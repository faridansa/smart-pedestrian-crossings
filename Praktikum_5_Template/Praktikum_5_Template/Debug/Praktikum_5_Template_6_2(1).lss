
Praktikum_5_Template_6_2(1).elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000040e4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000003e  00802000  000040e4  00004178  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000035d  0080203e  0080203e  000041b6  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000041b6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00004214  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000768  00000000  00000000  00004258  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00016445  00000000  00000000  000049c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00006250  00000000  00000000  0001ae05  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000c144  00000000  00000000  00021055  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001818  00000000  00000000  0002d19c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00038e41  00000000  00000000  0002e9b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000ad30  00000000  00000000  000677f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000930  00000000  00000000  00072528  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000ceda  00000000  00000000  00072e58  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	0c 94 00 0a 	jmp	0x1400	; 0x1400 <__vector_11>
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 e3 0f 	jmp	0x1fc6	; 0x1fc6 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	e9 c7       	rjmp	.+4050   	; 0x1070 <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 6a 08 	jmp	0x10d4	; 0x10d4 <__vector_40>
      a4:	0c 94 9c 08 	jmp	0x1138	; 0x1138 <__vector_41>
      a8:	0c 94 ce 08 	jmp	0x119c	; 0x119c <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	e1 c6       	rjmp	.+3522   	; 0xee0 <__vector_71>
     11e:	00 00       	nop
     120:	11 c7       	rjmp	.+3618   	; 0xf44 <__vector_72>
     122:	00 00       	nop
     124:	41 c7       	rjmp	.+3714   	; 0xfa8 <__vector_73>
     126:	00 00       	nop
     128:	71 c7       	rjmp	.+3810   	; 0x100c <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	e6 18       	sub	r14, r6
     1fe:	e6 18       	sub	r14, r6
     200:	e6 18       	sub	r14, r6
     202:	1c 19       	sub	r17, r12
     204:	0c 19       	sub	r16, r12
     206:	19 19       	sub	r17, r9
     208:	e6 18       	sub	r14, r6
     20a:	e6 18       	sub	r14, r6
     20c:	1c 19       	sub	r17, r12
     20e:	0c 19       	sub	r16, r12

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1d05>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x64ed>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x64c5>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x54ed>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1cc5>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e4 ee       	ldi	r30, 0xE4	; 228
     4ba:	f0 e4       	ldi	r31, 0x40	; 64
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	ae 33       	cpi	r26, 0x3E	; 62
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	ae e3       	ldi	r26, 0x3E	; 62
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	ab 39       	cpi	r26, 0x9B	; 155
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 17 1b 	call	0x362e	; 0x362e <main>
     4e0:	0c 94 70 20 	jmp	0x40e0	; 0x40e0 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
     4e6:	61 50       	subi	r22, 0x01	; 1
     4e8:	71 09       	sbc	r23, r1
     4ea:	81 09       	sbc	r24, r1
     4ec:	91 09       	sbc	r25, r1
     4ee:	d9 f7       	brne	.-10     	; 0x4e6 <__portable_avr_delay_cycles>
}
     4f0:	08 95       	ret

000004f2 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4f2:	bf 92       	push	r11
     4f4:	cf 92       	push	r12
     4f6:	df 92       	push	r13
     4f8:	ef 92       	push	r14
     4fa:	ff 92       	push	r15
     4fc:	0f 93       	push	r16
     4fe:	1f 93       	push	r17
     500:	cf 93       	push	r28
     502:	df 93       	push	r29
     504:	1f 92       	push	r1
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     50a:	00 e0       	ldi	r16, 0x00	; 0
     50c:	16 e0       	ldi	r17, 0x06	; 6
     50e:	68 94       	set
     510:	ff 24       	eor	r15, r15
     512:	f3 f8       	bld	r15, 3
     514:	f8 01       	movw	r30, r16
     516:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     518:	63 e0       	ldi	r22, 0x03	; 3
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	e2 df       	rcall	.-60     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     522:	f8 01       	movw	r30, r16
     524:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     526:	63 e0       	ldi	r22, 0x03	; 3
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	80 e0       	ldi	r24, 0x00	; 0
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	db df       	rcall	.-74     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     530:	0f 2e       	mov	r0, r31
     532:	fb e2       	ldi	r31, 0x2B	; 43
     534:	bf 2e       	mov	r11, r31
     536:	f0 2d       	mov	r31, r0
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     538:	b9 82       	std	Y+1, r11	; 0x01
     53a:	80 ea       	ldi	r24, 0xA0	; 160
     53c:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     53e:	08 d4       	rcall	.+2064   	; 0xd50 <usart_spi_init>
     540:	c1 2c       	mov	r12, r1
     542:	d1 2c       	mov	r13, r1
     544:	76 01       	movw	r14, r12
     546:	00 e4       	ldi	r16, 0x40	; 64
     548:	12 e4       	ldi	r17, 0x42	; 66
     54a:	2f e0       	ldi	r18, 0x0F	; 15
     54c:	30 e0       	ldi	r19, 0x00	; 0
     54e:	43 e0       	ldi	r20, 0x03	; 3
     550:	be 01       	movw	r22, r28
     552:	6f 5f       	subi	r22, 0xFF	; 255
     554:	7f 4f       	sbci	r23, 0xFF	; 255
     556:	80 ea       	ldi	r24, 0xA0	; 160
     558:	99 e0       	ldi	r25, 0x09	; 9
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     55a:	29 d4       	rcall	.+2130   	; 0xdae <usart_spi_setup_device>
     55c:	00 e6       	ldi	r16, 0x60	; 96
     55e:	16 e0       	ldi	r17, 0x06	; 6
     560:	ff 24       	eor	r15, r15
     562:	f3 94       	inc	r15
     564:	f8 01       	movw	r30, r16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     566:	f6 82       	std	Z+6, r15	; 0x06
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     568:	b9 82       	std	Y+1, r11	; 0x01
     56a:	be 01       	movw	r22, r28
     56c:	6f 5f       	subi	r22, 0xFF	; 255
     56e:	7f 4f       	sbci	r23, 0xFF	; 255
     570:	80 ea       	ldi	r24, 0xA0	; 160
     572:	99 e0       	ldi	r25, 0x09	; 9
     574:	36 d4       	rcall	.+2156   	; 0xde2 <usart_spi_select_device>
     576:	f8 01       	movw	r30, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     578:	f6 82       	std	Z+6, r15	; 0x06
     57a:	e0 ea       	ldi	r30, 0xA0	; 160
     57c:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     57e:	81 81       	ldd	r24, Z+1	; 0x01
     580:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     582:	fd cf       	rjmp	.-6      	; 0x57e <st7565r_init+0x8c>
     584:	80 ea       	ldi	r24, 0xA0	; 160
     586:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     58a:	e0 ea       	ldi	r30, 0xA0	; 160
     58c:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     58e:	81 81       	ldd	r24, Z+1	; 0x01
     590:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     592:	fd cf       	rjmp	.-6      	; 0x58e <st7565r_init+0x9c>
     594:	e0 ea       	ldi	r30, 0xA0	; 160
     596:	f9 e0       	ldi	r31, 0x09	; 9
     598:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     59a:	81 83       	std	Z+1, r24	; 0x01
     59c:	80 81       	ld	r24, Z
     59e:	be 01       	movw	r22, r28
     5a0:	6f 5f       	subi	r22, 0xFF	; 255
     5a2:	7f 4f       	sbci	r23, 0xFF	; 255
     5a4:	80 ea       	ldi	r24, 0xA0	; 160
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5a6:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5a8:	32 d4       	rcall	.+2148   	; 0xe0e <usart_spi_deselect_device>
     5aa:	8b e2       	ldi	r24, 0x2B	; 43
     5ac:	89 83       	std	Y+1, r24	; 0x01
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5f       	subi	r22, 0xFF	; 255
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	80 ea       	ldi	r24, 0xA0	; 160
     5b6:	99 e0       	ldi	r25, 0x09	; 9
     5b8:	14 d4       	rcall	.+2088   	; 0xde2 <usart_spi_select_device>
     5ba:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5bc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     5c0:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5c2:	f9 e0       	ldi	r31, 0x09	; 9
     5c4:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5c6:	85 ff       	sbrs	r24, 5
     5c8:	fd cf       	rjmp	.-6      	; 0x5c4 <st7565r_init+0xd2>
     5ca:	86 ea       	ldi	r24, 0xA6	; 166
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5cc:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     5d0:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5d2:	f9 e0       	ldi	r31, 0x09	; 9
     5d4:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5d6:	86 ff       	sbrs	r24, 6
     5d8:	fd cf       	rjmp	.-6      	; 0x5d4 <st7565r_init+0xe2>
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5dc:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5de:	80 e4       	ldi	r24, 0x40	; 64
     5e0:	81 83       	std	Z+1, r24	; 0x01
     5e2:	80 81       	ld	r24, Z
     5e4:	be 01       	movw	r22, r28
     5e6:	6f 5f       	subi	r22, 0xFF	; 255
     5e8:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5ea:	80 ea       	ldi	r24, 0xA0	; 160
     5ec:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5ee:	0f d4       	rcall	.+2078   	; 0xe0e <usart_spi_deselect_device>
     5f0:	8b e2       	ldi	r24, 0x2B	; 43
     5f2:	89 83       	std	Y+1, r24	; 0x01
     5f4:	be 01       	movw	r22, r28
     5f6:	6f 5f       	subi	r22, 0xFF	; 255
     5f8:	7f 4f       	sbci	r23, 0xFF	; 255
     5fa:	80 ea       	ldi	r24, 0xA0	; 160
     5fc:	99 e0       	ldi	r25, 0x09	; 9
     5fe:	f1 d3       	rcall	.+2018   	; 0xde2 <usart_spi_select_device>
     600:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     602:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     606:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     608:	f9 e0       	ldi	r31, 0x09	; 9
     60a:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     60c:	85 ff       	sbrs	r24, 5
     60e:	fd cf       	rjmp	.-6      	; 0x60a <st7565r_init+0x118>
     610:	88 ec       	ldi	r24, 0xC8	; 200
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     612:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     616:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     618:	f9 e0       	ldi	r31, 0x09	; 9
     61a:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     61c:	86 ff       	sbrs	r24, 6
     61e:	fd cf       	rjmp	.-6      	; 0x61a <st7565r_init+0x128>
     620:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     622:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     624:	80 e4       	ldi	r24, 0x40	; 64
     626:	81 83       	std	Z+1, r24	; 0x01
     628:	80 81       	ld	r24, Z
     62a:	be 01       	movw	r22, r28
     62c:	6f 5f       	subi	r22, 0xFF	; 255
     62e:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     630:	80 ea       	ldi	r24, 0xA0	; 160
     632:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     634:	ec d3       	rcall	.+2008   	; 0xe0e <usart_spi_deselect_device>
     636:	8b e2       	ldi	r24, 0x2B	; 43
     638:	89 83       	std	Y+1, r24	; 0x01
     63a:	be 01       	movw	r22, r28
     63c:	6f 5f       	subi	r22, 0xFF	; 255
     63e:	7f 4f       	sbci	r23, 0xFF	; 255
     640:	80 ea       	ldi	r24, 0xA0	; 160
     642:	99 e0       	ldi	r25, 0x09	; 9
     644:	ce d3       	rcall	.+1948   	; 0xde2 <usart_spi_select_device>
     646:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     648:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     64c:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     64e:	f9 e0       	ldi	r31, 0x09	; 9
     650:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     652:	85 ff       	sbrs	r24, 5
     654:	fd cf       	rjmp	.-6      	; 0x650 <st7565r_init+0x15e>
     656:	82 ea       	ldi	r24, 0xA2	; 162
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     658:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     65c:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     65e:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     660:	81 81       	ldd	r24, Z+1	; 0x01
     662:	86 ff       	sbrs	r24, 6
     664:	fd cf       	rjmp	.-6      	; 0x660 <st7565r_init+0x16e>
     666:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     668:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     66a:	80 e4       	ldi	r24, 0x40	; 64
     66c:	81 83       	std	Z+1, r24	; 0x01
     66e:	80 81       	ld	r24, Z
     670:	be 01       	movw	r22, r28
     672:	6f 5f       	subi	r22, 0xFF	; 255
     674:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     676:	80 ea       	ldi	r24, 0xA0	; 160
     678:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     67a:	c9 d3       	rcall	.+1938   	; 0xe0e <usart_spi_deselect_device>
     67c:	8b e2       	ldi	r24, 0x2B	; 43
     67e:	89 83       	std	Y+1, r24	; 0x01
     680:	be 01       	movw	r22, r28
     682:	6f 5f       	subi	r22, 0xFF	; 255
     684:	7f 4f       	sbci	r23, 0xFF	; 255
     686:	80 ea       	ldi	r24, 0xA0	; 160
     688:	99 e0       	ldi	r25, 0x09	; 9
     68a:	ab d3       	rcall	.+1878   	; 0xde2 <usart_spi_select_device>
     68c:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     68e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     692:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     694:	f9 e0       	ldi	r31, 0x09	; 9
     696:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     698:	85 ff       	sbrs	r24, 5
     69a:	fd cf       	rjmp	.-6      	; 0x696 <st7565r_init+0x1a4>
     69c:	8f e2       	ldi	r24, 0x2F	; 47
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     69e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6a2:	e0 ea       	ldi	r30, 0xA0	; 160
     6a4:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6a6:	81 81       	ldd	r24, Z+1	; 0x01
     6a8:	86 ff       	sbrs	r24, 6
     6aa:	fd cf       	rjmp	.-6      	; 0x6a6 <st7565r_init+0x1b4>
     6ac:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6ae:	f9 e0       	ldi	r31, 0x09	; 9
     6b0:	80 e4       	ldi	r24, 0x40	; 64
     6b2:	81 83       	std	Z+1, r24	; 0x01
     6b4:	80 81       	ld	r24, Z
     6b6:	be 01       	movw	r22, r28
     6b8:	6f 5f       	subi	r22, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ba:	7f 4f       	sbci	r23, 0xFF	; 255
     6bc:	80 ea       	ldi	r24, 0xA0	; 160
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6be:	99 e0       	ldi	r25, 0x09	; 9
     6c0:	a6 d3       	rcall	.+1868   	; 0xe0e <usart_spi_deselect_device>
     6c2:	8b e2       	ldi	r24, 0x2B	; 43
     6c4:	89 83       	std	Y+1, r24	; 0x01
     6c6:	be 01       	movw	r22, r28
     6c8:	6f 5f       	subi	r22, 0xFF	; 255
     6ca:	7f 4f       	sbci	r23, 0xFF	; 255
     6cc:	80 ea       	ldi	r24, 0xA0	; 160
     6ce:	99 e0       	ldi	r25, 0x09	; 9
     6d0:	88 d3       	rcall	.+1808   	; 0xde2 <usart_spi_select_device>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6d8:	e0 ea       	ldi	r30, 0xA0	; 160
     6da:	f9 e0       	ldi	r31, 0x09	; 9
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6dc:	81 81       	ldd	r24, Z+1	; 0x01
     6de:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6e0:	fd cf       	rjmp	.-6      	; 0x6dc <st7565r_init+0x1ea>
     6e2:	88 ef       	ldi	r24, 0xF8	; 248
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6e4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6e8:	e0 ea       	ldi	r30, 0xA0	; 160
     6ea:	f9 e0       	ldi	r31, 0x09	; 9
     6ec:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6ee:	86 ff       	sbrs	r24, 6
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6f0:	fd cf       	rjmp	.-6      	; 0x6ec <st7565r_init+0x1fa>
     6f2:	e0 ea       	ldi	r30, 0xA0	; 160
     6f4:	f9 e0       	ldi	r31, 0x09	; 9
     6f6:	80 e4       	ldi	r24, 0x40	; 64
     6f8:	81 83       	std	Z+1, r24	; 0x01
     6fa:	80 81       	ld	r24, Z
     6fc:	be 01       	movw	r22, r28
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6fe:	6f 5f       	subi	r22, 0xFF	; 255
     700:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	99 e0       	ldi	r25, 0x09	; 9
     706:	83 d3       	rcall	.+1798   	; 0xe0e <usart_spi_deselect_device>
     708:	8b e2       	ldi	r24, 0x2B	; 43
     70a:	89 83       	std	Y+1, r24	; 0x01
     70c:	be 01       	movw	r22, r28
     70e:	6f 5f       	subi	r22, 0xFF	; 255
     710:	7f 4f       	sbci	r23, 0xFF	; 255
     712:	80 ea       	ldi	r24, 0xA0	; 160
     714:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     716:	65 d3       	rcall	.+1738   	; 0xde2 <usart_spi_select_device>
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     71e:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     720:	f9 e0       	ldi	r31, 0x09	; 9
     722:	81 81       	ldd	r24, Z+1	; 0x01
     724:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     726:	fd cf       	rjmp	.-6      	; 0x722 <st7565r_init+0x230>
     728:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     72c:	e0 ea       	ldi	r30, 0xA0	; 160
     72e:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     730:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     732:	86 ff       	sbrs	r24, 6
     734:	fd cf       	rjmp	.-6      	; 0x730 <st7565r_init+0x23e>
     736:	e0 ea       	ldi	r30, 0xA0	; 160
     738:	f9 e0       	ldi	r31, 0x09	; 9
     73a:	80 e4       	ldi	r24, 0x40	; 64
     73c:	81 83       	std	Z+1, r24	; 0x01
     73e:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     740:	be 01       	movw	r22, r28
     742:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     744:	7f 4f       	sbci	r23, 0xFF	; 255
     746:	80 ea       	ldi	r24, 0xA0	; 160
     748:	99 e0       	ldi	r25, 0x09	; 9
     74a:	61 d3       	rcall	.+1730   	; 0xe0e <usart_spi_deselect_device>
     74c:	8b e2       	ldi	r24, 0x2B	; 43
     74e:	89 83       	std	Y+1, r24	; 0x01
     750:	be 01       	movw	r22, r28
     752:	6f 5f       	subi	r22, 0xFF	; 255
     754:	7f 4f       	sbci	r23, 0xFF	; 255
     756:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     758:	99 e0       	ldi	r25, 0x09	; 9
     75a:	43 d3       	rcall	.+1670   	; 0xde2 <usart_spi_select_device>
     75c:	81 e0       	ldi	r24, 0x01	; 1
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     75e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     762:	e0 ea       	ldi	r30, 0xA0	; 160
     764:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     766:	81 81       	ldd	r24, Z+1	; 0x01
     768:	85 ff       	sbrs	r24, 5
     76a:	fd cf       	rjmp	.-6      	; 0x766 <st7565r_init+0x274>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     76c:	81 e2       	ldi	r24, 0x21	; 33
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     76e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     772:	e0 ea       	ldi	r30, 0xA0	; 160
     774:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     776:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     778:	86 ff       	sbrs	r24, 6
     77a:	fd cf       	rjmp	.-6      	; 0x776 <st7565r_init+0x284>
     77c:	e0 ea       	ldi	r30, 0xA0	; 160
     77e:	f9 e0       	ldi	r31, 0x09	; 9
     780:	80 e4       	ldi	r24, 0x40	; 64
     782:	81 83       	std	Z+1, r24	; 0x01
     784:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     786:	be 01       	movw	r22, r28
     788:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     78a:	7f 4f       	sbci	r23, 0xFF	; 255
     78c:	80 ea       	ldi	r24, 0xA0	; 160
     78e:	99 e0       	ldi	r25, 0x09	; 9
     790:	3e d3       	rcall	.+1660   	; 0xe0e <usart_spi_deselect_device>
     792:	8b e2       	ldi	r24, 0x2B	; 43
     794:	89 83       	std	Y+1, r24	; 0x01
     796:	be 01       	movw	r22, r28
     798:	6f 5f       	subi	r22, 0xFF	; 255
     79a:	7f 4f       	sbci	r23, 0xFF	; 255
     79c:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     79e:	99 e0       	ldi	r25, 0x09	; 9
     7a0:	20 d3       	rcall	.+1600   	; 0xde2 <usart_spi_select_device>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7a8:	e0 ea       	ldi	r30, 0xA0	; 160
     7aa:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7ac:	81 81       	ldd	r24, Z+1	; 0x01
     7ae:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7b0:	fd cf       	rjmp	.-6      	; 0x7ac <st7565r_init+0x2ba>
     7b2:	81 e8       	ldi	r24, 0x81	; 129
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7b4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     7b8:	e0 ea       	ldi	r30, 0xA0	; 160
     7ba:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7bc:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7be:	86 ff       	sbrs	r24, 6
     7c0:	fd cf       	rjmp	.-6      	; 0x7bc <st7565r_init+0x2ca>
     7c2:	e0 ea       	ldi	r30, 0xA0	; 160
     7c4:	f9 e0       	ldi	r31, 0x09	; 9
     7c6:	80 e4       	ldi	r24, 0x40	; 64
     7c8:	81 83       	std	Z+1, r24	; 0x01
     7ca:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7cc:	be 01       	movw	r22, r28
     7ce:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7d0:	7f 4f       	sbci	r23, 0xFF	; 255
     7d2:	80 ea       	ldi	r24, 0xA0	; 160
     7d4:	99 e0       	ldi	r25, 0x09	; 9
     7d6:	1b d3       	rcall	.+1590   	; 0xe0e <usart_spi_deselect_device>
     7d8:	8b e2       	ldi	r24, 0x2B	; 43
     7da:	89 83       	std	Y+1, r24	; 0x01
     7dc:	be 01       	movw	r22, r28
     7de:	6f 5f       	subi	r22, 0xFF	; 255
     7e0:	7f 4f       	sbci	r23, 0xFF	; 255
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7e2:	80 ea       	ldi	r24, 0xA0	; 160
     7e4:	99 e0       	ldi	r25, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7e6:	fd d2       	rcall	.+1530   	; 0xde2 <usart_spi_select_device>
     7e8:	81 e0       	ldi	r24, 0x01	; 1
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7ea:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7ee:	e0 ea       	ldi	r30, 0xA0	; 160
     7f0:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7f2:	81 81       	ldd	r24, Z+1	; 0x01
     7f4:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7f6:	fd cf       	rjmp	.-6      	; 0x7f2 <st7565r_init+0x300>
     7f8:	81 e2       	ldi	r24, 0x21	; 33
     7fa:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7fe:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     800:	f9 e0       	ldi	r31, 0x09	; 9
     802:	81 81       	ldd	r24, Z+1	; 0x01
     804:	86 ff       	sbrs	r24, 6
     806:	fd cf       	rjmp	.-6      	; 0x802 <st7565r_init+0x310>
     808:	e0 ea       	ldi	r30, 0xA0	; 160
     80a:	f9 e0       	ldi	r31, 0x09	; 9
     80c:	80 e4       	ldi	r24, 0x40	; 64
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     80e:	81 83       	std	Z+1, r24	; 0x01
     810:	80 81       	ld	r24, Z
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     812:	be 01       	movw	r22, r28
     814:	6f 5f       	subi	r22, 0xFF	; 255
     816:	7f 4f       	sbci	r23, 0xFF	; 255
     818:	80 ea       	ldi	r24, 0xA0	; 160
     81a:	99 e0       	ldi	r25, 0x09	; 9
     81c:	f8 d2       	rcall	.+1520   	; 0xe0e <usart_spi_deselect_device>
     81e:	8b e2       	ldi	r24, 0x2B	; 43
     820:	89 83       	std	Y+1, r24	; 0x01
     822:	be 01       	movw	r22, r28
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     824:	6f 5f       	subi	r22, 0xFF	; 255
     826:	7f 4f       	sbci	r23, 0xFF	; 255
     828:	80 ea       	ldi	r24, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     82a:	99 e0       	ldi	r25, 0x09	; 9
     82c:	da d2       	rcall	.+1460   	; 0xde2 <usart_spi_select_device>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     834:	e0 ea       	ldi	r30, 0xA0	; 160
     836:	f9 e0       	ldi	r31, 0x09	; 9
     838:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     83a:	85 ff       	sbrs	r24, 5
     83c:	fd cf       	rjmp	.-6      	; 0x838 <st7565r_init+0x346>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     83e:	8f ea       	ldi	r24, 0xAF	; 175
     840:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     844:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     846:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     848:	81 81       	ldd	r24, Z+1	; 0x01
     84a:	86 ff       	sbrs	r24, 6
     84c:	fd cf       	rjmp	.-6      	; 0x848 <st7565r_init+0x356>
     84e:	e0 ea       	ldi	r30, 0xA0	; 160
     850:	f9 e0       	ldi	r31, 0x09	; 9
     852:	80 e4       	ldi	r24, 0x40	; 64
     854:	81 83       	std	Z+1, r24	; 0x01
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     856:	80 81       	ld	r24, Z
     858:	be 01       	movw	r22, r28
     85a:	6f 5f       	subi	r22, 0xFF	; 255
     85c:	7f 4f       	sbci	r23, 0xFF	; 255
     85e:	80 ea       	ldi	r24, 0xA0	; 160
     860:	99 e0       	ldi	r25, 0x09	; 9
     862:	d5 d2       	rcall	.+1450   	; 0xe0e <usart_spi_deselect_device>
     864:	0f 90       	pop	r0
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	1f 91       	pop	r17
     86c:	0f 91       	pop	r16
     86e:	ff 90       	pop	r15
     870:	ef 90       	pop	r14
     872:	df 90       	pop	r13
     874:	cf 90       	pop	r12
     876:	bf 90       	pop	r11
     878:	08 95       	ret

0000087a <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
     87a:	8f ef       	ldi	r24, 0xFF	; 255
     87c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
     880:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
     884:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
     888:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
     88c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
     890:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
     894:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
     898:	08 95       	ret

0000089a <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     89a:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     89c:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     89e:	e8 2f       	mov	r30, r24
     8a0:	f0 e0       	ldi	r31, 0x00	; 0
     8a2:	e0 59       	subi	r30, 0x90	; 144
     8a4:	ff 4f       	sbci	r31, 0xFF	; 255
     8a6:	60 95       	com	r22
     8a8:	80 81       	ld	r24, Z
     8aa:	68 23       	and	r22, r24
     8ac:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8ae:	9f bf       	out	0x3f, r25	; 63
     8b0:	08 95       	ret

000008b2 <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     8b2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     8b4:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     8b6:	e8 2f       	mov	r30, r24
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	e0 59       	subi	r30, 0x90	; 144
     8bc:	ff 4f       	sbci	r31, 0xFF	; 255
     8be:	80 81       	ld	r24, Z
     8c0:	68 2b       	or	r22, r24
     8c2:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8c4:	9f bf       	out	0x3f, r25	; 63
     8c6:	08 95       	ret

000008c8 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8c8:	ff 92       	push	r15
     8ca:	0f 93       	push	r16
     8cc:	1f 93       	push	r17
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	1f 92       	push	r1
     8d4:	cd b7       	in	r28, 0x3d	; 61
     8d6:	de b7       	in	r29, 0x3e	; 62
     8d8:	08 2f       	mov	r16, r24
     8da:	f6 2e       	mov	r15, r22
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8dc:	14 2f       	mov	r17, r20
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8de:	1a d1       	rcall	.+564    	; 0xb14 <gfx_mono_framebuffer_put_byte>
     8e0:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8e2:	00 6b       	ori	r16, 0xB0	; 176
     8e4:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8e6:	89 83       	std	Y+1, r24	; 0x01
     8e8:	be 01       	movw	r22, r28
     8ea:	6f 5f       	subi	r22, 0xFF	; 255
     8ec:	7f 4f       	sbci	r23, 0xFF	; 255
     8ee:	80 ea       	ldi	r24, 0xA0	; 160
     8f0:	99 e0       	ldi	r25, 0x09	; 9
     8f2:	77 d2       	rcall	.+1262   	; 0xde2 <usart_spi_select_device>
     8f4:	81 e0       	ldi	r24, 0x01	; 1
     8f6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8fa:	e0 ea       	ldi	r30, 0xA0	; 160
     8fc:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8fe:	91 81       	ldd	r25, Z+1	; 0x01
     900:	95 ff       	sbrs	r25, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     902:	fd cf       	rjmp	.-6      	; 0x8fe <gfx_mono_st7565r_put_byte+0x36>
     904:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     908:	e0 ea       	ldi	r30, 0xA0	; 160
     90a:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     90c:	81 81       	ldd	r24, Z+1	; 0x01
     90e:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     910:	fd cf       	rjmp	.-6      	; 0x90c <gfx_mono_st7565r_put_byte+0x44>
     912:	e0 ea       	ldi	r30, 0xA0	; 160
     914:	f9 e0       	ldi	r31, 0x09	; 9
     916:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     918:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     91a:	80 81       	ld	r24, Z
     91c:	be 01       	movw	r22, r28
     91e:	6f 5f       	subi	r22, 0xFF	; 255
     920:	7f 4f       	sbci	r23, 0xFF	; 255
     922:	80 ea       	ldi	r24, 0xA0	; 160
     924:	99 e0       	ldi	r25, 0x09	; 9
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     926:	73 d2       	rcall	.+1254   	; 0xe0e <usart_spi_deselect_device>
     928:	0f 2d       	mov	r16, r15
     92a:	0f 77       	andi	r16, 0x7F	; 127
     92c:	02 95       	swap	r16
     92e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     930:	00 61       	ori	r16, 0x10	; 16
     932:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     934:	89 83       	std	Y+1, r24	; 0x01
     936:	be 01       	movw	r22, r28
     938:	6f 5f       	subi	r22, 0xFF	; 255
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	80 ea       	ldi	r24, 0xA0	; 160
     93e:	99 e0       	ldi	r25, 0x09	; 9
     940:	50 d2       	rcall	.+1184   	; 0xde2 <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94c:	81 81       	ldd	r24, Z+1	; 0x01
     94e:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0x84>
     952:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95a:	81 81       	ldd	r24, Z+1	; 0x01
     95c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0x92>
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     966:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     968:	80 81       	ld	r24, Z
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     974:	4c d2       	rcall	.+1176   	; 0xe0e <usart_spi_deselect_device>
     976:	0f 2d       	mov	r16, r15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     978:	0f 70       	andi	r16, 0x0F	; 15
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     97a:	8b e2       	ldi	r24, 0x2B	; 43
     97c:	89 83       	std	Y+1, r24	; 0x01
     97e:	be 01       	movw	r22, r28
     980:	6f 5f       	subi	r22, 0xFF	; 255
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	80 ea       	ldi	r24, 0xA0	; 160
     986:	99 e0       	ldi	r25, 0x09	; 9
     988:	2c d2       	rcall	.+1112   	; 0xde2 <usart_spi_select_device>
     98a:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     98c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     990:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     992:	f9 e0       	ldi	r31, 0x09	; 9
     994:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     996:	85 ff       	sbrs	r24, 5
     998:	fd cf       	rjmp	.-6      	; 0x994 <gfx_mono_st7565r_put_byte+0xcc>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     99a:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     99e:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a0:	f9 e0       	ldi	r31, 0x09	; 9
     9a2:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a4:	86 ff       	sbrs	r24, 6
     9a6:	fd cf       	rjmp	.-6      	; 0x9a2 <gfx_mono_st7565r_put_byte+0xda>
     9a8:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9aa:	f9 e0       	ldi	r31, 0x09	; 9
     9ac:	80 e4       	ldi	r24, 0x40	; 64
     9ae:	81 83       	std	Z+1, r24	; 0x01
     9b0:	80 81       	ld	r24, Z
     9b2:	be 01       	movw	r22, r28
     9b4:	6f 5f       	subi	r22, 0xFF	; 255
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9b6:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9b8:	80 ea       	ldi	r24, 0xA0	; 160
     9ba:	99 e0       	ldi	r25, 0x09	; 9
     9bc:	28 d2       	rcall	.+1104   	; 0xe0e <usart_spi_deselect_device>
     9be:	8b e2       	ldi	r24, 0x2B	; 43
     9c0:	89 83       	std	Y+1, r24	; 0x01
     9c2:	be 01       	movw	r22, r28
     9c4:	6f 5f       	subi	r22, 0xFF	; 255
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9c6:	7f 4f       	sbci	r23, 0xFF	; 255
     9c8:	80 ea       	ldi	r24, 0xA0	; 160
     9ca:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9cc:	0a d2       	rcall	.+1044   	; 0xde2 <usart_spi_select_device>
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9d4:	e0 ea       	ldi	r30, 0xA0	; 160
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9d6:	f9 e0       	ldi	r31, 0x09	; 9
     9d8:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9da:	85 ff       	sbrs	r24, 5
     9dc:	fd cf       	rjmp	.-6      	; 0x9d8 <gfx_mono_st7565r_put_byte+0x110>
     9de:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9e2:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9e4:	f9 e0       	ldi	r31, 0x09	; 9
     9e6:	81 81       	ldd	r24, Z+1	; 0x01
     9e8:	86 ff       	sbrs	r24, 6
     9ea:	fd cf       	rjmp	.-6      	; 0x9e6 <gfx_mono_st7565r_put_byte+0x11e>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ec:	e0 ea       	ldi	r30, 0xA0	; 160
     9ee:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9f0:	80 e4       	ldi	r24, 0x40	; 64
     9f2:	81 83       	std	Z+1, r24	; 0x01
     9f4:	80 81       	ld	r24, Z
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     9fc:	be 01       	movw	r22, r28

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9fe:	6f 5f       	subi	r22, 0xFF	; 255
     a00:	7f 4f       	sbci	r23, 0xFF	; 255
     a02:	80 ea       	ldi	r24, 0xA0	; 160
     a04:	99 e0       	ldi	r25, 0x09	; 9
     a06:	03 d2       	rcall	.+1030   	; 0xe0e <usart_spi_deselect_device>
     a08:	0f 90       	pop	r0
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	ff 90       	pop	r15
     a14:	08 95       	ret

00000a16 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a16:	0f 93       	push	r16
     a18:	1f 93       	push	r17
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	1f 92       	push	r1
     a20:	cd b7       	in	r28, 0x3d	; 61
     a22:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a24:	8e e3       	ldi	r24, 0x3E	; 62
     a26:	90 e2       	ldi	r25, 0x20	; 32
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a28:	70 d0       	rcall	.+224    	; 0xb0a <gfx_mono_set_framebuffer>
     a2a:	63 dd       	rcall	.-1338   	; 0x4f2 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a2c:	8b e2       	ldi	r24, 0x2B	; 43
     a2e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a30:	be 01       	movw	r22, r28
     a32:	6f 5f       	subi	r22, 0xFF	; 255
     a34:	7f 4f       	sbci	r23, 0xFF	; 255
     a36:	80 ea       	ldi	r24, 0xA0	; 160
     a38:	99 e0       	ldi	r25, 0x09	; 9
     a3a:	d3 d1       	rcall	.+934    	; 0xde2 <usart_spi_select_device>
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a42:	e0 ea       	ldi	r30, 0xA0	; 160
     a44:	f9 e0       	ldi	r31, 0x09	; 9
     a46:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a48:	85 ff       	sbrs	r24, 5
     a4a:	fd cf       	rjmp	.-6      	; 0xa46 <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a4c:	80 e4       	ldi	r24, 0x40	; 64
     a4e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a52:	e0 ea       	ldi	r30, 0xA0	; 160
     a54:	f9 e0       	ldi	r31, 0x09	; 9
     a56:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a58:	86 ff       	sbrs	r24, 6
     a5a:	fd cf       	rjmp	.-6      	; 0xa56 <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a5c:	e0 ea       	ldi	r30, 0xA0	; 160
     a5e:	f9 e0       	ldi	r31, 0x09	; 9
     a60:	80 e4       	ldi	r24, 0x40	; 64
     a62:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a64:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a66:	be 01       	movw	r22, r28
     a68:	6f 5f       	subi	r22, 0xFF	; 255
     a6a:	7f 4f       	sbci	r23, 0xFF	; 255
     a6c:	80 ea       	ldi	r24, 0xA0	; 160
     a6e:	99 e0       	ldi	r25, 0x09	; 9
     a70:	ce d1       	rcall	.+924    	; 0xe0e <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a72:	00 e0       	ldi	r16, 0x00	; 0
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a74:	0a c0       	rjmp	.+20     	; 0xa8a <gfx_mono_st7565r_init+0x74>
     a76:	40 e0       	ldi	r20, 0x00	; 0
     a78:	61 2f       	mov	r22, r17
     a7a:	80 2f       	mov	r24, r16
     a7c:	25 df       	rcall	.-438    	; 0x8c8 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a7e:	1f 5f       	subi	r17, 0xFF	; 255
     a80:	10 38       	cpi	r17, 0x80	; 128
     a82:	c9 f7       	brne	.-14     	; 0xa76 <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a84:	0f 5f       	subi	r16, 0xFF	; 255
     a86:	04 30       	cpi	r16, 0x04	; 4
     a88:	11 f0       	breq	.+4      	; 0xa8e <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a8a:	10 e0       	ldi	r17, 0x00	; 0
     a8c:	f4 cf       	rjmp	.-24     	; 0xa76 <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a8e:	0f 90       	pop	r0
     a90:	df 91       	pop	r29
     a92:	cf 91       	pop	r28
     a94:	1f 91       	pop	r17
     a96:	0f 91       	pop	r16
     a98:	08 95       	ret

00000a9a <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a9a:	ff 92       	push	r15
     a9c:	0f 93       	push	r16
     a9e:	1f 93       	push	r17
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     aa4:	88 23       	and	r24, r24
     aa6:	4c f1       	brlt	.+82     	; 0xafa <gfx_mono_st7565r_draw_pixel+0x60>
     aa8:	60 32       	cpi	r22, 0x20	; 32
     aaa:	38 f5       	brcc	.+78     	; 0xafa <gfx_mono_st7565r_draw_pixel+0x60>
     aac:	d4 2f       	mov	r29, r20
     aae:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ab0:	f6 2e       	mov	r15, r22
     ab2:	f6 94       	lsr	r15
     ab4:	f6 94       	lsr	r15
     ab6:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     ab8:	70 e0       	ldi	r23, 0x00	; 0
     aba:	88 e0       	ldi	r24, 0x08	; 8
     abc:	f8 9e       	mul	r15, r24
     abe:	60 19       	sub	r22, r0
     ac0:	71 09       	sbc	r23, r1
     ac2:	11 24       	eor	r1, r1
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	8c 01       	movw	r16, r24
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <gfx_mono_st7565r_draw_pixel+0x36>
     acc:	00 0f       	add	r16, r16
     ace:	11 1f       	adc	r17, r17
     ad0:	6a 95       	dec	r22
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ad4:	6c 2f       	mov	r22, r28
     ad6:	8f 2d       	mov	r24, r15
     ad8:	2b d0       	rcall	.+86     	; 0xb30 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ada:	d1 30       	cpi	r29, 0x01	; 1
     adc:	21 f0       	breq	.+8      	; 0xae6 <gfx_mono_st7565r_draw_pixel+0x4c>
     ade:	28 f0       	brcs	.+10     	; 0xaea <gfx_mono_st7565r_draw_pixel+0x50>
     ae0:	d2 30       	cpi	r29, 0x02	; 2
     ae2:	31 f0       	breq	.+12     	; 0xaf0 <gfx_mono_st7565r_draw_pixel+0x56>
     ae4:	06 c0       	rjmp	.+12     	; 0xaf2 <gfx_mono_st7565r_draw_pixel+0x58>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     ae6:	80 2b       	or	r24, r16
		break;
     ae8:	04 c0       	rjmp	.+8      	; 0xaf2 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     aea:	00 95       	com	r16
     aec:	80 23       	and	r24, r16
		break;
     aee:	01 c0       	rjmp	.+2      	; 0xaf2 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     af0:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     af2:	48 2f       	mov	r20, r24
     af4:	6c 2f       	mov	r22, r28
     af6:	8f 2d       	mov	r24, r15
     af8:	e7 de       	rcall	.-562    	; 0x8c8 <gfx_mono_st7565r_put_byte>
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	ff 90       	pop	r15
     b04:	08 95       	ret

00000b06 <gfx_mono_st7565r_get_byte>:
 * \code
	data = gfx_mono_st7565r_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
     b06:	14 c0       	rjmp	.+40     	; 0xb30 <gfx_mono_framebuffer_get_byte>
     b08:	08 95       	ret

00000b0a <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     b0a:	80 93 3e 22 	sts	0x223E, r24	; 0x80223e <fbpointer>
     b0e:	90 93 3f 22 	sts	0x223F, r25	; 0x80223f <fbpointer+0x1>
     b12:	08 95       	ret

00000b14 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     b14:	20 91 3e 22 	lds	r18, 0x223E	; 0x80223e <fbpointer>
     b18:	30 91 3f 22 	lds	r19, 0x223F	; 0x80223f <fbpointer+0x1>
     b1c:	90 e8       	ldi	r25, 0x80	; 128
     b1e:	89 9f       	mul	r24, r25
     b20:	20 0d       	add	r18, r0
     b22:	31 1d       	adc	r19, r1
     b24:	11 24       	eor	r1, r1
     b26:	f9 01       	movw	r30, r18
     b28:	e6 0f       	add	r30, r22
     b2a:	f1 1d       	adc	r31, r1
     b2c:	40 83       	st	Z, r20
     b2e:	08 95       	ret

00000b30 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     b30:	20 91 3e 22 	lds	r18, 0x223E	; 0x80223e <fbpointer>
     b34:	30 91 3f 22 	lds	r19, 0x223F	; 0x80223f <fbpointer+0x1>
     b38:	90 e8       	ldi	r25, 0x80	; 128
     b3a:	89 9f       	mul	r24, r25
     b3c:	20 0d       	add	r18, r0
     b3e:	31 1d       	adc	r19, r1
     b40:	11 24       	eor	r1, r1
     b42:	f9 01       	movw	r30, r18
     b44:	e6 0f       	add	r30, r22
     b46:	f1 1d       	adc	r31, r1
}
     b48:	80 81       	ld	r24, Z
     b4a:	08 95       	ret

00000b4c <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b4c:	ff 92       	push	r15
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	e4 2f       	mov	r30, r20
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	e8 0f       	add	r30, r24
     b5c:	f1 1d       	adc	r31, r1
     b5e:	e1 38       	cpi	r30, 0x81	; 129
     b60:	f1 05       	cpc	r31, r1
     b62:	1c f0       	brlt	.+6      	; 0xb6a <gfx_mono_generic_draw_horizontal_line+0x1e>
     b64:	c0 e8       	ldi	r28, 0x80	; 128
     b66:	4c 2f       	mov	r20, r28
     b68:	48 1b       	sub	r20, r24
     b6a:	44 23       	and	r20, r20
     b6c:	09 f4       	brne	.+2      	; 0xb70 <gfx_mono_generic_draw_horizontal_line+0x24>
     b6e:	4a c0       	rjmp	.+148    	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     b70:	d6 2f       	mov	r29, r22
     b72:	d6 95       	lsr	r29
     b74:	d6 95       	lsr	r29
     b76:	d6 95       	lsr	r29
     b78:	70 e0       	ldi	r23, 0x00	; 0
     b7a:	98 e0       	ldi	r25, 0x08	; 8
     b7c:	d9 9f       	mul	r29, r25
     b7e:	60 19       	sub	r22, r0
     b80:	71 09       	sbc	r23, r1
     b82:	11 24       	eor	r1, r1
     b84:	e1 e0       	ldi	r30, 0x01	; 1
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	df 01       	movw	r26, r30
     b8a:	02 c0       	rjmp	.+4      	; 0xb90 <gfx_mono_generic_draw_horizontal_line+0x44>
     b8c:	aa 0f       	add	r26, r26
     b8e:	bb 1f       	adc	r27, r27
     b90:	6a 95       	dec	r22
     b92:	e2 f7       	brpl	.-8      	; 0xb8c <gfx_mono_generic_draw_horizontal_line+0x40>
     b94:	fa 2e       	mov	r15, r26
     b96:	21 30       	cpi	r18, 0x01	; 1
     b98:	21 f0       	breq	.+8      	; 0xba2 <gfx_mono_generic_draw_horizontal_line+0x56>
     b9a:	98 f0       	brcs	.+38     	; 0xbc2 <gfx_mono_generic_draw_horizontal_line+0x76>
     b9c:	22 30       	cpi	r18, 0x02	; 2
     b9e:	19 f1       	breq	.+70     	; 0xbe6 <gfx_mono_generic_draw_horizontal_line+0x9a>
     ba0:	31 c0       	rjmp	.+98     	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     ba2:	c4 2f       	mov	r28, r20
     ba4:	1f ef       	ldi	r17, 0xFF	; 255
     ba6:	18 0f       	add	r17, r24
     ba8:	01 2f       	mov	r16, r17
     baa:	0c 0f       	add	r16, r28
     bac:	60 2f       	mov	r22, r16
     bae:	8d 2f       	mov	r24, r29
     bb0:	aa df       	rcall	.-172    	; 0xb06 <gfx_mono_st7565r_get_byte>
     bb2:	4f 2d       	mov	r20, r15
     bb4:	48 2b       	or	r20, r24
     bb6:	60 2f       	mov	r22, r16
     bb8:	8d 2f       	mov	r24, r29
     bba:	86 de       	rcall	.-756    	; 0x8c8 <gfx_mono_st7565r_put_byte>
     bbc:	c1 50       	subi	r28, 0x01	; 1
     bbe:	a1 f7       	brne	.-24     	; 0xba8 <gfx_mono_generic_draw_horizontal_line+0x5c>
     bc0:	21 c0       	rjmp	.+66     	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     bc2:	c4 2f       	mov	r28, r20
     bc4:	1f ef       	ldi	r17, 0xFF	; 255
     bc6:	18 0f       	add	r17, r24
     bc8:	fa 2e       	mov	r15, r26
     bca:	f0 94       	com	r15
     bcc:	01 2f       	mov	r16, r17
     bce:	0c 0f       	add	r16, r28
     bd0:	60 2f       	mov	r22, r16
     bd2:	8d 2f       	mov	r24, r29
     bd4:	98 df       	rcall	.-208    	; 0xb06 <gfx_mono_st7565r_get_byte>
     bd6:	4f 2d       	mov	r20, r15
     bd8:	48 23       	and	r20, r24
     bda:	60 2f       	mov	r22, r16
     bdc:	8d 2f       	mov	r24, r29
     bde:	74 de       	rcall	.-792    	; 0x8c8 <gfx_mono_st7565r_put_byte>
     be0:	c1 50       	subi	r28, 0x01	; 1
     be2:	a1 f7       	brne	.-24     	; 0xbcc <gfx_mono_generic_draw_horizontal_line+0x80>
     be4:	0f c0       	rjmp	.+30     	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     be6:	c4 2f       	mov	r28, r20
     be8:	1f ef       	ldi	r17, 0xFF	; 255
     bea:	18 0f       	add	r17, r24
     bec:	01 2f       	mov	r16, r17
     bee:	0c 0f       	add	r16, r28
     bf0:	60 2f       	mov	r22, r16
     bf2:	8d 2f       	mov	r24, r29
     bf4:	88 df       	rcall	.-240    	; 0xb06 <gfx_mono_st7565r_get_byte>
     bf6:	4f 2d       	mov	r20, r15
     bf8:	48 27       	eor	r20, r24
     bfa:	60 2f       	mov	r22, r16
     bfc:	8d 2f       	mov	r24, r29
     bfe:	64 de       	rcall	.-824    	; 0x8c8 <gfx_mono_st7565r_put_byte>
     c00:	c1 50       	subi	r28, 0x01	; 1
     c02:	a1 f7       	brne	.-24     	; 0xbec <gfx_mono_generic_draw_horizontal_line+0xa0>
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	08 95       	ret

00000c10 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     c10:	ff 92       	push	r15
     c12:	0f 93       	push	r16
     c14:	1f 93       	push	r17
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
	if (height == 0) {
     c1a:	22 23       	and	r18, r18
     c1c:	69 f0       	breq	.+26     	; 0xc38 <gfx_mono_generic_draw_filled_rect+0x28>
     c1e:	f4 2e       	mov	r15, r20
     c20:	18 2f       	mov	r17, r24
     c22:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c24:	df ef       	ldi	r29, 0xFF	; 255
     c26:	d6 0f       	add	r29, r22
     c28:	6d 2f       	mov	r22, r29
     c2a:	6c 0f       	add	r22, r28
     c2c:	20 2f       	mov	r18, r16
     c2e:	4f 2d       	mov	r20, r15
     c30:	81 2f       	mov	r24, r17
     c32:	8c df       	rcall	.-232    	; 0xb4c <gfx_mono_generic_draw_horizontal_line>
     c34:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c36:	c1 f7       	brne	.-16     	; 0xc28 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	ff 90       	pop	r15
     c42:	08 95       	ret

00000c44 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c44:	af 92       	push	r10
     c46:	bf 92       	push	r11
     c48:	cf 92       	push	r12
     c4a:	df 92       	push	r13
     c4c:	ef 92       	push	r14
     c4e:	ff 92       	push	r15
     c50:	0f 93       	push	r16
     c52:	1f 93       	push	r17
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	c8 2f       	mov	r28, r24
     c5a:	e6 2e       	mov	r14, r22
     c5c:	b4 2e       	mov	r11, r20
     c5e:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c60:	00 e0       	ldi	r16, 0x00	; 0
     c62:	f9 01       	movw	r30, r18
     c64:	24 81       	ldd	r18, Z+4	; 0x04
     c66:	43 81       	ldd	r20, Z+3	; 0x03
     c68:	6b 2d       	mov	r22, r11
     c6a:	8e 2d       	mov	r24, r14
     c6c:	d1 df       	rcall	.-94     	; 0xc10 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c6e:	f6 01       	movw	r30, r12
     c70:	80 81       	ld	r24, Z
     c72:	81 11       	cpse	r24, r1
     c74:	39 c0       	rjmp	.+114    	; 0xce8 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c76:	83 81       	ldd	r24, Z+3	; 0x03
     c78:	28 2f       	mov	r18, r24
     c7a:	26 95       	lsr	r18
     c7c:	26 95       	lsr	r18
     c7e:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c80:	87 70       	andi	r24, 0x07	; 7
     c82:	09 f0       	breq	.+2      	; 0xc86 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c84:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c86:	f6 01       	movw	r30, r12
     c88:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c8a:	8c 2f       	mov	r24, r28
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	35 81       	ldd	r19, Z+5	; 0x05
     c90:	83 1b       	sub	r24, r19
     c92:	91 09       	sbc	r25, r1
     c94:	2a 9d       	mul	r18, r10
     c96:	90 01       	movw	r18, r0
     c98:	11 24       	eor	r1, r1
     c9a:	82 9f       	mul	r24, r18
     c9c:	a0 01       	movw	r20, r0
     c9e:	83 9f       	mul	r24, r19
     ca0:	50 0d       	add	r21, r0
     ca2:	92 9f       	mul	r25, r18
     ca4:	50 0d       	add	r21, r0
     ca6:	11 24       	eor	r1, r1
     ca8:	01 81       	ldd	r16, Z+1	; 0x01
     caa:	12 81       	ldd	r17, Z+2	; 0x02
     cac:	04 0f       	add	r16, r20
     cae:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     cb0:	f6 01       	movw	r30, r12
     cb2:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     cb4:	ff 20       	and	r15, r15
     cb6:	a1 f0       	breq	.+40     	; 0xce0 <gfx_mono_draw_char+0x9c>
     cb8:	d0 e0       	ldi	r29, 0x00	; 0
     cba:	c0 e0       	ldi	r28, 0x00	; 0
     cbc:	8e 2d       	mov	r24, r14
     cbe:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     cc0:	9c 2f       	mov	r25, r28
     cc2:	97 70       	andi	r25, 0x07	; 7
     cc4:	21 f4       	brne	.+8      	; 0xcce <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     cc6:	f8 01       	movw	r30, r16
     cc8:	d4 91       	lpm	r29, Z
				glyph_data++;
     cca:	0f 5f       	subi	r16, 0xFF	; 255
     ccc:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     cce:	dd 23       	and	r29, r29
     cd0:	1c f4       	brge	.+6      	; 0xcd8 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cd2:	41 e0       	ldi	r20, 0x01	; 1
     cd4:	6b 2d       	mov	r22, r11
     cd6:	e1 de       	rcall	.-574    	; 0xa9a <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cd8:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cda:	cf 5f       	subi	r28, 0xFF	; 255
     cdc:	fc 12       	cpse	r15, r28
     cde:	ee cf       	rjmp	.-36     	; 0xcbc <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     ce0:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     ce2:	aa 94       	dec	r10
	} while (rows_left > 0);
     ce4:	a1 10       	cpse	r10, r1
     ce6:	e4 cf       	rjmp	.-56     	; 0xcb0 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	1f 91       	pop	r17
     cee:	0f 91       	pop	r16
     cf0:	ff 90       	pop	r15
     cf2:	ef 90       	pop	r14
     cf4:	df 90       	pop	r13
     cf6:	cf 90       	pop	r12
     cf8:	bf 90       	pop	r11
     cfa:	af 90       	pop	r10
     cfc:	08 95       	ret

00000cfe <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cfe:	df 92       	push	r13
     d00:	ef 92       	push	r14
     d02:	ff 92       	push	r15
     d04:	0f 93       	push	r16
     d06:	1f 93       	push	r17
     d08:	cf 93       	push	r28
     d0a:	df 93       	push	r29
     d0c:	d6 2e       	mov	r13, r22
     d0e:	04 2f       	mov	r16, r20
     d10:	79 01       	movw	r14, r18
     d12:	ec 01       	movw	r28, r24
     d14:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     d16:	89 91       	ld	r24, Y+
     d18:	8a 30       	cpi	r24, 0x0A	; 10
     d1a:	31 f4       	brne	.+12     	; 0xd28 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d1c:	f7 01       	movw	r30, r14
     d1e:	84 81       	ldd	r24, Z+4	; 0x04
     d20:	8f 5f       	subi	r24, 0xFF	; 255
     d22:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d24:	1d 2d       	mov	r17, r13
     d26:	09 c0       	rjmp	.+18     	; 0xd3a <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d28:	8d 30       	cpi	r24, 0x0D	; 13
     d2a:	39 f0       	breq	.+14     	; 0xd3a <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d2c:	97 01       	movw	r18, r14
     d2e:	40 2f       	mov	r20, r16
     d30:	61 2f       	mov	r22, r17
     d32:	88 df       	rcall	.-240    	; 0xc44 <gfx_mono_draw_char>
			x += font->width;
     d34:	f7 01       	movw	r30, r14
     d36:	83 81       	ldd	r24, Z+3	; 0x03
     d38:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d3a:	88 81       	ld	r24, Y
     d3c:	81 11       	cpse	r24, r1
     d3e:	eb cf       	rjmp	.-42     	; 0xd16 <gfx_mono_draw_string+0x18>
}
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	1f 91       	pop	r17
     d46:	0f 91       	pop	r16
     d48:	ff 90       	pop	r15
     d4a:	ef 90       	pop	r14
     d4c:	df 90       	pop	r13
     d4e:	08 95       	ret

00000d50 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d50:	80 3a       	cpi	r24, 0xA0	; 160
     d52:	28 e0       	ldi	r18, 0x08	; 8
     d54:	92 07       	cpc	r25, r18
     d56:	21 f4       	brne	.+8      	; 0xd60 <usart_spi_init+0x10>
     d58:	60 e1       	ldi	r22, 0x10	; 16
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	9e cd       	rjmp	.-1220   	; 0x89a <sysclk_enable_module>
     d5e:	08 95       	ret
     d60:	80 3b       	cpi	r24, 0xB0	; 176
     d62:	28 e0       	ldi	r18, 0x08	; 8
     d64:	92 07       	cpc	r25, r18
     d66:	21 f4       	brne	.+8      	; 0xd70 <usart_spi_init+0x20>
     d68:	60 e2       	ldi	r22, 0x20	; 32
     d6a:	83 e0       	ldi	r24, 0x03	; 3
     d6c:	96 cd       	rjmp	.-1236   	; 0x89a <sysclk_enable_module>
     d6e:	08 95       	ret
     d70:	80 3a       	cpi	r24, 0xA0	; 160
     d72:	29 e0       	ldi	r18, 0x09	; 9
     d74:	92 07       	cpc	r25, r18
     d76:	21 f4       	brne	.+8      	; 0xd80 <usart_spi_init+0x30>
     d78:	60 e1       	ldi	r22, 0x10	; 16
     d7a:	84 e0       	ldi	r24, 0x04	; 4
     d7c:	8e cd       	rjmp	.-1252   	; 0x89a <sysclk_enable_module>
     d7e:	08 95       	ret
     d80:	80 3b       	cpi	r24, 0xB0	; 176
     d82:	29 e0       	ldi	r18, 0x09	; 9
     d84:	92 07       	cpc	r25, r18
     d86:	21 f4       	brne	.+8      	; 0xd90 <usart_spi_init+0x40>
     d88:	60 e2       	ldi	r22, 0x20	; 32
     d8a:	84 e0       	ldi	r24, 0x04	; 4
     d8c:	86 cd       	rjmp	.-1268   	; 0x89a <sysclk_enable_module>
     d8e:	08 95       	ret
     d90:	80 3a       	cpi	r24, 0xA0	; 160
     d92:	2a e0       	ldi	r18, 0x0A	; 10
     d94:	92 07       	cpc	r25, r18
     d96:	21 f4       	brne	.+8      	; 0xda0 <usart_spi_init+0x50>
     d98:	60 e1       	ldi	r22, 0x10	; 16
     d9a:	85 e0       	ldi	r24, 0x05	; 5
     d9c:	7e cd       	rjmp	.-1284   	; 0x89a <sysclk_enable_module>
     d9e:	08 95       	ret
     da0:	80 3a       	cpi	r24, 0xA0	; 160
     da2:	9b 40       	sbci	r25, 0x0B	; 11
     da4:	19 f4       	brne	.+6      	; 0xdac <usart_spi_init+0x5c>
     da6:	60 e1       	ldi	r22, 0x10	; 16
     da8:	86 e0       	ldi	r24, 0x06	; 6
     daa:	77 cd       	rjmp	.-1298   	; 0x89a <sysclk_enable_module>
     dac:	08 95       	ret

00000dae <usart_spi_setup_device>:
     dae:	0f 93       	push	r16
     db0:	1f 93       	push	r17
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	00 d0       	rcall	.+0      	; 0xdb8 <usart_spi_setup_device+0xa>
     db8:	00 d0       	rcall	.+0      	; 0xdba <usart_spi_setup_device+0xc>
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	09 83       	std	Y+1, r16	; 0x01
     dc0:	1a 83       	std	Y+2, r17	; 0x02
     dc2:	2b 83       	std	Y+3, r18	; 0x03
     dc4:	3c 83       	std	Y+4, r19	; 0x04
     dc6:	4d 83       	std	Y+5, r20	; 0x05
     dc8:	1e 82       	std	Y+6, r1	; 0x06
     dca:	be 01       	movw	r22, r28
     dcc:	6f 5f       	subi	r22, 0xFF	; 255
     dce:	7f 4f       	sbci	r23, 0xFF	; 255
     dd0:	a2 d5       	rcall	.+2884   	; 0x1916 <usart_init_spi>
     dd2:	26 96       	adiw	r28, 0x06	; 6
     dd4:	cd bf       	out	0x3d, r28	; 61
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	08 95       	ret

00000de2 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     de2:	fb 01       	movw	r30, r22
     de4:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     de6:	e8 2f       	mov	r30, r24
     de8:	e6 95       	lsr	r30
     dea:	e6 95       	lsr	r30
     dec:	e6 95       	lsr	r30
     dee:	40 e2       	ldi	r20, 0x20	; 32
     df0:	e4 9f       	mul	r30, r20
     df2:	f0 01       	movw	r30, r0
     df4:	11 24       	eor	r1, r1
     df6:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     df8:	87 70       	andi	r24, 0x07	; 7
     dfa:	21 e0       	ldi	r18, 0x01	; 1
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	a9 01       	movw	r20, r18
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <usart_spi_select_device+0x24>
     e02:	44 0f       	add	r20, r20
     e04:	55 1f       	adc	r21, r21
     e06:	8a 95       	dec	r24
     e08:	e2 f7       	brpl	.-8      	; 0xe02 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     e0a:	46 83       	std	Z+6, r20	; 0x06
     e0c:	08 95       	ret

00000e0e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     e0e:	fb 01       	movw	r30, r22
     e10:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e12:	e8 2f       	mov	r30, r24
     e14:	e6 95       	lsr	r30
     e16:	e6 95       	lsr	r30
     e18:	e6 95       	lsr	r30
     e1a:	40 e2       	ldi	r20, 0x20	; 32
     e1c:	e4 9f       	mul	r30, r20
     e1e:	f0 01       	movw	r30, r0
     e20:	11 24       	eor	r1, r1
     e22:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e24:	87 70       	andi	r24, 0x07	; 7
     e26:	21 e0       	ldi	r18, 0x01	; 1
     e28:	30 e0       	ldi	r19, 0x00	; 0
     e2a:	a9 01       	movw	r20, r18
     e2c:	02 c0       	rjmp	.+4      	; 0xe32 <usart_spi_deselect_device+0x24>
     e2e:	44 0f       	add	r20, r20
     e30:	55 1f       	adc	r21, r21
     e32:	8a 95       	dec	r24
     e34:	e2 f7       	brpl	.-8      	; 0xe2e <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e36:	45 83       	std	Z+5, r20	; 0x05
     e38:	08 95       	ret

00000e3a <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e3a:	81 15       	cp	r24, r1
     e3c:	22 e0       	ldi	r18, 0x02	; 2
     e3e:	92 07       	cpc	r25, r18
     e40:	61 f4       	brne	.+24     	; 0xe5a <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e42:	80 91 41 22 	lds	r24, 0x2241	; 0x802241 <adca_enable_count>
     e46:	91 e0       	ldi	r25, 0x01	; 1
     e48:	98 0f       	add	r25, r24
     e4a:	90 93 41 22 	sts	0x2241, r25	; 0x802241 <adca_enable_count>
     e4e:	81 11       	cpse	r24, r1
     e50:	12 c0       	rjmp	.+36     	; 0xe76 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e52:	62 e0       	ldi	r22, 0x02	; 2
     e54:	81 e0       	ldi	r24, 0x01	; 1
     e56:	21 cd       	rjmp	.-1470   	; 0x89a <sysclk_enable_module>
     e58:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e5a:	80 34       	cpi	r24, 0x40	; 64
     e5c:	92 40       	sbci	r25, 0x02	; 2
     e5e:	59 f4       	brne	.+22     	; 0xe76 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e60:	80 91 40 22 	lds	r24, 0x2240	; 0x802240 <adcb_enable_count>
     e64:	91 e0       	ldi	r25, 0x01	; 1
     e66:	98 0f       	add	r25, r24
     e68:	90 93 40 22 	sts	0x2240, r25	; 0x802240 <adcb_enable_count>
     e6c:	81 11       	cpse	r24, r1
     e6e:	03 c0       	rjmp	.+6      	; 0xe76 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e70:	62 e0       	ldi	r22, 0x02	; 2
     e72:	82 e0       	ldi	r24, 0x02	; 2
     e74:	12 cd       	rjmp	.-1500   	; 0x89a <sysclk_enable_module>
     e76:	08 95       	ret

00000e78 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e78:	81 15       	cp	r24, r1
     e7a:	22 e0       	ldi	r18, 0x02	; 2
     e7c:	92 07       	cpc	r25, r18
     e7e:	59 f4       	brne	.+22     	; 0xe96 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e80:	80 91 41 22 	lds	r24, 0x2241	; 0x802241 <adca_enable_count>
     e84:	81 50       	subi	r24, 0x01	; 1
     e86:	80 93 41 22 	sts	0x2241, r24	; 0x802241 <adca_enable_count>
     e8a:	81 11       	cpse	r24, r1
     e8c:	11 c0       	rjmp	.+34     	; 0xeb0 <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e8e:	62 e0       	ldi	r22, 0x02	; 2
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	0f cd       	rjmp	.-1506   	; 0x8b2 <sysclk_disable_module>
     e94:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e96:	80 34       	cpi	r24, 0x40	; 64
     e98:	92 40       	sbci	r25, 0x02	; 2
     e9a:	51 f4       	brne	.+20     	; 0xeb0 <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     e9c:	80 91 40 22 	lds	r24, 0x2240	; 0x802240 <adcb_enable_count>
     ea0:	81 50       	subi	r24, 0x01	; 1
     ea2:	80 93 40 22 	sts	0x2240, r24	; 0x802240 <adcb_enable_count>
     ea6:	81 11       	cpse	r24, r1
     ea8:	03 c0       	rjmp	.+6      	; 0xeb0 <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     eaa:	62 e0       	ldi	r22, 0x02	; 2
     eac:	82 e0       	ldi	r24, 0x02	; 2
     eae:	01 cd       	rjmp	.-1534   	; 0x8b2 <sysclk_disable_module>
     eb0:	08 95       	ret

00000eb2 <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     eb2:	1f 93       	push	r17
     eb4:	cf 93       	push	r28
     eb6:	df 93       	push	r29
     eb8:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     eba:	1f b7       	in	r17, 0x3f	; 63
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     ebc:	f8 94       	cli
	adc->CTRLA |= ADC_ENABLE_bm;
     ebe:	bd df       	rcall	.-134    	; 0xe3a <adc_enable_clock>
     ec0:	88 81       	ld	r24, Y
     ec2:	81 60       	ori	r24, 0x01	; 1
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ec4:	88 83       	st	Y, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ec6:	1f bf       	out	0x3f, r17	; 63
	cpu_irq_disable();
     ec8:	9f b7       	in	r25, 0x3f	; 63
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     eca:	f8 94       	cli
     ecc:	eb e8       	ldi	r30, 0x8B	; 139
     ece:	f3 e2       	ldi	r31, 0x23	; 35
     ed0:	81 81       	ldd	r24, Z+1	; 0x01
     ed2:	8f 5f       	subi	r24, 0xFF	; 255
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ed4:	81 83       	std	Z+1, r24	; 0x01
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     ed6:	9f bf       	out	0x3f, r25	; 63
     ed8:	df 91       	pop	r29
     eda:	cf 91       	pop	r28
     edc:	1f 91       	pop	r17
     ede:	08 95       	ret

00000ee0 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     ee0:	1f 92       	push	r1
     ee2:	0f 92       	push	r0
     ee4:	0f b6       	in	r0, 0x3f	; 63
     ee6:	0f 92       	push	r0
     ee8:	11 24       	eor	r1, r1
     eea:	0b b6       	in	r0, 0x3b	; 59
     eec:	0f 92       	push	r0
     eee:	2f 93       	push	r18
     ef0:	3f 93       	push	r19
     ef2:	4f 93       	push	r20
     ef4:	5f 93       	push	r21
     ef6:	6f 93       	push	r22
     ef8:	7f 93       	push	r23
     efa:	8f 93       	push	r24
     efc:	9f 93       	push	r25
     efe:	af 93       	push	r26
     f00:	bf 93       	push	r27
     f02:	ef 93       	push	r30
     f04:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     f06:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     f0a:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     f0e:	e0 91 93 23 	lds	r30, 0x2393	; 0x802393 <adca_callback>
     f12:	f0 91 94 23 	lds	r31, 0x2394	; 0x802394 <adca_callback+0x1>
     f16:	61 e0       	ldi	r22, 0x01	; 1
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	92 e0       	ldi	r25, 0x02	; 2
     f1c:	19 95       	eicall
}
     f1e:	ff 91       	pop	r31
     f20:	ef 91       	pop	r30
     f22:	bf 91       	pop	r27
     f24:	af 91       	pop	r26
     f26:	9f 91       	pop	r25
     f28:	8f 91       	pop	r24
     f2a:	7f 91       	pop	r23
     f2c:	6f 91       	pop	r22
     f2e:	5f 91       	pop	r21
     f30:	4f 91       	pop	r20
     f32:	3f 91       	pop	r19
     f34:	2f 91       	pop	r18
     f36:	0f 90       	pop	r0
     f38:	0b be       	out	0x3b, r0	; 59
     f3a:	0f 90       	pop	r0
     f3c:	0f be       	out	0x3f, r0	; 63
     f3e:	0f 90       	pop	r0
     f40:	1f 90       	pop	r1
     f42:	18 95       	reti

00000f44 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f44:	1f 92       	push	r1
     f46:	0f 92       	push	r0
     f48:	0f b6       	in	r0, 0x3f	; 63
     f4a:	0f 92       	push	r0
     f4c:	11 24       	eor	r1, r1
     f4e:	0b b6       	in	r0, 0x3b	; 59
     f50:	0f 92       	push	r0
     f52:	2f 93       	push	r18
     f54:	3f 93       	push	r19
     f56:	4f 93       	push	r20
     f58:	5f 93       	push	r21
     f5a:	6f 93       	push	r22
     f5c:	7f 93       	push	r23
     f5e:	8f 93       	push	r24
     f60:	9f 93       	push	r25
     f62:	af 93       	push	r26
     f64:	bf 93       	push	r27
     f66:	ef 93       	push	r30
     f68:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f6a:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     f6e:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     f72:	e0 91 93 23 	lds	r30, 0x2393	; 0x802393 <adca_callback>
     f76:	f0 91 94 23 	lds	r31, 0x2394	; 0x802394 <adca_callback+0x1>
     f7a:	62 e0       	ldi	r22, 0x02	; 2
     f7c:	80 e0       	ldi	r24, 0x00	; 0
     f7e:	92 e0       	ldi	r25, 0x02	; 2
     f80:	19 95       	eicall
}
     f82:	ff 91       	pop	r31
     f84:	ef 91       	pop	r30
     f86:	bf 91       	pop	r27
     f88:	af 91       	pop	r26
     f8a:	9f 91       	pop	r25
     f8c:	8f 91       	pop	r24
     f8e:	7f 91       	pop	r23
     f90:	6f 91       	pop	r22
     f92:	5f 91       	pop	r21
     f94:	4f 91       	pop	r20
     f96:	3f 91       	pop	r19
     f98:	2f 91       	pop	r18
     f9a:	0f 90       	pop	r0
     f9c:	0b be       	out	0x3b, r0	; 59
     f9e:	0f 90       	pop	r0
     fa0:	0f be       	out	0x3f, r0	; 63
     fa2:	0f 90       	pop	r0
     fa4:	1f 90       	pop	r1
     fa6:	18 95       	reti

00000fa8 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     fa8:	1f 92       	push	r1
     faa:	0f 92       	push	r0
     fac:	0f b6       	in	r0, 0x3f	; 63
     fae:	0f 92       	push	r0
     fb0:	11 24       	eor	r1, r1
     fb2:	0b b6       	in	r0, 0x3b	; 59
     fb4:	0f 92       	push	r0
     fb6:	2f 93       	push	r18
     fb8:	3f 93       	push	r19
     fba:	4f 93       	push	r20
     fbc:	5f 93       	push	r21
     fbe:	6f 93       	push	r22
     fc0:	7f 93       	push	r23
     fc2:	8f 93       	push	r24
     fc4:	9f 93       	push	r25
     fc6:	af 93       	push	r26
     fc8:	bf 93       	push	r27
     fca:	ef 93       	push	r30
     fcc:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fce:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     fd2:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     fd6:	e0 91 93 23 	lds	r30, 0x2393	; 0x802393 <adca_callback>
     fda:	f0 91 94 23 	lds	r31, 0x2394	; 0x802394 <adca_callback+0x1>
     fde:	64 e0       	ldi	r22, 0x04	; 4
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	92 e0       	ldi	r25, 0x02	; 2
     fe4:	19 95       	eicall
}
     fe6:	ff 91       	pop	r31
     fe8:	ef 91       	pop	r30
     fea:	bf 91       	pop	r27
     fec:	af 91       	pop	r26
     fee:	9f 91       	pop	r25
     ff0:	8f 91       	pop	r24
     ff2:	7f 91       	pop	r23
     ff4:	6f 91       	pop	r22
     ff6:	5f 91       	pop	r21
     ff8:	4f 91       	pop	r20
     ffa:	3f 91       	pop	r19
     ffc:	2f 91       	pop	r18
     ffe:	0f 90       	pop	r0
    1000:	0b be       	out	0x3b, r0	; 59
    1002:	0f 90       	pop	r0
    1004:	0f be       	out	0x3f, r0	; 63
    1006:	0f 90       	pop	r0
    1008:	1f 90       	pop	r1
    100a:	18 95       	reti

0000100c <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
    100c:	1f 92       	push	r1
    100e:	0f 92       	push	r0
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	0f 92       	push	r0
    1014:	11 24       	eor	r1, r1
    1016:	0b b6       	in	r0, 0x3b	; 59
    1018:	0f 92       	push	r0
    101a:	2f 93       	push	r18
    101c:	3f 93       	push	r19
    101e:	4f 93       	push	r20
    1020:	5f 93       	push	r21
    1022:	6f 93       	push	r22
    1024:	7f 93       	push	r23
    1026:	8f 93       	push	r24
    1028:	9f 93       	push	r25
    102a:	af 93       	push	r26
    102c:	bf 93       	push	r27
    102e:	ef 93       	push	r30
    1030:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    1032:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1036:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    103a:	e0 91 93 23 	lds	r30, 0x2393	; 0x802393 <adca_callback>
    103e:	f0 91 94 23 	lds	r31, 0x2394	; 0x802394 <adca_callback+0x1>
    1042:	68 e0       	ldi	r22, 0x08	; 8
    1044:	80 e0       	ldi	r24, 0x00	; 0
    1046:	92 e0       	ldi	r25, 0x02	; 2
    1048:	19 95       	eicall
}
    104a:	ff 91       	pop	r31
    104c:	ef 91       	pop	r30
    104e:	bf 91       	pop	r27
    1050:	af 91       	pop	r26
    1052:	9f 91       	pop	r25
    1054:	8f 91       	pop	r24
    1056:	7f 91       	pop	r23
    1058:	6f 91       	pop	r22
    105a:	5f 91       	pop	r21
    105c:	4f 91       	pop	r20
    105e:	3f 91       	pop	r19
    1060:	2f 91       	pop	r18
    1062:	0f 90       	pop	r0
    1064:	0b be       	out	0x3b, r0	; 59
    1066:	0f 90       	pop	r0
    1068:	0f be       	out	0x3f, r0	; 63
    106a:	0f 90       	pop	r0
    106c:	1f 90       	pop	r1
    106e:	18 95       	reti

00001070 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1070:	1f 92       	push	r1
    1072:	0f 92       	push	r0
    1074:	0f b6       	in	r0, 0x3f	; 63
    1076:	0f 92       	push	r0
    1078:	11 24       	eor	r1, r1
    107a:	0b b6       	in	r0, 0x3b	; 59
    107c:	0f 92       	push	r0
    107e:	2f 93       	push	r18
    1080:	3f 93       	push	r19
    1082:	4f 93       	push	r20
    1084:	5f 93       	push	r21
    1086:	6f 93       	push	r22
    1088:	7f 93       	push	r23
    108a:	8f 93       	push	r24
    108c:	9f 93       	push	r25
    108e:	af 93       	push	r26
    1090:	bf 93       	push	r27
    1092:	ef 93       	push	r30
    1094:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1096:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    109a:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    109e:	e0 91 91 23 	lds	r30, 0x2391	; 0x802391 <adcb_callback>
    10a2:	f0 91 92 23 	lds	r31, 0x2392	; 0x802392 <adcb_callback+0x1>
    10a6:	61 e0       	ldi	r22, 0x01	; 1
    10a8:	80 e4       	ldi	r24, 0x40	; 64
    10aa:	92 e0       	ldi	r25, 0x02	; 2
    10ac:	19 95       	eicall
}
    10ae:	ff 91       	pop	r31
    10b0:	ef 91       	pop	r30
    10b2:	bf 91       	pop	r27
    10b4:	af 91       	pop	r26
    10b6:	9f 91       	pop	r25
    10b8:	8f 91       	pop	r24
    10ba:	7f 91       	pop	r23
    10bc:	6f 91       	pop	r22
    10be:	5f 91       	pop	r21
    10c0:	4f 91       	pop	r20
    10c2:	3f 91       	pop	r19
    10c4:	2f 91       	pop	r18
    10c6:	0f 90       	pop	r0
    10c8:	0b be       	out	0x3b, r0	; 59
    10ca:	0f 90       	pop	r0
    10cc:	0f be       	out	0x3f, r0	; 63
    10ce:	0f 90       	pop	r0
    10d0:	1f 90       	pop	r1
    10d2:	18 95       	reti

000010d4 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10d4:	1f 92       	push	r1
    10d6:	0f 92       	push	r0
    10d8:	0f b6       	in	r0, 0x3f	; 63
    10da:	0f 92       	push	r0
    10dc:	11 24       	eor	r1, r1
    10de:	0b b6       	in	r0, 0x3b	; 59
    10e0:	0f 92       	push	r0
    10e2:	2f 93       	push	r18
    10e4:	3f 93       	push	r19
    10e6:	4f 93       	push	r20
    10e8:	5f 93       	push	r21
    10ea:	6f 93       	push	r22
    10ec:	7f 93       	push	r23
    10ee:	8f 93       	push	r24
    10f0:	9f 93       	push	r25
    10f2:	af 93       	push	r26
    10f4:	bf 93       	push	r27
    10f6:	ef 93       	push	r30
    10f8:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    10fa:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    10fe:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    1102:	e0 91 91 23 	lds	r30, 0x2391	; 0x802391 <adcb_callback>
    1106:	f0 91 92 23 	lds	r31, 0x2392	; 0x802392 <adcb_callback+0x1>
    110a:	62 e0       	ldi	r22, 0x02	; 2
    110c:	80 e4       	ldi	r24, 0x40	; 64
    110e:	92 e0       	ldi	r25, 0x02	; 2
    1110:	19 95       	eicall
}
    1112:	ff 91       	pop	r31
    1114:	ef 91       	pop	r30
    1116:	bf 91       	pop	r27
    1118:	af 91       	pop	r26
    111a:	9f 91       	pop	r25
    111c:	8f 91       	pop	r24
    111e:	7f 91       	pop	r23
    1120:	6f 91       	pop	r22
    1122:	5f 91       	pop	r21
    1124:	4f 91       	pop	r20
    1126:	3f 91       	pop	r19
    1128:	2f 91       	pop	r18
    112a:	0f 90       	pop	r0
    112c:	0b be       	out	0x3b, r0	; 59
    112e:	0f 90       	pop	r0
    1130:	0f be       	out	0x3f, r0	; 63
    1132:	0f 90       	pop	r0
    1134:	1f 90       	pop	r1
    1136:	18 95       	reti

00001138 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1138:	1f 92       	push	r1
    113a:	0f 92       	push	r0
    113c:	0f b6       	in	r0, 0x3f	; 63
    113e:	0f 92       	push	r0
    1140:	11 24       	eor	r1, r1
    1142:	0b b6       	in	r0, 0x3b	; 59
    1144:	0f 92       	push	r0
    1146:	2f 93       	push	r18
    1148:	3f 93       	push	r19
    114a:	4f 93       	push	r20
    114c:	5f 93       	push	r21
    114e:	6f 93       	push	r22
    1150:	7f 93       	push	r23
    1152:	8f 93       	push	r24
    1154:	9f 93       	push	r25
    1156:	af 93       	push	r26
    1158:	bf 93       	push	r27
    115a:	ef 93       	push	r30
    115c:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    115e:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    1162:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1166:	e0 91 91 23 	lds	r30, 0x2391	; 0x802391 <adcb_callback>
    116a:	f0 91 92 23 	lds	r31, 0x2392	; 0x802392 <adcb_callback+0x1>
    116e:	64 e0       	ldi	r22, 0x04	; 4
    1170:	80 e4       	ldi	r24, 0x40	; 64
    1172:	92 e0       	ldi	r25, 0x02	; 2
    1174:	19 95       	eicall
}
    1176:	ff 91       	pop	r31
    1178:	ef 91       	pop	r30
    117a:	bf 91       	pop	r27
    117c:	af 91       	pop	r26
    117e:	9f 91       	pop	r25
    1180:	8f 91       	pop	r24
    1182:	7f 91       	pop	r23
    1184:	6f 91       	pop	r22
    1186:	5f 91       	pop	r21
    1188:	4f 91       	pop	r20
    118a:	3f 91       	pop	r19
    118c:	2f 91       	pop	r18
    118e:	0f 90       	pop	r0
    1190:	0b be       	out	0x3b, r0	; 59
    1192:	0f 90       	pop	r0
    1194:	0f be       	out	0x3f, r0	; 63
    1196:	0f 90       	pop	r0
    1198:	1f 90       	pop	r1
    119a:	18 95       	reti

0000119c <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    119c:	1f 92       	push	r1
    119e:	0f 92       	push	r0
    11a0:	0f b6       	in	r0, 0x3f	; 63
    11a2:	0f 92       	push	r0
    11a4:	11 24       	eor	r1, r1
    11a6:	0b b6       	in	r0, 0x3b	; 59
    11a8:	0f 92       	push	r0
    11aa:	2f 93       	push	r18
    11ac:	3f 93       	push	r19
    11ae:	4f 93       	push	r20
    11b0:	5f 93       	push	r21
    11b2:	6f 93       	push	r22
    11b4:	7f 93       	push	r23
    11b6:	8f 93       	push	r24
    11b8:	9f 93       	push	r25
    11ba:	af 93       	push	r26
    11bc:	bf 93       	push	r27
    11be:	ef 93       	push	r30
    11c0:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    11c2:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    11c6:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    11ca:	e0 91 91 23 	lds	r30, 0x2391	; 0x802391 <adcb_callback>
    11ce:	f0 91 92 23 	lds	r31, 0x2392	; 0x802392 <adcb_callback+0x1>
    11d2:	68 e0       	ldi	r22, 0x08	; 8
    11d4:	80 e4       	ldi	r24, 0x40	; 64
    11d6:	92 e0       	ldi	r25, 0x02	; 2
    11d8:	19 95       	eicall
}
    11da:	ff 91       	pop	r31
    11dc:	ef 91       	pop	r30
    11de:	bf 91       	pop	r27
    11e0:	af 91       	pop	r26
    11e2:	9f 91       	pop	r25
    11e4:	8f 91       	pop	r24
    11e6:	7f 91       	pop	r23
    11e8:	6f 91       	pop	r22
    11ea:	5f 91       	pop	r21
    11ec:	4f 91       	pop	r20
    11ee:	3f 91       	pop	r19
    11f0:	2f 91       	pop	r18
    11f2:	0f 90       	pop	r0
    11f4:	0b be       	out	0x3b, r0	; 59
    11f6:	0f 90       	pop	r0
    11f8:	0f be       	out	0x3f, r0	; 63
    11fa:	0f 90       	pop	r0
    11fc:	1f 90       	pop	r1
    11fe:	18 95       	reti

00001200 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    1200:	df 92       	push	r13
    1202:	ef 92       	push	r14
    1204:	ff 92       	push	r15
    1206:	0f 93       	push	r16
    1208:	1f 93       	push	r17
    120a:	cf 93       	push	r28
    120c:	df 93       	push	r29
    120e:	ec 01       	movw	r28, r24
    1210:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    1212:	81 15       	cp	r24, r1
    1214:	22 e0       	ldi	r18, 0x02	; 2
    1216:	92 07       	cpc	r25, r18
    1218:	71 f4       	brne	.+28     	; 0x1236 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    121a:	61 e2       	ldi	r22, 0x21	; 33
    121c:	70 e0       	ldi	r23, 0x00	; 0
    121e:	82 e0       	ldi	r24, 0x02	; 2
    1220:	d4 d0       	rcall	.+424    	; 0x13ca <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    1222:	e8 2e       	mov	r14, r24
    1224:	f1 2c       	mov	r15, r1
    1226:	60 e2       	ldi	r22, 0x20	; 32
    1228:	70 e0       	ldi	r23, 0x00	; 0
    122a:	82 e0       	ldi	r24, 0x02	; 2
    122c:	ce d0       	rcall	.+412    	; 0x13ca <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
    122e:	fe 2c       	mov	r15, r14
    1230:	ee 24       	eor	r14, r14
    1232:	e8 2a       	or	r14, r24
    1234:	10 c0       	rjmp	.+32     	; 0x1256 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1236:	80 34       	cpi	r24, 0x40	; 64
    1238:	92 40       	sbci	r25, 0x02	; 2
    123a:	51 f5       	brne	.+84     	; 0x1290 <adc_write_configuration+0x90>
    123c:	65 e2       	ldi	r22, 0x25	; 37
    123e:	70 e0       	ldi	r23, 0x00	; 0
    1240:	82 e0       	ldi	r24, 0x02	; 2
    1242:	c3 d0       	rcall	.+390    	; 0x13ca <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1244:	e8 2e       	mov	r14, r24
    1246:	f1 2c       	mov	r15, r1
    1248:	64 e2       	ldi	r22, 0x24	; 36
    124a:	70 e0       	ldi	r23, 0x00	; 0
    124c:	82 e0       	ldi	r24, 0x02	; 2
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
    124e:	bd d0       	rcall	.+378    	; 0x13ca <nvm_read_byte>
    1250:	fe 2c       	mov	r15, r14

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1252:	ee 24       	eor	r14, r14
	cpu_irq_disable();
    1254:	e8 2a       	or	r14, r24
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1256:	df b6       	in	r13, 0x3f	; 63
    1258:	f8 94       	cli
    125a:	ce 01       	movw	r24, r28
	enable = adc->CTRLA & ADC_ENABLE_bm;
    125c:	ee dd       	rcall	.-1060   	; 0xe3a <adc_enable_clock>

	adc->CTRLA = ADC_FLUSH_bm;
    125e:	88 81       	ld	r24, Y
    1260:	92 e0       	ldi	r25, 0x02	; 2
	adc->CAL = cal;
    1262:	98 83       	st	Y, r25
    1264:	ec 86       	std	Y+12, r14	; 0x0c
	adc->CMP = conf->cmp;
    1266:	fd 86       	std	Y+13, r15	; 0x0d
    1268:	f8 01       	movw	r30, r16
    126a:	25 81       	ldd	r18, Z+5	; 0x05
    126c:	36 81       	ldd	r19, Z+6	; 0x06
    126e:	28 8f       	std	Y+24, r18	; 0x18
	adc->REFCTRL = conf->refctrl;
    1270:	39 8f       	std	Y+25, r19	; 0x19
    1272:	92 81       	ldd	r25, Z+2	; 0x02
	adc->PRESCALER = conf->prescaler;
    1274:	9a 83       	std	Y+2, r25	; 0x02
    1276:	94 81       	ldd	r25, Z+4	; 0x04
	adc->EVCTRL = conf->evctrl;
    1278:	9c 83       	std	Y+4, r25	; 0x04
    127a:	93 81       	ldd	r25, Z+3	; 0x03
	adc->CTRLB = conf->ctrlb;
    127c:	9b 83       	std	Y+3, r25	; 0x03

	adc->CTRLA = enable | conf->ctrla;
    127e:	91 81       	ldd	r25, Z+1	; 0x01
    1280:	99 83       	std	Y+1, r25	; 0x01
    1282:	81 70       	andi	r24, 0x01	; 1

	adc_disable_clock(adc);
    1284:	90 81       	ld	r25, Z
    1286:	89 2b       	or	r24, r25
    1288:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    128a:	ce 01       	movw	r24, r28

	cpu_irq_restore(flags);
}
    128c:	f5 dd       	rcall	.-1046   	; 0xe78 <adc_disable_clock>
    128e:	df be       	out	0x3f, r13	; 63
    1290:	df 91       	pop	r29
    1292:	cf 91       	pop	r28
    1294:	1f 91       	pop	r17
    1296:	0f 91       	pop	r16
    1298:	ff 90       	pop	r15
    129a:	ef 90       	pop	r14
    129c:	df 90       	pop	r13
    129e:	08 95       	ret

000012a0 <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    12a0:	ff 92       	push	r15
    12a2:	0f 93       	push	r16
    12a4:	1f 93       	push	r17
    12a6:	cf 93       	push	r28
    12a8:	df 93       	push	r29
    12aa:	ec 01       	movw	r28, r24
    12ac:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12ae:	ff b6       	in	r15, 0x3f	; 63
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    12b0:	f8 94       	cli

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    12b2:	c3 dd       	rcall	.-1146   	; 0xe3a <adc_enable_clock>
    12b4:	88 81       	ld	r24, Y
    12b6:	80 7c       	andi	r24, 0xC0	; 192
    12b8:	f8 01       	movw	r30, r16

	conf->cmp = adc->CMP;
    12ba:	80 83       	st	Z, r24
    12bc:	88 8d       	ldd	r24, Y+24	; 0x18
    12be:	99 8d       	ldd	r25, Y+25	; 0x19
    12c0:	85 83       	std	Z+5, r24	; 0x05
	conf->refctrl = adc->REFCTRL;
    12c2:	96 83       	std	Z+6, r25	; 0x06
    12c4:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->prescaler = adc->PRESCALER;
    12c6:	82 83       	std	Z+2, r24	; 0x02
    12c8:	8c 81       	ldd	r24, Y+4	; 0x04
	conf->evctrl = adc->EVCTRL;
    12ca:	84 83       	std	Z+4, r24	; 0x04
    12cc:	8b 81       	ldd	r24, Y+3	; 0x03
	conf->ctrlb = adc->CTRLB;
    12ce:	83 83       	std	Z+3, r24	; 0x03

	adc_disable_clock(adc);
    12d0:	89 81       	ldd	r24, Y+1	; 0x01
    12d2:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12d4:	ce 01       	movw	r24, r28

	cpu_irq_restore(flags);
}
    12d6:	d0 dd       	rcall	.-1120   	; 0xe78 <adc_disable_clock>
    12d8:	ff be       	out	0x3f, r15	; 63
    12da:	df 91       	pop	r29
    12dc:	cf 91       	pop	r28
    12de:	1f 91       	pop	r17
    12e0:	0f 91       	pop	r16
    12e2:	ff 90       	pop	r15
    12e4:	08 95       	ret

000012e6 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12e6:	cf 92       	push	r12
    12e8:	df 92       	push	r13
    12ea:	ef 92       	push	r14
    12ec:	ff 92       	push	r15
    12ee:	0f 93       	push	r16
    12f0:	1f 93       	push	r17
    12f2:	cf 93       	push	r28
    12f4:	df 93       	push	r29
    12f6:	7c 01       	movw	r14, r24
    12f8:	d6 2e       	mov	r13, r22
    12fa:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12fc:	86 2f       	mov	r24, r22
    12fe:	83 70       	andi	r24, 0x03	; 3
    1300:	29 f4       	brne	.+10     	; 0x130c <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1302:	96 2f       	mov	r25, r22
    1304:	96 95       	lsr	r25
    1306:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1308:	82 e0       	ldi	r24, 0x02	; 2
    130a:	02 c0       	rjmp	.+4      	; 0x1310 <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    130c:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    130e:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1310:	90 ff       	sbrs	r25, 0
		index++;
    1312:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1314:	e7 01       	movw	r28, r14
    1316:	a0 96       	adiw	r28, 0x20	; 32
    1318:	98 e0       	ldi	r25, 0x08	; 8
    131a:	89 9f       	mul	r24, r25
    131c:	c0 0d       	add	r28, r0
    131e:	d1 1d       	adc	r29, r1
    1320:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1322:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1324:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1326:	c7 01       	movw	r24, r14
    1328:	88 dd       	rcall	.-1264   	; 0xe3a <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    132a:	f8 01       	movw	r30, r16
    132c:	80 81       	ld	r24, Z
    132e:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    1330:	82 81       	ldd	r24, Z+2	; 0x02
    1332:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1334:	81 81       	ldd	r24, Z+1	; 0x01
    1336:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1338:	d0 fe       	sbrs	r13, 0
    133a:	02 c0       	rjmp	.+4      	; 0x1340 <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    133c:	83 81       	ldd	r24, Z+3	; 0x03
	}
	adc_disable_clock(adc);
    133e:	8e 83       	std	Y+6, r24	; 0x06
    1340:	c7 01       	movw	r24, r14
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1342:	9a dd       	rcall	.-1228   	; 0xe78 <adc_disable_clock>

	cpu_irq_restore(flags);
}
    1344:	cf be       	out	0x3f, r12	; 63
    1346:	df 91       	pop	r29
    1348:	cf 91       	pop	r28
    134a:	1f 91       	pop	r17
    134c:	0f 91       	pop	r16
    134e:	ff 90       	pop	r15
    1350:	ef 90       	pop	r14
    1352:	df 90       	pop	r13
    1354:	cf 90       	pop	r12
    1356:	08 95       	ret

00001358 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1358:	cf 92       	push	r12
    135a:	df 92       	push	r13
    135c:	ef 92       	push	r14
    135e:	ff 92       	push	r15
    1360:	0f 93       	push	r16
    1362:	1f 93       	push	r17
    1364:	cf 93       	push	r28
    1366:	df 93       	push	r29
    1368:	7c 01       	movw	r14, r24
    136a:	d6 2e       	mov	r13, r22
    136c:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    136e:	86 2f       	mov	r24, r22
    1370:	83 70       	andi	r24, 0x03	; 3
    1372:	29 f4       	brne	.+10     	; 0x137e <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1374:	96 2f       	mov	r25, r22
    1376:	96 95       	lsr	r25
    1378:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    137a:	82 e0       	ldi	r24, 0x02	; 2
    137c:	02 c0       	rjmp	.+4      	; 0x1382 <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    137e:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1380:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1382:	90 ff       	sbrs	r25, 0
		index++;
    1384:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1386:	e7 01       	movw	r28, r14
    1388:	a0 96       	adiw	r28, 0x20	; 32
    138a:	98 e0       	ldi	r25, 0x08	; 8
    138c:	89 9f       	mul	r24, r25
    138e:	c0 0d       	add	r28, r0
    1390:	d1 1d       	adc	r29, r1
    1392:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1394:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1396:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1398:	c7 01       	movw	r24, r14
    139a:	4f dd       	rcall	.-1378   	; 0xe3a <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    139c:	88 81       	ld	r24, Y
    139e:	f8 01       	movw	r30, r16
    13a0:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    13a2:	8a 81       	ldd	r24, Y+2	; 0x02
    13a4:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    13a6:	89 81       	ldd	r24, Y+1	; 0x01
    13a8:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    13aa:	d0 fe       	sbrs	r13, 0
    13ac:	02 c0       	rjmp	.+4      	; 0x13b2 <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    13ae:	8e 81       	ldd	r24, Y+6	; 0x06
	}
	adc_disable_clock(adc);
    13b0:	83 83       	std	Z+3, r24	; 0x03
    13b2:	c7 01       	movw	r24, r14
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    13b4:	61 dd       	rcall	.-1342   	; 0xe78 <adc_disable_clock>

	cpu_irq_restore(flags);
}
    13b6:	cf be       	out	0x3f, r12	; 63
    13b8:	df 91       	pop	r29
    13ba:	cf 91       	pop	r28
    13bc:	1f 91       	pop	r17
    13be:	0f 91       	pop	r16
    13c0:	ff 90       	pop	r15
    13c2:	ef 90       	pop	r14
    13c4:	df 90       	pop	r13
    13c6:	cf 90       	pop	r12
    13c8:	08 95       	ret

000013ca <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    13ca:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    13ce:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13d0:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13d2:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    13d6:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13d8:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13dc:	08 95       	ret

000013de <rtc_get_time>:
	RTC32.INTCTRL = 0;
	RTC32.CTRL = RTC32_ENABLE_bm;

	// Make sure it's sync'ed before return
	while (rtc_is_busy());
}
    13de:	80 e1       	ldi	r24, 0x10	; 16
    13e0:	80 93 21 04 	sts	0x0421, r24	; 0x800421 <__TEXT_REGION_LENGTH__+0x700421>
    13e4:	e0 e2       	ldi	r30, 0x20	; 32
    13e6:	f4 e0       	ldi	r31, 0x04	; 4
    13e8:	81 81       	ldd	r24, Z+1	; 0x01
    13ea:	84 fd       	sbrc	r24, 4
    13ec:	fd cf       	rjmp	.-6      	; 0x13e8 <rtc_get_time+0xa>
    13ee:	60 91 24 04 	lds	r22, 0x0424	; 0x800424 <__TEXT_REGION_LENGTH__+0x700424>
    13f2:	70 91 25 04 	lds	r23, 0x0425	; 0x800425 <__TEXT_REGION_LENGTH__+0x700425>
    13f6:	80 91 26 04 	lds	r24, 0x0426	; 0x800426 <__TEXT_REGION_LENGTH__+0x700426>
    13fa:	90 91 27 04 	lds	r25, 0x0427	; 0x800427 <__TEXT_REGION_LENGTH__+0x700427>
    13fe:	08 95       	ret

00001400 <__vector_11>:
 *
 * Disables the RTC32 interrupts, then calls the alarm callback function if one
 * has been set.
 */
ISR(RTC32_COMP_vect)
{
    1400:	1f 92       	push	r1
    1402:	0f 92       	push	r0
    1404:	0f b6       	in	r0, 0x3f	; 63
    1406:	0f 92       	push	r0
    1408:	11 24       	eor	r1, r1
    140a:	0b b6       	in	r0, 0x3b	; 59
    140c:	0f 92       	push	r0
    140e:	2f 93       	push	r18
    1410:	3f 93       	push	r19
    1412:	4f 93       	push	r20
    1414:	5f 93       	push	r21
    1416:	6f 93       	push	r22
    1418:	7f 93       	push	r23
    141a:	8f 93       	push	r24
    141c:	9f 93       	push	r25
    141e:	af 93       	push	r26
    1420:	bf 93       	push	r27
    1422:	cf 93       	push	r28
    1424:	df 93       	push	r29
    1426:	ef 93       	push	r30
    1428:	ff 93       	push	r31
	RTC32.INTCTRL = 0;
    142a:	10 92 22 04 	sts	0x0422, r1	; 0x800422 <__TEXT_REGION_LENGTH__+0x700422>
	if (rtc_data.callback)
    142e:	c0 91 95 23 	lds	r28, 0x2395	; 0x802395 <rtc_data>
    1432:	d0 91 96 23 	lds	r29, 0x2396	; 0x802396 <rtc_data+0x1>
    1436:	20 97       	sbiw	r28, 0x00	; 0
		rtc_data.callback(rtc_get_time());
    1438:	19 f0       	breq	.+6      	; 0x1440 <__vector_11+0x40>
    143a:	d1 df       	rcall	.-94     	; 0x13de <rtc_get_time>
    143c:	fe 01       	movw	r30, r28
}
    143e:	19 95       	eicall
    1440:	ff 91       	pop	r31
    1442:	ef 91       	pop	r30
    1444:	df 91       	pop	r29
    1446:	cf 91       	pop	r28
    1448:	bf 91       	pop	r27
    144a:	af 91       	pop	r26
    144c:	9f 91       	pop	r25
    144e:	8f 91       	pop	r24
    1450:	7f 91       	pop	r23
    1452:	6f 91       	pop	r22
    1454:	5f 91       	pop	r21
    1456:	4f 91       	pop	r20
    1458:	3f 91       	pop	r19
    145a:	2f 91       	pop	r18
    145c:	0f 90       	pop	r0
    145e:	0b be       	out	0x3b, r0	; 59
    1460:	0f 90       	pop	r0
    1462:	0f be       	out	0x3f, r0	; 63
    1464:	0f 90       	pop	r0
    1466:	1f 90       	pop	r1
    1468:	18 95       	reti

0000146a <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    146a:	4f 92       	push	r4
    146c:	5f 92       	push	r5
    146e:	6f 92       	push	r6
    1470:	7f 92       	push	r7
    1472:	8f 92       	push	r8
    1474:	9f 92       	push	r9
    1476:	af 92       	push	r10
    1478:	bf 92       	push	r11
    147a:	ef 92       	push	r14
    147c:	ff 92       	push	r15
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	cf 93       	push	r28
    1484:	7c 01       	movw	r14, r24
    1486:	4a 01       	movw	r8, r20
    1488:	5b 01       	movw	r10, r22
    148a:	28 01       	movw	r4, r16
    148c:	39 01       	movw	r6, r18
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    148e:	fc 01       	movw	r30, r24
    1490:	84 81       	ldd	r24, Z+4	; 0x04
    1492:	82 ff       	sbrs	r24, 2
    1494:	16 c0       	rjmp	.+44     	; 0x14c2 <usart_set_baudrate+0x58>

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    1496:	d9 01       	movw	r26, r18
    1498:	c8 01       	movw	r24, r16
    149a:	68 94       	set
    149c:	12 f8       	bld	r1, 2
    149e:	b6 95       	lsr	r27
    14a0:	a7 95       	ror	r26
    14a2:	97 95       	ror	r25
    14a4:	87 95       	ror	r24
    14a6:	16 94       	lsr	r1
    14a8:	d1 f7       	brne	.-12     	; 0x149e <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    14aa:	b9 01       	movw	r22, r18
    14ac:	a8 01       	movw	r20, r16
    14ae:	03 2e       	mov	r0, r19
    14b0:	36 e1       	ldi	r19, 0x16	; 22
    14b2:	76 95       	lsr	r23
    14b4:	67 95       	ror	r22
    14b6:	57 95       	ror	r21
    14b8:	47 95       	ror	r20
    14ba:	3a 95       	dec	r19
    14bc:	d1 f7       	brne	.-12     	; 0x14b2 <usart_set_baudrate+0x48>
    14be:	30 2d       	mov	r19, r0
    14c0:	15 c0       	rjmp	.+42     	; 0x14ec <usart_set_baudrate+0x82>

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
		max_rate /= 2;
    14c2:	d9 01       	movw	r26, r18
    14c4:	c8 01       	movw	r24, r16
    14c6:	68 94       	set
    14c8:	13 f8       	bld	r1, 3
    14ca:	b6 95       	lsr	r27
    14cc:	a7 95       	ror	r26
    14ce:	97 95       	ror	r25
    14d0:	87 95       	ror	r24
    14d2:	16 94       	lsr	r1
    14d4:	d1 f7       	brne	.-12     	; 0x14ca <usart_set_baudrate+0x60>
		min_rate /= 2;
    14d6:	b9 01       	movw	r22, r18
    14d8:	a8 01       	movw	r20, r16
    14da:	03 2e       	mov	r0, r19
    14dc:	37 e1       	ldi	r19, 0x17	; 23
    14de:	76 95       	lsr	r23
    14e0:	67 95       	ror	r22
    14e2:	57 95       	ror	r21
    14e4:	47 95       	ror	r20
    14e6:	3a 95       	dec	r19
    14e8:	d1 f7       	brne	.-12     	; 0x14de <usart_set_baudrate+0x74>
    14ea:	30 2d       	mov	r19, r0
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    14ec:	88 15       	cp	r24, r8
    14ee:	99 05       	cpc	r25, r9
    14f0:	aa 05       	cpc	r26, r10
    14f2:	bb 05       	cpc	r27, r11
    14f4:	08 f4       	brcc	.+2      	; 0x14f8 <usart_set_baudrate+0x8e>
    14f6:	a6 c0       	rjmp	.+332    	; 0x1644 <usart_set_baudrate+0x1da>
    14f8:	84 16       	cp	r8, r20
    14fa:	95 06       	cpc	r9, r21
    14fc:	a6 06       	cpc	r10, r22
    14fe:	b7 06       	cpc	r11, r23
    1500:	08 f4       	brcc	.+2      	; 0x1504 <usart_set_baudrate+0x9a>
    1502:	a2 c0       	rjmp	.+324    	; 0x1648 <usart_set_baudrate+0x1de>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1504:	f7 01       	movw	r30, r14
    1506:	84 81       	ldd	r24, Z+4	; 0x04
    1508:	82 fd       	sbrc	r24, 2
    150a:	04 c0       	rjmp	.+8      	; 0x1514 <usart_set_baudrate+0xaa>
		baud *= 2;
    150c:	88 0c       	add	r8, r8
    150e:	99 1c       	adc	r9, r9
    1510:	aa 1c       	adc	r10, r10
    1512:	bb 1c       	adc	r11, r11
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    1514:	c3 01       	movw	r24, r6
    1516:	b2 01       	movw	r22, r4
    1518:	a5 01       	movw	r20, r10
    151a:	94 01       	movw	r18, r8
    151c:	0e 94 3f 1c 	call	0x387e	; 0x387e <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    1520:	2f 3f       	cpi	r18, 0xFF	; 255
    1522:	31 05       	cpc	r19, r1
    1524:	41 05       	cpc	r20, r1
    1526:	51 05       	cpc	r21, r1
    1528:	08 f4       	brcc	.+2      	; 0x152c <usart_set_baudrate+0xc2>
    152a:	90 c0       	rjmp	.+288    	; 0x164c <usart_set_baudrate+0x1e2>
    152c:	8f ef       	ldi	r24, 0xFF	; 255
    152e:	90 e0       	ldi	r25, 0x00	; 0
    1530:	a0 e0       	ldi	r26, 0x00	; 0
    1532:	b0 e0       	ldi	r27, 0x00	; 0
    1534:	c9 ef       	ldi	r28, 0xF9	; 249
    1536:	05 c0       	rjmp	.+10     	; 0x1542 <usart_set_baudrate+0xd8>
    1538:	28 17       	cp	r18, r24
    153a:	39 07       	cpc	r19, r25
    153c:	4a 07       	cpc	r20, r26
    153e:	5b 07       	cpc	r21, r27
    1540:	58 f0       	brcs	.+22     	; 0x1558 <usart_set_baudrate+0xee>
			break;
		}

		limit <<= 1;
    1542:	88 0f       	add	r24, r24
    1544:	99 1f       	adc	r25, r25
    1546:	aa 1f       	adc	r26, r26
    1548:	bb 1f       	adc	r27, r27

		if (exp < -3) {
    154a:	cd 3f       	cpi	r28, 0xFD	; 253
    154c:	0c f4       	brge	.+2      	; 0x1550 <usart_set_baudrate+0xe6>
			limit |= 1;
    154e:	81 60       	ori	r24, 0x01	; 1
    1550:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1552:	c7 30       	cpi	r28, 0x07	; 7
    1554:	89 f7       	brne	.-30     	; 0x1538 <usart_set_baudrate+0xce>
    1556:	4f c0       	rjmp	.+158    	; 0x15f6 <usart_set_baudrate+0x18c>
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    1558:	cc 23       	and	r28, r28
    155a:	0c f0       	brlt	.+2      	; 0x155e <usart_set_baudrate+0xf4>
    155c:	4c c0       	rjmp	.+152    	; 0x15f6 <usart_set_baudrate+0x18c>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    155e:	d5 01       	movw	r26, r10
    1560:	c4 01       	movw	r24, r8
    1562:	88 0f       	add	r24, r24
    1564:	99 1f       	adc	r25, r25
    1566:	aa 1f       	adc	r26, r26
    1568:	bb 1f       	adc	r27, r27
    156a:	88 0f       	add	r24, r24
    156c:	99 1f       	adc	r25, r25
    156e:	aa 1f       	adc	r26, r26
    1570:	bb 1f       	adc	r27, r27
    1572:	88 0f       	add	r24, r24
    1574:	99 1f       	adc	r25, r25
    1576:	aa 1f       	adc	r26, r26
    1578:	bb 1f       	adc	r27, r27
    157a:	48 1a       	sub	r4, r24
    157c:	59 0a       	sbc	r5, r25
    157e:	6a 0a       	sbc	r6, r26
    1580:	7b 0a       	sbc	r7, r27
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    1582:	ce 3f       	cpi	r28, 0xFE	; 254
    1584:	f4 f4       	brge	.+60     	; 0x15c2 <usart_set_baudrate+0x158>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    1586:	8d ef       	ldi	r24, 0xFD	; 253
    1588:	9f ef       	ldi	r25, 0xFF	; 255
    158a:	8c 1b       	sub	r24, r28
    158c:	91 09       	sbc	r25, r1
    158e:	c7 fd       	sbrc	r28, 7
    1590:	93 95       	inc	r25
    1592:	04 c0       	rjmp	.+8      	; 0x159c <usart_set_baudrate+0x132>
    1594:	44 0c       	add	r4, r4
    1596:	55 1c       	adc	r5, r5
    1598:	66 1c       	adc	r6, r6
    159a:	77 1c       	adc	r7, r7
    159c:	8a 95       	dec	r24
    159e:	d2 f7       	brpl	.-12     	; 0x1594 <usart_set_baudrate+0x12a>
    15a0:	d5 01       	movw	r26, r10
    15a2:	c4 01       	movw	r24, r8
    15a4:	b6 95       	lsr	r27
    15a6:	a7 95       	ror	r26
    15a8:	97 95       	ror	r25
    15aa:	87 95       	ror	r24
    15ac:	bc 01       	movw	r22, r24
    15ae:	cd 01       	movw	r24, r26
    15b0:	64 0d       	add	r22, r4
    15b2:	75 1d       	adc	r23, r5
    15b4:	86 1d       	adc	r24, r6
    15b6:	97 1d       	adc	r25, r7
    15b8:	a5 01       	movw	r20, r10
    15ba:	94 01       	movw	r18, r8
    15bc:	0e 94 3f 1c 	call	0x387e	; 0x387e <__udivmodsi4>
    15c0:	37 c0       	rjmp	.+110    	; 0x1630 <usart_set_baudrate+0x1c6>
		} else {
			baud <<= exp + 3;
    15c2:	83 e0       	ldi	r24, 0x03	; 3
    15c4:	8c 0f       	add	r24, r28
    15c6:	a5 01       	movw	r20, r10
    15c8:	94 01       	movw	r18, r8
    15ca:	04 c0       	rjmp	.+8      	; 0x15d4 <usart_set_baudrate+0x16a>
    15cc:	22 0f       	add	r18, r18
    15ce:	33 1f       	adc	r19, r19
    15d0:	44 1f       	adc	r20, r20
    15d2:	55 1f       	adc	r21, r21
    15d4:	8a 95       	dec	r24
    15d6:	d2 f7       	brpl	.-12     	; 0x15cc <usart_set_baudrate+0x162>
			div = (cpu_hz + baud / 2) / baud;
    15d8:	da 01       	movw	r26, r20
    15da:	c9 01       	movw	r24, r18
    15dc:	b6 95       	lsr	r27
    15de:	a7 95       	ror	r26
    15e0:	97 95       	ror	r25
    15e2:	87 95       	ror	r24
    15e4:	bc 01       	movw	r22, r24
    15e6:	cd 01       	movw	r24, r26
    15e8:	64 0d       	add	r22, r4
    15ea:	75 1d       	adc	r23, r5
    15ec:	86 1d       	adc	r24, r6
    15ee:	97 1d       	adc	r25, r7
    15f0:	0e 94 3f 1c 	call	0x387e	; 0x387e <__udivmodsi4>
    15f4:	1d c0       	rjmp	.+58     	; 0x1630 <usart_set_baudrate+0x1c6>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    15f6:	83 e0       	ldi	r24, 0x03	; 3
    15f8:	8c 0f       	add	r24, r28
    15fa:	a5 01       	movw	r20, r10
    15fc:	94 01       	movw	r18, r8
    15fe:	04 c0       	rjmp	.+8      	; 0x1608 <usart_set_baudrate+0x19e>
    1600:	22 0f       	add	r18, r18
    1602:	33 1f       	adc	r19, r19
    1604:	44 1f       	adc	r20, r20
    1606:	55 1f       	adc	r21, r21
    1608:	8a 95       	dec	r24
    160a:	d2 f7       	brpl	.-12     	; 0x1600 <usart_set_baudrate+0x196>
		div = (cpu_hz + baud / 2) / baud - 1;
    160c:	da 01       	movw	r26, r20
    160e:	c9 01       	movw	r24, r18
    1610:	b6 95       	lsr	r27
    1612:	a7 95       	ror	r26
    1614:	97 95       	ror	r25
    1616:	87 95       	ror	r24
    1618:	bc 01       	movw	r22, r24
    161a:	cd 01       	movw	r24, r26
    161c:	64 0d       	add	r22, r4
    161e:	75 1d       	adc	r23, r5
    1620:	86 1d       	adc	r24, r6
    1622:	97 1d       	adc	r25, r7
    1624:	0e 94 3f 1c 	call	0x387e	; 0x387e <__udivmodsi4>
    1628:	21 50       	subi	r18, 0x01	; 1
    162a:	31 09       	sbc	r19, r1
    162c:	41 09       	sbc	r20, r1
    162e:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    1630:	83 2f       	mov	r24, r19
    1632:	8f 70       	andi	r24, 0x0F	; 15
    1634:	c2 95       	swap	r28
    1636:	c0 7f       	andi	r28, 0xF0	; 240
    1638:	c8 2b       	or	r28, r24
    163a:	f7 01       	movw	r30, r14
    163c:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    163e:	26 83       	std	Z+6, r18	; 0x06

	return true;
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	18 c0       	rjmp	.+48     	; 0x1674 <usart_set_baudrate+0x20a>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    1644:	80 e0       	ldi	r24, 0x00	; 0
    1646:	16 c0       	rjmp	.+44     	; 0x1674 <usart_set_baudrate+0x20a>
    1648:	80 e0       	ldi	r24, 0x00	; 0
    164a:	14 c0       	rjmp	.+40     	; 0x1674 <usart_set_baudrate+0x20a>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    164c:	d5 01       	movw	r26, r10
    164e:	c4 01       	movw	r24, r8
    1650:	88 0f       	add	r24, r24
    1652:	99 1f       	adc	r25, r25
    1654:	aa 1f       	adc	r26, r26
    1656:	bb 1f       	adc	r27, r27
    1658:	88 0f       	add	r24, r24
    165a:	99 1f       	adc	r25, r25
    165c:	aa 1f       	adc	r26, r26
    165e:	bb 1f       	adc	r27, r27
    1660:	88 0f       	add	r24, r24
    1662:	99 1f       	adc	r25, r25
    1664:	aa 1f       	adc	r26, r26
    1666:	bb 1f       	adc	r27, r27
    1668:	48 1a       	sub	r4, r24
    166a:	59 0a       	sbc	r5, r25
    166c:	6a 0a       	sbc	r6, r26
    166e:	7b 0a       	sbc	r7, r27

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    1670:	c9 ef       	ldi	r28, 0xF9	; 249
    1672:	89 cf       	rjmp	.-238    	; 0x1586 <usart_set_baudrate+0x11c>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    1674:	cf 91       	pop	r28
    1676:	1f 91       	pop	r17
    1678:	0f 91       	pop	r16
    167a:	ff 90       	pop	r15
    167c:	ef 90       	pop	r14
    167e:	bf 90       	pop	r11
    1680:	af 90       	pop	r10
    1682:	9f 90       	pop	r9
    1684:	8f 90       	pop	r8
    1686:	7f 90       	pop	r7
    1688:	6f 90       	pop	r6
    168a:	5f 90       	pop	r5
    168c:	4f 90       	pop	r4
    168e:	08 95       	ret

00001690 <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    1690:	0f 93       	push	r16
    1692:	1f 93       	push	r17
    1694:	cf 93       	push	r28
    1696:	df 93       	push	r29
    1698:	ec 01       	movw	r28, r24
    169a:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    169c:	00 97       	sbiw	r24, 0x00	; 0
    169e:	09 f4       	brne	.+2      	; 0x16a2 <usart_init_rs232+0x12>
    16a0:	e6 c0       	rjmp	.+460    	; 0x186e <usart_init_rs232+0x1de>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    16a2:	80 3c       	cpi	r24, 0xC0	; 192
    16a4:	91 05       	cpc	r25, r1
    16a6:	21 f4       	brne	.+8      	; 0x16b0 <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    16a8:	60 e1       	ldi	r22, 0x10	; 16
    16aa:	80 e0       	ldi	r24, 0x00	; 0
    16ac:	f6 d8       	rcall	.-3604   	; 0x89a <sysclk_enable_module>
    16ae:	df c0       	rjmp	.+446    	; 0x186e <usart_init_rs232+0x1de>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    16b0:	c0 38       	cpi	r28, 0x80	; 128
    16b2:	81 e0       	ldi	r24, 0x01	; 1
    16b4:	d8 07       	cpc	r29, r24
    16b6:	21 f4       	brne	.+8      	; 0x16c0 <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    16b8:	62 e0       	ldi	r22, 0x02	; 2
    16ba:	80 e0       	ldi	r24, 0x00	; 0
    16bc:	ee d8       	rcall	.-3620   	; 0x89a <sysclk_enable_module>
    16be:	d7 c0       	rjmp	.+430    	; 0x186e <usart_init_rs232+0x1de>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    16c0:	c1 15       	cp	r28, r1
    16c2:	e1 e0       	ldi	r30, 0x01	; 1
    16c4:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    16c6:	21 f4       	brne	.+8      	; 0x16d0 <usart_init_rs232+0x40>
    16c8:	61 e0       	ldi	r22, 0x01	; 1
    16ca:	80 e0       	ldi	r24, 0x00	; 0
    16cc:	e6 d8       	rcall	.-3636   	; 0x89a <sysclk_enable_module>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    16ce:	cf c0       	rjmp	.+414    	; 0x186e <usart_init_rs232+0x1de>
    16d0:	c0 38       	cpi	r28, 0x80	; 128
    16d2:	f3 e0       	ldi	r31, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    16d4:	df 07       	cpc	r29, r31
    16d6:	21 f4       	brne	.+8      	; 0x16e0 <usart_init_rs232+0x50>
    16d8:	61 e0       	ldi	r22, 0x01	; 1
    16da:	81 e0       	ldi	r24, 0x01	; 1
    16dc:	de d8       	rcall	.-3652   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    16de:	c7 c0       	rjmp	.+398    	; 0x186e <usart_init_rs232+0x1de>
    16e0:	c0 39       	cpi	r28, 0x90	; 144
    16e2:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    16e4:	d8 07       	cpc	r29, r24
    16e6:	21 f4       	brne	.+8      	; 0x16f0 <usart_init_rs232+0x60>
    16e8:	61 e0       	ldi	r22, 0x01	; 1
    16ea:	82 e0       	ldi	r24, 0x02	; 2
    16ec:	d6 d8       	rcall	.-3668   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    16ee:	bf c0       	rjmp	.+382    	; 0x186e <usart_init_rs232+0x1de>
    16f0:	c1 15       	cp	r28, r1
    16f2:	e2 e0       	ldi	r30, 0x02	; 2
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    16f4:	de 07       	cpc	r29, r30
    16f6:	21 f4       	brne	.+8      	; 0x1700 <usart_init_rs232+0x70>
    16f8:	62 e0       	ldi	r22, 0x02	; 2
    16fa:	81 e0       	ldi	r24, 0x01	; 1
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    16fc:	ce d8       	rcall	.-3684   	; 0x89a <sysclk_enable_module>
    16fe:	b7 c0       	rjmp	.+366    	; 0x186e <usart_init_rs232+0x1de>
    1700:	c0 34       	cpi	r28, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1702:	f2 e0       	ldi	r31, 0x02	; 2
    1704:	df 07       	cpc	r29, r31
    1706:	21 f4       	brne	.+8      	; 0x1710 <usart_init_rs232+0x80>
    1708:	62 e0       	ldi	r22, 0x02	; 2
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    170a:	82 e0       	ldi	r24, 0x02	; 2
    170c:	c6 d8       	rcall	.-3700   	; 0x89a <sysclk_enable_module>
    170e:	af c0       	rjmp	.+350    	; 0x186e <usart_init_rs232+0x1de>
    1710:	c0 32       	cpi	r28, 0x20	; 32
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1712:	83 e0       	ldi	r24, 0x03	; 3
    1714:	d8 07       	cpc	r29, r24
    1716:	21 f4       	brne	.+8      	; 0x1720 <usart_init_rs232+0x90>
    1718:	64 e0       	ldi	r22, 0x04	; 4
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    171a:	82 e0       	ldi	r24, 0x02	; 2
    171c:	be d8       	rcall	.-3716   	; 0x89a <sysclk_enable_module>
    171e:	a7 c0       	rjmp	.+334    	; 0x186e <usart_init_rs232+0x1de>
    1720:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1722:	e8 e0       	ldi	r30, 0x08	; 8
    1724:	de 07       	cpc	r29, r30
    1726:	21 f4       	brne	.+8      	; 0x1730 <usart_init_rs232+0xa0>
    1728:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    172a:	83 e0       	ldi	r24, 0x03	; 3
    172c:	b6 d8       	rcall	.-3732   	; 0x89a <sysclk_enable_module>
    172e:	9f c0       	rjmp	.+318    	; 0x186e <usart_init_rs232+0x1de>
    1730:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1732:	f9 e0       	ldi	r31, 0x09	; 9
    1734:	df 07       	cpc	r29, r31
    1736:	21 f4       	brne	.+8      	; 0x1740 <usart_init_rs232+0xb0>
    1738:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    173a:	84 e0       	ldi	r24, 0x04	; 4
    173c:	ae d8       	rcall	.-3748   	; 0x89a <sysclk_enable_module>
    173e:	97 c0       	rjmp	.+302    	; 0x186e <usart_init_rs232+0x1de>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1740:	c1 15       	cp	r28, r1
    1742:	8a e0       	ldi	r24, 0x0A	; 10
    1744:	d8 07       	cpc	r29, r24
    1746:	21 f4       	brne	.+8      	; 0x1750 <usart_init_rs232+0xc0>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    1748:	61 e0       	ldi	r22, 0x01	; 1
    174a:	85 e0       	ldi	r24, 0x05	; 5
    174c:	a6 d8       	rcall	.-3764   	; 0x89a <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    174e:	8f c0       	rjmp	.+286    	; 0x186e <usart_init_rs232+0x1de>
    1750:	c1 15       	cp	r28, r1
    1752:	eb e0       	ldi	r30, 0x0B	; 11
    1754:	de 07       	cpc	r29, r30
    1756:	21 f4       	brne	.+8      	; 0x1760 <usart_init_rs232+0xd0>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1758:	61 e0       	ldi	r22, 0x01	; 1
    175a:	86 e0       	ldi	r24, 0x06	; 6
    175c:	9e d8       	rcall	.-3780   	; 0x89a <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    175e:	87 c0       	rjmp	.+270    	; 0x186e <usart_init_rs232+0x1de>
    1760:	c0 34       	cpi	r28, 0x40	; 64
    1762:	f8 e0       	ldi	r31, 0x08	; 8
    1764:	df 07       	cpc	r29, r31
    1766:	21 f4       	brne	.+8      	; 0x1770 <usart_init_rs232+0xe0>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1768:	62 e0       	ldi	r22, 0x02	; 2
    176a:	83 e0       	ldi	r24, 0x03	; 3
    176c:	96 d8       	rcall	.-3796   	; 0x89a <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    176e:	7f c0       	rjmp	.+254    	; 0x186e <usart_init_rs232+0x1de>
    1770:	c0 34       	cpi	r28, 0x40	; 64
    1772:	89 e0       	ldi	r24, 0x09	; 9
    1774:	d8 07       	cpc	r29, r24
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1776:	21 f4       	brne	.+8      	; 0x1780 <usart_init_rs232+0xf0>
    1778:	62 e0       	ldi	r22, 0x02	; 2
    177a:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    177c:	8e d8       	rcall	.-3812   	; 0x89a <sysclk_enable_module>
    177e:	77 c0       	rjmp	.+238    	; 0x186e <usart_init_rs232+0x1de>
    1780:	c0 34       	cpi	r28, 0x40	; 64
    1782:	ea e0       	ldi	r30, 0x0A	; 10
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1784:	de 07       	cpc	r29, r30
    1786:	21 f4       	brne	.+8      	; 0x1790 <usart_init_rs232+0x100>
    1788:	62 e0       	ldi	r22, 0x02	; 2
    178a:	85 e0       	ldi	r24, 0x05	; 5
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    178c:	86 d8       	rcall	.-3828   	; 0x89a <sysclk_enable_module>
    178e:	6f c0       	rjmp	.+222    	; 0x186e <usart_init_rs232+0x1de>
    1790:	c0 39       	cpi	r28, 0x90	; 144
    1792:	f8 e0       	ldi	r31, 0x08	; 8
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1794:	df 07       	cpc	r29, r31
    1796:	21 f4       	brne	.+8      	; 0x17a0 <usart_init_rs232+0x110>
    1798:	64 e0       	ldi	r22, 0x04	; 4
    179a:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    179c:	7e d8       	rcall	.-3844   	; 0x89a <sysclk_enable_module>
    179e:	67 c0       	rjmp	.+206    	; 0x186e <usart_init_rs232+0x1de>
    17a0:	c0 39       	cpi	r28, 0x90	; 144
    17a2:	89 e0       	ldi	r24, 0x09	; 9
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    17a4:	d8 07       	cpc	r29, r24
    17a6:	21 f4       	brne	.+8      	; 0x17b0 <usart_init_rs232+0x120>
    17a8:	64 e0       	ldi	r22, 0x04	; 4
    17aa:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    17ac:	76 d8       	rcall	.-3860   	; 0x89a <sysclk_enable_module>
    17ae:	5f c0       	rjmp	.+190    	; 0x186e <usart_init_rs232+0x1de>
    17b0:	c0 39       	cpi	r28, 0x90	; 144
    17b2:	ea e0       	ldi	r30, 0x0A	; 10
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    17b4:	de 07       	cpc	r29, r30
    17b6:	21 f4       	brne	.+8      	; 0x17c0 <usart_init_rs232+0x130>
    17b8:	64 e0       	ldi	r22, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    17ba:	85 e0       	ldi	r24, 0x05	; 5
    17bc:	6e d8       	rcall	.-3876   	; 0x89a <sysclk_enable_module>
    17be:	57 c0       	rjmp	.+174    	; 0x186e <usart_init_rs232+0x1de>
    17c0:	c0 39       	cpi	r28, 0x90	; 144
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    17c2:	fb e0       	ldi	r31, 0x0B	; 11
    17c4:	df 07       	cpc	r29, r31
    17c6:	21 f4       	brne	.+8      	; 0x17d0 <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    17c8:	64 e0       	ldi	r22, 0x04	; 4
    17ca:	86 e0       	ldi	r24, 0x06	; 6
    17cc:	66 d8       	rcall	.-3892   	; 0x89a <sysclk_enable_module>
    17ce:	4f c0       	rjmp	.+158    	; 0x186e <usart_init_rs232+0x1de>
    17d0:	c0 3c       	cpi	r28, 0xC0	; 192
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    17d2:	88 e0       	ldi	r24, 0x08	; 8
    17d4:	d8 07       	cpc	r29, r24
    17d6:	21 f4       	brne	.+8      	; 0x17e0 <usart_init_rs232+0x150>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    17d8:	68 e0       	ldi	r22, 0x08	; 8
    17da:	83 e0       	ldi	r24, 0x03	; 3
    17dc:	5e d8       	rcall	.-3908   	; 0x89a <sysclk_enable_module>
    17de:	47 c0       	rjmp	.+142    	; 0x186e <usart_init_rs232+0x1de>
    17e0:	c0 3c       	cpi	r28, 0xC0	; 192
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    17e2:	e9 e0       	ldi	r30, 0x09	; 9
    17e4:	de 07       	cpc	r29, r30
    17e6:	21 f4       	brne	.+8      	; 0x17f0 <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    17e8:	68 e0       	ldi	r22, 0x08	; 8
    17ea:	84 e0       	ldi	r24, 0x04	; 4
    17ec:	56 d8       	rcall	.-3924   	; 0x89a <sysclk_enable_module>
    17ee:	3f c0       	rjmp	.+126    	; 0x186e <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    17f0:	c0 3a       	cpi	r28, 0xA0	; 160
    17f2:	f8 e0       	ldi	r31, 0x08	; 8
    17f4:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    17f6:	21 f4       	brne	.+8      	; 0x1800 <usart_init_rs232+0x170>
    17f8:	60 e1       	ldi	r22, 0x10	; 16
    17fa:	83 e0       	ldi	r24, 0x03	; 3
    17fc:	4e d8       	rcall	.-3940   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    17fe:	37 c0       	rjmp	.+110    	; 0x186e <usart_init_rs232+0x1de>
    1800:	c0 3a       	cpi	r28, 0xA0	; 160
    1802:	89 e0       	ldi	r24, 0x09	; 9
    1804:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1806:	21 f4       	brne	.+8      	; 0x1810 <usart_init_rs232+0x180>
    1808:	60 e1       	ldi	r22, 0x10	; 16
    180a:	84 e0       	ldi	r24, 0x04	; 4
    180c:	46 d8       	rcall	.-3956   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    180e:	2f c0       	rjmp	.+94     	; 0x186e <usart_init_rs232+0x1de>
    1810:	c0 3a       	cpi	r28, 0xA0	; 160
    1812:	ea e0       	ldi	r30, 0x0A	; 10
    1814:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1816:	21 f4       	brne	.+8      	; 0x1820 <usart_init_rs232+0x190>
    1818:	60 e1       	ldi	r22, 0x10	; 16
    181a:	85 e0       	ldi	r24, 0x05	; 5
    181c:	3e d8       	rcall	.-3972   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    181e:	27 c0       	rjmp	.+78     	; 0x186e <usart_init_rs232+0x1de>
    1820:	c0 3a       	cpi	r28, 0xA0	; 160
    1822:	fb e0       	ldi	r31, 0x0B	; 11
    1824:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1826:	21 f4       	brne	.+8      	; 0x1830 <usart_init_rs232+0x1a0>
    1828:	60 e1       	ldi	r22, 0x10	; 16
    182a:	86 e0       	ldi	r24, 0x06	; 6
    182c:	36 d8       	rcall	.-3988   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    182e:	1f c0       	rjmp	.+62     	; 0x186e <usart_init_rs232+0x1de>
    1830:	c0 3b       	cpi	r28, 0xB0	; 176
    1832:	88 e0       	ldi	r24, 0x08	; 8
    1834:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1836:	21 f4       	brne	.+8      	; 0x1840 <usart_init_rs232+0x1b0>
    1838:	60 e2       	ldi	r22, 0x20	; 32
    183a:	83 e0       	ldi	r24, 0x03	; 3
    183c:	2e d8       	rcall	.-4004   	; 0x89a <sysclk_enable_module>
    183e:	17 c0       	rjmp	.+46     	; 0x186e <usart_init_rs232+0x1de>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1840:	c0 3b       	cpi	r28, 0xB0	; 176
    1842:	e9 e0       	ldi	r30, 0x09	; 9
    1844:	de 07       	cpc	r29, r30
    1846:	21 f4       	brne	.+8      	; 0x1850 <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1848:	60 e2       	ldi	r22, 0x20	; 32
    184a:	84 e0       	ldi	r24, 0x04	; 4
    184c:	26 d8       	rcall	.-4020   	; 0x89a <sysclk_enable_module>
    184e:	0f c0       	rjmp	.+30     	; 0x186e <usart_init_rs232+0x1de>
    1850:	c0 38       	cpi	r28, 0x80	; 128
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1852:	f4 e0       	ldi	r31, 0x04	; 4
    1854:	df 07       	cpc	r29, r31
    1856:	21 f4       	brne	.+8      	; 0x1860 <usart_init_rs232+0x1d0>
    1858:	60 e4       	ldi	r22, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    185a:	83 e0       	ldi	r24, 0x03	; 3
    185c:	1e d8       	rcall	.-4036   	; 0x89a <sysclk_enable_module>
    185e:	07 c0       	rjmp	.+14     	; 0x186e <usart_init_rs232+0x1de>
    1860:	c0 3a       	cpi	r28, 0xA0	; 160
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1862:	84 e0       	ldi	r24, 0x04	; 4
    1864:	d8 07       	cpc	r29, r24
    1866:	19 f4       	brne	.+6      	; 0x186e <usart_init_rs232+0x1de>
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    1868:	60 e4       	ldi	r22, 0x40	; 64
    186a:	85 e0       	ldi	r24, 0x05	; 5
    186c:	16 d8       	rcall	.-4052   	; 0x89a <sysclk_enable_module>
    186e:	8d 81       	ldd	r24, Y+5	; 0x05
    1870:	8f 73       	andi	r24, 0x3F	; 63
    1872:	8d 83       	std	Y+5, r24	; 0x05
    1874:	f8 01       	movw	r30, r16
    1876:	95 81       	ldd	r25, Z+5	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1878:	84 81       	ldd	r24, Z+4	; 0x04
    187a:	89 2b       	or	r24, r25
    187c:	96 81       	ldd	r25, Z+6	; 0x06
    187e:	91 11       	cpse	r25, r1
    1880:	98 e0       	ldi	r25, 0x08	; 8
    1882:	89 2b       	or	r24, r25
    1884:	8d 83       	std	Y+5, r24	; 0x05
    1886:	f8 01       	movw	r30, r16
    1888:	40 81       	ld	r20, Z
    188a:	51 81       	ldd	r21, Z+1	; 0x01
    188c:	62 81       	ldd	r22, Z+2	; 0x02
    188e:	73 81       	ldd	r23, Z+3	; 0x03
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1890:	00 e8       	ldi	r16, 0x80	; 128
    1892:	14 e8       	ldi	r17, 0x84	; 132
    1894:	2e e1       	ldi	r18, 0x1E	; 30
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1896:	30 e0       	ldi	r19, 0x00	; 0
    1898:	ce 01       	movw	r24, r28
    189a:	e7 dd       	rcall	.-1074   	; 0x146a <usart_set_baudrate>
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    189c:	9c 81       	ldd	r25, Y+4	; 0x04
    189e:	98 60       	ori	r25, 0x08	; 8
    18a0:	9c 83       	std	Y+4, r25	; 0x04
    18a2:	9c 81       	ldd	r25, Y+4	; 0x04
    18a4:	90 61       	ori	r25, 0x10	; 16
    18a6:	9c 83       	std	Y+4, r25	; 0x04
    18a8:	df 91       	pop	r29
    18aa:	cf 91       	pop	r28
    18ac:	1f 91       	pop	r17
    18ae:	0f 91       	pop	r16
    18b0:	08 95       	ret

000018b2 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    18b2:	cf 92       	push	r12
    18b4:	df 92       	push	r13
    18b6:	ef 92       	push	r14
    18b8:	ff 92       	push	r15
    18ba:	0f 93       	push	r16
    18bc:	1f 93       	push	r17
    18be:	cf 93       	push	r28
    18c0:	df 93       	push	r29
    18c2:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    18c4:	d9 01       	movw	r26, r18
    18c6:	c8 01       	movw	r24, r16
    18c8:	b6 95       	lsr	r27
    18ca:	a7 95       	ror	r26
    18cc:	97 95       	ror	r25
    18ce:	87 95       	ror	r24
    18d0:	48 17       	cp	r20, r24
    18d2:	59 07       	cpc	r21, r25
    18d4:	6a 07       	cpc	r22, r26
    18d6:	7b 07       	cpc	r23, r27
    18d8:	78 f4       	brcc	.+30     	; 0x18f8 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    18da:	6a 01       	movw	r12, r20
    18dc:	7b 01       	movw	r14, r22
    18de:	cc 0c       	add	r12, r12
    18e0:	dd 1c       	adc	r13, r13
    18e2:	ee 1c       	adc	r14, r14
    18e4:	ff 1c       	adc	r15, r15
    18e6:	c9 01       	movw	r24, r18
    18e8:	b8 01       	movw	r22, r16
    18ea:	a7 01       	movw	r20, r14
    18ec:	96 01       	movw	r18, r12
    18ee:	0e 94 3f 1c 	call	0x387e	; 0x387e <__udivmodsi4>
    18f2:	21 50       	subi	r18, 0x01	; 1
    18f4:	31 09       	sbc	r19, r1
    18f6:	02 c0       	rjmp	.+4      	; 0x18fc <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    18f8:	20 e0       	ldi	r18, 0x00	; 0
    18fa:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    18fc:	83 2f       	mov	r24, r19
    18fe:	8f 70       	andi	r24, 0x0F	; 15
    1900:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1902:	2e 83       	std	Y+6, r18	; 0x06
}
    1904:	df 91       	pop	r29
    1906:	cf 91       	pop	r28
    1908:	1f 91       	pop	r17
    190a:	0f 91       	pop	r16
    190c:	ff 90       	pop	r15
    190e:	ef 90       	pop	r14
    1910:	df 90       	pop	r13
    1912:	cf 90       	pop	r12
    1914:	08 95       	ret

00001916 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1916:	ef 92       	push	r14
    1918:	ff 92       	push	r15
    191a:	0f 93       	push	r16
    191c:	1f 93       	push	r17
    191e:	cf 93       	push	r28
    1920:	df 93       	push	r29
    1922:	ec 01       	movw	r28, r24
    1924:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1926:	00 97       	sbiw	r24, 0x00	; 0
    1928:	09 f4       	brne	.+2      	; 0x192c <usart_init_spi+0x16>
    192a:	98 c1       	rjmp	.+816    	; 0x1c5c <usart_init_spi+0x346>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    192c:	80 3c       	cpi	r24, 0xC0	; 192
    192e:	91 05       	cpc	r25, r1
    1930:	29 f4       	brne	.+10     	; 0x193c <usart_init_spi+0x26>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1932:	60 e1       	ldi	r22, 0x10	; 16
    1934:	80 e0       	ldi	r24, 0x00	; 0
    1936:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    193a:	90 c1       	rjmp	.+800    	; 0x1c5c <usart_init_spi+0x346>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    193c:	80 38       	cpi	r24, 0x80	; 128
    193e:	91 40       	sbci	r25, 0x01	; 1
    1940:	29 f4       	brne	.+10     	; 0x194c <usart_init_spi+0x36>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1942:	62 e0       	ldi	r22, 0x02	; 2
    1944:	80 e0       	ldi	r24, 0x00	; 0
    1946:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    194a:	88 c1       	rjmp	.+784    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    194c:	c1 15       	cp	r28, r1
    194e:	81 e0       	ldi	r24, 0x01	; 1
    1950:	d8 07       	cpc	r29, r24
    1952:	29 f4       	brne	.+10     	; 0x195e <usart_init_spi+0x48>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1954:	61 e0       	ldi	r22, 0x01	; 1
    1956:	80 e0       	ldi	r24, 0x00	; 0
    1958:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    195c:	7f c1       	rjmp	.+766    	; 0x1c5c <usart_init_spi+0x346>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    195e:	c0 38       	cpi	r28, 0x80	; 128
    1960:	e3 e0       	ldi	r30, 0x03	; 3
    1962:	de 07       	cpc	r29, r30
    1964:	29 f4       	brne	.+10     	; 0x1970 <usart_init_spi+0x5a>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1966:	61 e0       	ldi	r22, 0x01	; 1
    1968:	81 e0       	ldi	r24, 0x01	; 1
    196a:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    196e:	76 c1       	rjmp	.+748    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1970:	c0 39       	cpi	r28, 0x90	; 144
    1972:	f3 e0       	ldi	r31, 0x03	; 3
    1974:	df 07       	cpc	r29, r31
    1976:	29 f4       	brne	.+10     	; 0x1982 <usart_init_spi+0x6c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1978:	61 e0       	ldi	r22, 0x01	; 1
    197a:	82 e0       	ldi	r24, 0x02	; 2
    197c:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1980:	6d c1       	rjmp	.+730    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1982:	c1 15       	cp	r28, r1
    1984:	32 e0       	ldi	r19, 0x02	; 2
    1986:	d3 07       	cpc	r29, r19
    1988:	29 f4       	brne	.+10     	; 0x1994 <usart_init_spi+0x7e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    198a:	62 e0       	ldi	r22, 0x02	; 2
    198c:	81 e0       	ldi	r24, 0x01	; 1
    198e:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1992:	64 c1       	rjmp	.+712    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    1994:	c0 34       	cpi	r28, 0x40	; 64
    1996:	82 e0       	ldi	r24, 0x02	; 2
    1998:	d8 07       	cpc	r29, r24
    199a:	29 f4       	brne	.+10     	; 0x19a6 <usart_init_spi+0x90>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    199c:	62 e0       	ldi	r22, 0x02	; 2
    199e:	82 e0       	ldi	r24, 0x02	; 2
    19a0:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19a4:	5b c1       	rjmp	.+694    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    19a6:	c0 32       	cpi	r28, 0x20	; 32
    19a8:	e3 e0       	ldi	r30, 0x03	; 3
    19aa:	de 07       	cpc	r29, r30
    19ac:	29 f4       	brne	.+10     	; 0x19b8 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    19ae:	64 e0       	ldi	r22, 0x04	; 4
    19b0:	82 e0       	ldi	r24, 0x02	; 2
    19b2:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19b6:	52 c1       	rjmp	.+676    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    19b8:	c1 15       	cp	r28, r1
    19ba:	f8 e0       	ldi	r31, 0x08	; 8
    19bc:	df 07       	cpc	r29, r31
    19be:	29 f4       	brne	.+10     	; 0x19ca <usart_init_spi+0xb4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    19c0:	61 e0       	ldi	r22, 0x01	; 1
    19c2:	83 e0       	ldi	r24, 0x03	; 3
    19c4:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19c8:	49 c1       	rjmp	.+658    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    19ca:	c1 15       	cp	r28, r1
    19cc:	39 e0       	ldi	r19, 0x09	; 9
    19ce:	d3 07       	cpc	r29, r19
    19d0:	29 f4       	brne	.+10     	; 0x19dc <usart_init_spi+0xc6>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    19d2:	61 e0       	ldi	r22, 0x01	; 1
    19d4:	84 e0       	ldi	r24, 0x04	; 4
    19d6:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19da:	40 c1       	rjmp	.+640    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    19dc:	c1 15       	cp	r28, r1
    19de:	8a e0       	ldi	r24, 0x0A	; 10
    19e0:	d8 07       	cpc	r29, r24
    19e2:	29 f4       	brne	.+10     	; 0x19ee <usart_init_spi+0xd8>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    19e4:	61 e0       	ldi	r22, 0x01	; 1
    19e6:	85 e0       	ldi	r24, 0x05	; 5
    19e8:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19ec:	37 c1       	rjmp	.+622    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    19ee:	c1 15       	cp	r28, r1
    19f0:	eb e0       	ldi	r30, 0x0B	; 11
    19f2:	de 07       	cpc	r29, r30
    19f4:	29 f4       	brne	.+10     	; 0x1a00 <usart_init_spi+0xea>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    19f6:	61 e0       	ldi	r22, 0x01	; 1
    19f8:	86 e0       	ldi	r24, 0x06	; 6
    19fa:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19fe:	2e c1       	rjmp	.+604    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1a00:	c0 34       	cpi	r28, 0x40	; 64
    1a02:	f8 e0       	ldi	r31, 0x08	; 8
    1a04:	df 07       	cpc	r29, r31
    1a06:	29 f4       	brne	.+10     	; 0x1a12 <usart_init_spi+0xfc>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1a08:	62 e0       	ldi	r22, 0x02	; 2
    1a0a:	83 e0       	ldi	r24, 0x03	; 3
    1a0c:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a10:	25 c1       	rjmp	.+586    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1a12:	c0 34       	cpi	r28, 0x40	; 64
    1a14:	39 e0       	ldi	r19, 0x09	; 9
    1a16:	d3 07       	cpc	r29, r19
    1a18:	29 f4       	brne	.+10     	; 0x1a24 <usart_init_spi+0x10e>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1a1a:	62 e0       	ldi	r22, 0x02	; 2
    1a1c:	84 e0       	ldi	r24, 0x04	; 4
    1a1e:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a22:	1c c1       	rjmp	.+568    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1a24:	c0 34       	cpi	r28, 0x40	; 64
    1a26:	8a e0       	ldi	r24, 0x0A	; 10
    1a28:	d8 07       	cpc	r29, r24
    1a2a:	29 f4       	brne	.+10     	; 0x1a36 <usart_init_spi+0x120>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1a2c:	62 e0       	ldi	r22, 0x02	; 2
    1a2e:	85 e0       	ldi	r24, 0x05	; 5
    1a30:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a34:	13 c1       	rjmp	.+550    	; 0x1c5c <usart_init_spi+0x346>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1a36:	c0 39       	cpi	r28, 0x90	; 144
    1a38:	e8 e0       	ldi	r30, 0x08	; 8
    1a3a:	de 07       	cpc	r29, r30
    1a3c:	29 f4       	brne	.+10     	; 0x1a48 <usart_init_spi+0x132>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1a3e:	64 e0       	ldi	r22, 0x04	; 4
    1a40:	83 e0       	ldi	r24, 0x03	; 3
    1a42:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a46:	0a c1       	rjmp	.+532    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    1a48:	c0 39       	cpi	r28, 0x90	; 144
    1a4a:	f9 e0       	ldi	r31, 0x09	; 9
    1a4c:	df 07       	cpc	r29, r31
    1a4e:	29 f4       	brne	.+10     	; 0x1a5a <usart_init_spi+0x144>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1a50:	64 e0       	ldi	r22, 0x04	; 4
    1a52:	84 e0       	ldi	r24, 0x04	; 4
    1a54:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a58:	01 c1       	rjmp	.+514    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1a5a:	c0 39       	cpi	r28, 0x90	; 144
    1a5c:	3a e0       	ldi	r19, 0x0A	; 10
    1a5e:	d3 07       	cpc	r29, r19
    1a60:	29 f4       	brne	.+10     	; 0x1a6c <usart_init_spi+0x156>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1a62:	64 e0       	ldi	r22, 0x04	; 4
    1a64:	85 e0       	ldi	r24, 0x05	; 5
    1a66:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a6a:	f8 c0       	rjmp	.+496    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1a6c:	c0 39       	cpi	r28, 0x90	; 144
    1a6e:	8b e0       	ldi	r24, 0x0B	; 11
    1a70:	d8 07       	cpc	r29, r24
    1a72:	29 f4       	brne	.+10     	; 0x1a7e <usart_init_spi+0x168>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1a74:	64 e0       	ldi	r22, 0x04	; 4
    1a76:	86 e0       	ldi	r24, 0x06	; 6
    1a78:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a7c:	ef c0       	rjmp	.+478    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1a7e:	c0 3c       	cpi	r28, 0xC0	; 192
    1a80:	e8 e0       	ldi	r30, 0x08	; 8
    1a82:	de 07       	cpc	r29, r30
    1a84:	29 f4       	brne	.+10     	; 0x1a90 <usart_init_spi+0x17a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1a86:	68 e0       	ldi	r22, 0x08	; 8
    1a88:	83 e0       	ldi	r24, 0x03	; 3
    1a8a:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a8e:	e6 c0       	rjmp	.+460    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1a90:	c0 3c       	cpi	r28, 0xC0	; 192
    1a92:	f9 e0       	ldi	r31, 0x09	; 9
    1a94:	df 07       	cpc	r29, r31
    1a96:	29 f4       	brne	.+10     	; 0x1aa2 <usart_init_spi+0x18c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1a98:	68 e0       	ldi	r22, 0x08	; 8
    1a9a:	84 e0       	ldi	r24, 0x04	; 4
    1a9c:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1aa0:	dd c0       	rjmp	.+442    	; 0x1c5c <usart_init_spi+0x346>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1aa2:	c0 3a       	cpi	r28, 0xA0	; 160
    1aa4:	38 e0       	ldi	r19, 0x08	; 8
    1aa6:	d3 07       	cpc	r29, r19
    1aa8:	69 f4       	brne	.+26     	; 0x1ac4 <usart_init_spi+0x1ae>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1aaa:	60 e1       	ldi	r22, 0x10	; 16
    1aac:	83 e0       	ldi	r24, 0x03	; 3
    1aae:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1ab2:	e0 ea       	ldi	r30, 0xA0	; 160
    1ab4:	f8 e0       	ldi	r31, 0x08	; 8
    1ab6:	84 81       	ldd	r24, Z+4	; 0x04
    1ab8:	8f 7e       	andi	r24, 0xEF	; 239
    1aba:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1abc:	f7 01       	movw	r30, r14
    1abe:	24 81       	ldd	r18, Z+4	; 0x04
    1ac0:	22 50       	subi	r18, 0x02	; 2
    1ac2:	4a c0       	rjmp	.+148    	; 0x1b58 <usart_init_spi+0x242>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1ac4:	c0 3a       	cpi	r28, 0xA0	; 160
    1ac6:	f9 e0       	ldi	r31, 0x09	; 9
    1ac8:	df 07       	cpc	r29, r31
    1aca:	29 f4       	brne	.+10     	; 0x1ad6 <usart_init_spi+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1acc:	60 e1       	ldi	r22, 0x10	; 16
    1ace:	84 e0       	ldi	r24, 0x04	; 4
    1ad0:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1ad4:	c3 c0       	rjmp	.+390    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1ad6:	c0 3a       	cpi	r28, 0xA0	; 160
    1ad8:	3a e0       	ldi	r19, 0x0A	; 10
    1ada:	d3 07       	cpc	r29, r19
    1adc:	29 f4       	brne	.+10     	; 0x1ae8 <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1ade:	60 e1       	ldi	r22, 0x10	; 16
    1ae0:	85 e0       	ldi	r24, 0x05	; 5
    1ae2:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1ae6:	ba c0       	rjmp	.+372    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1ae8:	c0 3a       	cpi	r28, 0xA0	; 160
    1aea:	8b e0       	ldi	r24, 0x0B	; 11
    1aec:	d8 07       	cpc	r29, r24
    1aee:	29 f4       	brne	.+10     	; 0x1afa <usart_init_spi+0x1e4>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1af0:	60 e1       	ldi	r22, 0x10	; 16
    1af2:	86 e0       	ldi	r24, 0x06	; 6
    1af4:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1af8:	b1 c0       	rjmp	.+354    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1afa:	c0 3b       	cpi	r28, 0xB0	; 176
    1afc:	e8 e0       	ldi	r30, 0x08	; 8
    1afe:	de 07       	cpc	r29, r30
    1b00:	29 f4       	brne	.+10     	; 0x1b0c <usart_init_spi+0x1f6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1b02:	60 e2       	ldi	r22, 0x20	; 32
    1b04:	83 e0       	ldi	r24, 0x03	; 3
    1b06:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1b0a:	a8 c0       	rjmp	.+336    	; 0x1c5c <usart_init_spi+0x346>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1b0c:	c0 3b       	cpi	r28, 0xB0	; 176
    1b0e:	f9 e0       	ldi	r31, 0x09	; 9
    1b10:	df 07       	cpc	r29, r31
    1b12:	29 f4       	brne	.+10     	; 0x1b1e <usart_init_spi+0x208>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1b14:	60 e2       	ldi	r22, 0x20	; 32
    1b16:	84 e0       	ldi	r24, 0x04	; 4
    1b18:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1b1c:	9f c0       	rjmp	.+318    	; 0x1c5c <usart_init_spi+0x346>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1b1e:	c0 38       	cpi	r28, 0x80	; 128
    1b20:	34 e0       	ldi	r19, 0x04	; 4
    1b22:	d3 07       	cpc	r29, r19
    1b24:	29 f4       	brne	.+10     	; 0x1b30 <usart_init_spi+0x21a>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1b26:	60 e4       	ldi	r22, 0x40	; 64
    1b28:	83 e0       	ldi	r24, 0x03	; 3
    1b2a:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1b2e:	96 c0       	rjmp	.+300    	; 0x1c5c <usart_init_spi+0x346>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1b30:	c0 3a       	cpi	r28, 0xA0	; 160
    1b32:	84 e0       	ldi	r24, 0x04	; 4
    1b34:	d8 07       	cpc	r29, r24
    1b36:	29 f4       	brne	.+10     	; 0x1b42 <usart_init_spi+0x22c>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1b38:	60 e4       	ldi	r22, 0x40	; 64
    1b3a:	85 e0       	ldi	r24, 0x05	; 5
    1b3c:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1b40:	8d c0       	rjmp	.+282    	; 0x1c5c <usart_init_spi+0x346>
    1b42:	8c 81       	ldd	r24, Y+4	; 0x04
    1b44:	8f 7e       	andi	r24, 0xEF	; 239
    1b46:	8c 83       	std	Y+4, r24	; 0x04
    1b48:	fb 01       	movw	r30, r22
    1b4a:	24 81       	ldd	r18, Z+4	; 0x04
    1b4c:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1b4e:	ce 01       	movw	r24, r28
    1b50:	c0 3a       	cpi	r28, 0xA0	; 160
    1b52:	f8 e0       	ldi	r31, 0x08	; 8
    1b54:	df 07       	cpc	r29, r31
    1b56:	31 f4       	brne	.+12     	; 0x1b64 <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1b58:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1b5c:	84 fd       	sbrc	r24, 4
    1b5e:	86 c0       	rjmp	.+268    	; 0x1c6c <usart_init_spi+0x356>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1b60:	11 e1       	ldi	r17, 0x11	; 17
    1b62:	85 c0       	rjmp	.+266    	; 0x1c6e <usart_init_spi+0x358>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1b64:	80 3b       	cpi	r24, 0xB0	; 176
    1b66:	38 e0       	ldi	r19, 0x08	; 8
    1b68:	93 07       	cpc	r25, r19
    1b6a:	79 f0       	breq	.+30     	; 0x1b8a <usart_init_spi+0x274>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1b6c:	80 3a       	cpi	r24, 0xA0	; 160
    1b6e:	e9 e0       	ldi	r30, 0x09	; 9
    1b70:	9e 07       	cpc	r25, r30
    1b72:	31 f4       	brne	.+12     	; 0x1b80 <usart_init_spi+0x26a>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1b74:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1b78:	34 fd       	sbrc	r19, 4
    1b7a:	7c c0       	rjmp	.+248    	; 0x1c74 <usart_init_spi+0x35e>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1b7c:	19 e1       	ldi	r17, 0x19	; 25
    1b7e:	10 c0       	rjmp	.+32     	; 0x1ba0 <usart_init_spi+0x28a>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1b80:	80 3b       	cpi	r24, 0xB0	; 176
    1b82:	f9 e0       	ldi	r31, 0x09	; 9
    1b84:	9f 07       	cpc	r25, r31
    1b86:	a9 f0       	breq	.+42     	; 0x1bb2 <usart_init_spi+0x29c>
    1b88:	01 c0       	rjmp	.+2      	; 0x1b8c <usart_init_spi+0x276>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1b8a:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1b8c:	80 3a       	cpi	r24, 0xA0	; 160
    1b8e:	3a e0       	ldi	r19, 0x0A	; 10
    1b90:	93 07       	cpc	r25, r19
    1b92:	31 f4       	brne	.+12     	; 0x1ba0 <usart_init_spi+0x28a>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1b94:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1b98:	84 fd       	sbrc	r24, 4
    1b9a:	6e c0       	rjmp	.+220    	; 0x1c78 <usart_init_spi+0x362>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1b9c:	11 e2       	ldi	r17, 0x21	; 33
    1b9e:	0c c0       	rjmp	.+24     	; 0x1bb8 <usart_init_spi+0x2a2>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1ba0:	80 3a       	cpi	r24, 0xA0	; 160
    1ba2:	9b 40       	sbci	r25, 0x0B	; 11
    1ba4:	49 f4       	brne	.+18     	; 0x1bb8 <usart_init_spi+0x2a2>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1ba6:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1baa:	84 fd       	sbrc	r24, 4
    1bac:	04 c0       	rjmp	.+8      	; 0x1bb6 <usart_init_spi+0x2a0>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1bae:	19 e2       	ldi	r17, 0x29	; 41
    1bb0:	03 c0       	rjmp	.+6      	; 0x1bb8 <usart_init_spi+0x2a2>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1bb2:	1d e1       	ldi	r17, 0x1D	; 29
    1bb4:	01 c0       	rjmp	.+2      	; 0x1bb8 <usart_init_spi+0x2a2>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1bb6:	1d e2       	ldi	r17, 0x2D	; 45
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1bb8:	e1 2f       	mov	r30, r17
    1bba:	e6 95       	lsr	r30
    1bbc:	e6 95       	lsr	r30
    1bbe:	e6 95       	lsr	r30
    1bc0:	30 e2       	ldi	r19, 0x20	; 32
    1bc2:	e3 9f       	mul	r30, r19
    1bc4:	f0 01       	movw	r30, r0
    1bc6:	11 24       	eor	r1, r1
    1bc8:	fa 5f       	subi	r31, 0xFA	; 250
    1bca:	17 70       	andi	r17, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1bcc:	81 e0       	ldi	r24, 0x01	; 1
    1bce:	90 e0       	ldi	r25, 0x00	; 0
    1bd0:	01 2e       	mov	r0, r17
    1bd2:	02 c0       	rjmp	.+4      	; 0x1bd8 <usart_init_spi+0x2c2>
    1bd4:	88 0f       	add	r24, r24
    1bd6:	99 1f       	adc	r25, r25
    1bd8:	0a 94       	dec	r0
    1bda:	e2 f7       	brpl	.-8      	; 0x1bd4 <usart_init_spi+0x2be>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1bdc:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    1bde:	22 30       	cpi	r18, 0x02	; 2
    1be0:	10 f0       	brcs	.+4      	; 0x1be6 <usart_init_spi+0x2d0>
    1be2:	40 e0       	ldi	r20, 0x00	; 0
    1be4:	01 c0       	rjmp	.+2      	; 0x1be8 <usart_init_spi+0x2d2>
    1be6:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1be8:	df 01       	movw	r26, r30
    1bea:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    1bec:	a1 0f       	add	r26, r17
    1bee:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1bf0:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    1bf2:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1bf4:	2c 91       	ld	r18, X
    1bf6:	27 70       	andi	r18, 0x07	; 7
    1bf8:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    1bfa:	9c 91       	ld	r25, X
    1bfc:	94 2b       	or	r25, r20
    1bfe:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1c00:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1c02:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1c04:	8d 81       	ldd	r24, Y+5	; 0x05
    1c06:	80 6c       	ori	r24, 0xC0	; 192
    1c08:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    1c0a:	f7 01       	movw	r30, r14
    1c0c:	84 81       	ldd	r24, Z+4	; 0x04
    1c0e:	8d 7f       	andi	r24, 0xFD	; 253
    1c10:	81 30       	cpi	r24, 0x01	; 1
    1c12:	21 f4       	brne	.+8      	; 0x1c1c <usart_init_spi+0x306>
		usart->CTRLC |= USART_UCPHA_bm;
    1c14:	8d 81       	ldd	r24, Y+5	; 0x05
    1c16:	82 60       	ori	r24, 0x02	; 2
    1c18:	8d 83       	std	Y+5, r24	; 0x05
    1c1a:	03 c0       	rjmp	.+6      	; 0x1c22 <usart_init_spi+0x30c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    1c1c:	8d 81       	ldd	r24, Y+5	; 0x05
    1c1e:	8d 7f       	andi	r24, 0xFD	; 253
    1c20:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    1c22:	f7 01       	movw	r30, r14
    1c24:	85 81       	ldd	r24, Z+5	; 0x05
    1c26:	88 23       	and	r24, r24
    1c28:	21 f0       	breq	.+8      	; 0x1c32 <usart_init_spi+0x31c>
		(usart)->CTRLC |= USART_DORD_bm;
    1c2a:	8d 81       	ldd	r24, Y+5	; 0x05
    1c2c:	84 60       	ori	r24, 0x04	; 4
    1c2e:	8d 83       	std	Y+5, r24	; 0x05
    1c30:	03 c0       	rjmp	.+6      	; 0x1c38 <usart_init_spi+0x322>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1c32:	8d 81       	ldd	r24, Y+5	; 0x05
    1c34:	8b 7f       	andi	r24, 0xFB	; 251
    1c36:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1c38:	f7 01       	movw	r30, r14
    1c3a:	40 81       	ld	r20, Z
    1c3c:	51 81       	ldd	r21, Z+1	; 0x01
    1c3e:	62 81       	ldd	r22, Z+2	; 0x02
    1c40:	73 81       	ldd	r23, Z+3	; 0x03
    1c42:	00 e8       	ldi	r16, 0x80	; 128
    1c44:	14 e8       	ldi	r17, 0x84	; 132
    1c46:	2e e1       	ldi	r18, 0x1E	; 30
    1c48:	30 e0       	ldi	r19, 0x00	; 0
    1c4a:	ce 01       	movw	r24, r28
    1c4c:	32 de       	rcall	.-924    	; 0x18b2 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1c4e:	8c 81       	ldd	r24, Y+4	; 0x04
    1c50:	88 60       	ori	r24, 0x08	; 8
    1c52:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1c54:	8c 81       	ldd	r24, Y+4	; 0x04
    1c56:	80 61       	ori	r24, 0x10	; 16
    1c58:	8c 83       	std	Y+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1c5a:	10 c0       	rjmp	.+32     	; 0x1c7c <usart_init_spi+0x366>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1c5c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c5e:	8f 7e       	andi	r24, 0xEF	; 239
    1c60:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1c62:	f7 01       	movw	r30, r14
    1c64:	24 81       	ldd	r18, Z+4	; 0x04
    1c66:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1c68:	ce 01       	movw	r24, r28
    1c6a:	7c cf       	rjmp	.-264    	; 0x1b64 <usart_init_spi+0x24e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1c6c:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1c6e:	80 ea       	ldi	r24, 0xA0	; 160
    1c70:	98 e0       	ldi	r25, 0x08	; 8
    1c72:	86 cf       	rjmp	.-244    	; 0x1b80 <usart_init_spi+0x26a>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1c74:	1d e1       	ldi	r17, 0x1D	; 29
    1c76:	94 cf       	rjmp	.-216    	; 0x1ba0 <usart_init_spi+0x28a>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1c78:	15 e2       	ldi	r17, 0x25	; 37
    1c7a:	9e cf       	rjmp	.-196    	; 0x1bb8 <usart_init_spi+0x2a2>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	1f 91       	pop	r17
    1c82:	0f 91       	pop	r16
    1c84:	ff 90       	pop	r15
    1c86:	ef 90       	pop	r14
    1c88:	08 95       	ret

00001c8a <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1c8a:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c8c:	03 96       	adiw	r24, 0x03	; 3
    1c8e:	81 83       	std	Z+1, r24	; 0x01
    1c90:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1c92:	2f ef       	ldi	r18, 0xFF	; 255
    1c94:	3f ef       	ldi	r19, 0xFF	; 255
    1c96:	23 83       	std	Z+3, r18	; 0x03
    1c98:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c9a:	85 83       	std	Z+5, r24	; 0x05
    1c9c:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c9e:	87 83       	std	Z+7, r24	; 0x07
    1ca0:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1ca2:	10 82       	st	Z, r1
    1ca4:	08 95       	ret

00001ca6 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1ca6:	fc 01       	movw	r30, r24
    1ca8:	10 86       	std	Z+8, r1	; 0x08
    1caa:	11 86       	std	Z+9, r1	; 0x09
    1cac:	08 95       	ret

00001cae <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1cae:	cf 93       	push	r28
    1cb0:	df 93       	push	r29
    1cb2:	9c 01       	movw	r18, r24
    1cb4:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1cb6:	dc 01       	movw	r26, r24
    1cb8:	11 96       	adiw	r26, 0x01	; 1
    1cba:	cd 91       	ld	r28, X+
    1cbc:	dc 91       	ld	r29, X
    1cbe:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1cc0:	c2 83       	std	Z+2, r28	; 0x02
    1cc2:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1cc4:	8c 81       	ldd	r24, Y+4	; 0x04
    1cc6:	9d 81       	ldd	r25, Y+5	; 0x05
    1cc8:	84 83       	std	Z+4, r24	; 0x04
    1cca:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1ccc:	8c 81       	ldd	r24, Y+4	; 0x04
    1cce:	9d 81       	ldd	r25, Y+5	; 0x05
    1cd0:	dc 01       	movw	r26, r24
    1cd2:	12 96       	adiw	r26, 0x02	; 2
    1cd4:	6d 93       	st	X+, r22
    1cd6:	7c 93       	st	X, r23
    1cd8:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1cda:	6c 83       	std	Y+4, r22	; 0x04
    1cdc:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1cde:	20 87       	std	Z+8, r18	; 0x08
    1ce0:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1ce2:	f9 01       	movw	r30, r18
    1ce4:	80 81       	ld	r24, Z
    1ce6:	8f 5f       	subi	r24, 0xFF	; 255
    1ce8:	80 83       	st	Z, r24
}
    1cea:	df 91       	pop	r29
    1cec:	cf 91       	pop	r28
    1cee:	08 95       	ret

00001cf0 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1cf0:	cf 93       	push	r28
    1cf2:	df 93       	push	r29
    1cf4:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1cf6:	48 81       	ld	r20, Y
    1cf8:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1cfa:	4f 3f       	cpi	r20, 0xFF	; 255
    1cfc:	2f ef       	ldi	r18, 0xFF	; 255
    1cfe:	52 07       	cpc	r21, r18
    1d00:	21 f4       	brne	.+8      	; 0x1d0a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1d02:	fc 01       	movw	r30, r24
    1d04:	a7 81       	ldd	r26, Z+7	; 0x07
    1d06:	b0 85       	ldd	r27, Z+8	; 0x08
    1d08:	0d c0       	rjmp	.+26     	; 0x1d24 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1d0a:	dc 01       	movw	r26, r24
    1d0c:	13 96       	adiw	r26, 0x03	; 3
    1d0e:	01 c0       	rjmp	.+2      	; 0x1d12 <vListInsert+0x22>
    1d10:	df 01       	movw	r26, r30
    1d12:	12 96       	adiw	r26, 0x02	; 2
    1d14:	ed 91       	ld	r30, X+
    1d16:	fc 91       	ld	r31, X
    1d18:	13 97       	sbiw	r26, 0x03	; 3
    1d1a:	20 81       	ld	r18, Z
    1d1c:	31 81       	ldd	r19, Z+1	; 0x01
    1d1e:	42 17       	cp	r20, r18
    1d20:	53 07       	cpc	r21, r19
    1d22:	b0 f7       	brcc	.-20     	; 0x1d10 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1d24:	12 96       	adiw	r26, 0x02	; 2
    1d26:	ed 91       	ld	r30, X+
    1d28:	fc 91       	ld	r31, X
    1d2a:	13 97       	sbiw	r26, 0x03	; 3
    1d2c:	ea 83       	std	Y+2, r30	; 0x02
    1d2e:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1d30:	c4 83       	std	Z+4, r28	; 0x04
    1d32:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1d34:	ac 83       	std	Y+4, r26	; 0x04
    1d36:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1d38:	12 96       	adiw	r26, 0x02	; 2
    1d3a:	cd 93       	st	X+, r28
    1d3c:	dc 93       	st	X, r29
    1d3e:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1d40:	88 87       	std	Y+8, r24	; 0x08
    1d42:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1d44:	fc 01       	movw	r30, r24
    1d46:	20 81       	ld	r18, Z
    1d48:	2f 5f       	subi	r18, 0xFF	; 255
    1d4a:	20 83       	st	Z, r18
}
    1d4c:	df 91       	pop	r29
    1d4e:	cf 91       	pop	r28
    1d50:	08 95       	ret

00001d52 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1d52:	cf 93       	push	r28
    1d54:	df 93       	push	r29
    1d56:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1d58:	a0 85       	ldd	r26, Z+8	; 0x08
    1d5a:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1d5c:	c2 81       	ldd	r28, Z+2	; 0x02
    1d5e:	d3 81       	ldd	r29, Z+3	; 0x03
    1d60:	84 81       	ldd	r24, Z+4	; 0x04
    1d62:	95 81       	ldd	r25, Z+5	; 0x05
    1d64:	8c 83       	std	Y+4, r24	; 0x04
    1d66:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1d68:	c4 81       	ldd	r28, Z+4	; 0x04
    1d6a:	d5 81       	ldd	r29, Z+5	; 0x05
    1d6c:	82 81       	ldd	r24, Z+2	; 0x02
    1d6e:	93 81       	ldd	r25, Z+3	; 0x03
    1d70:	8a 83       	std	Y+2, r24	; 0x02
    1d72:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1d74:	11 96       	adiw	r26, 0x01	; 1
    1d76:	8d 91       	ld	r24, X+
    1d78:	9c 91       	ld	r25, X
    1d7a:	12 97       	sbiw	r26, 0x02	; 2
    1d7c:	e8 17       	cp	r30, r24
    1d7e:	f9 07       	cpc	r31, r25
    1d80:	31 f4       	brne	.+12     	; 0x1d8e <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1d82:	84 81       	ldd	r24, Z+4	; 0x04
    1d84:	95 81       	ldd	r25, Z+5	; 0x05
    1d86:	11 96       	adiw	r26, 0x01	; 1
    1d88:	8d 93       	st	X+, r24
    1d8a:	9c 93       	st	X, r25
    1d8c:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1d8e:	10 86       	std	Z+8, r1	; 0x08
    1d90:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1d92:	8c 91       	ld	r24, X
    1d94:	81 50       	subi	r24, 0x01	; 1
    1d96:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1d98:	df 91       	pop	r29
    1d9a:	cf 91       	pop	r28
    1d9c:	08 95       	ret

00001d9e <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1d9e:	0f 93       	push	r16
    1da0:	1f 93       	push	r17
    1da2:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1da4:	71 e1       	ldi	r23, 0x11	; 17
    1da6:	fc 01       	movw	r30, r24
    1da8:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1daa:	31 97       	sbiw	r30, 0x01	; 1
    1dac:	62 e2       	ldi	r22, 0x22	; 34
    1dae:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    1db0:	31 97       	sbiw	r30, 0x01	; 1
    1db2:	23 e3       	ldi	r18, 0x33	; 51
    1db4:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1db6:	01 2e       	mov	r0, r17
    1db8:	00 0c       	add	r0, r0
    1dba:	22 0b       	sbc	r18, r18
    1dbc:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1dbe:	31 97       	sbiw	r30, 0x01	; 1
    1dc0:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1dc2:	31 97       	sbiw	r30, 0x01	; 1
    1dc4:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1dc6:	31 97       	sbiw	r30, 0x01	; 1
    1dc8:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1dca:	31 97       	sbiw	r30, 0x01	; 1
    1dcc:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    1dce:	31 97       	sbiw	r30, 0x01	; 1
    1dd0:	20 e8       	ldi	r18, 0x80	; 128
    1dd2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1dd4:	31 97       	sbiw	r30, 0x01	; 1
    1dd6:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1dd8:	31 97       	sbiw	r30, 0x01	; 1
    1dda:	22 e0       	ldi	r18, 0x02	; 2
    1ddc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    1dde:	31 97       	sbiw	r30, 0x01	; 1
    1de0:	23 e0       	ldi	r18, 0x03	; 3
    1de2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1de4:	31 97       	sbiw	r30, 0x01	; 1
    1de6:	24 e0       	ldi	r18, 0x04	; 4
    1de8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1dea:	31 97       	sbiw	r30, 0x01	; 1
    1dec:	25 e0       	ldi	r18, 0x05	; 5
    1dee:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1df0:	31 97       	sbiw	r30, 0x01	; 1
    1df2:	26 e0       	ldi	r18, 0x06	; 6
    1df4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1df6:	31 97       	sbiw	r30, 0x01	; 1
    1df8:	27 e0       	ldi	r18, 0x07	; 7
    1dfa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1dfc:	31 97       	sbiw	r30, 0x01	; 1
    1dfe:	28 e0       	ldi	r18, 0x08	; 8
    1e00:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1e02:	31 97       	sbiw	r30, 0x01	; 1
    1e04:	29 e0       	ldi	r18, 0x09	; 9
    1e06:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1e08:	31 97       	sbiw	r30, 0x01	; 1
    1e0a:	20 e1       	ldi	r18, 0x10	; 16
    1e0c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    1e0e:	31 97       	sbiw	r30, 0x01	; 1
    1e10:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1e12:	31 97       	sbiw	r30, 0x01	; 1
    1e14:	22 e1       	ldi	r18, 0x12	; 18
    1e16:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1e18:	31 97       	sbiw	r30, 0x01	; 1
    1e1a:	23 e1       	ldi	r18, 0x13	; 19
    1e1c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    1e1e:	31 97       	sbiw	r30, 0x01	; 1
    1e20:	24 e1       	ldi	r18, 0x14	; 20
    1e22:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1e24:	31 97       	sbiw	r30, 0x01	; 1
    1e26:	25 e1       	ldi	r18, 0x15	; 21
    1e28:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1e2a:	31 97       	sbiw	r30, 0x01	; 1
    1e2c:	26 e1       	ldi	r18, 0x16	; 22
    1e2e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1e30:	31 97       	sbiw	r30, 0x01	; 1
    1e32:	27 e1       	ldi	r18, 0x17	; 23
    1e34:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1e36:	31 97       	sbiw	r30, 0x01	; 1
    1e38:	28 e1       	ldi	r18, 0x18	; 24
    1e3a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1e3c:	31 97       	sbiw	r30, 0x01	; 1
    1e3e:	29 e1       	ldi	r18, 0x19	; 25
    1e40:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1e42:	31 97       	sbiw	r30, 0x01	; 1
    1e44:	20 e2       	ldi	r18, 0x20	; 32
    1e46:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1e48:	31 97       	sbiw	r30, 0x01	; 1
    1e4a:	21 e2       	ldi	r18, 0x21	; 33
    1e4c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    1e4e:	31 97       	sbiw	r30, 0x01	; 1
    1e50:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1e52:	31 97       	sbiw	r30, 0x01	; 1
    1e54:	23 e2       	ldi	r18, 0x23	; 35
    1e56:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1e58:	31 97       	sbiw	r30, 0x01	; 1
    1e5a:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1e5c:	31 97       	sbiw	r30, 0x01	; 1
    1e5e:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1e60:	31 97       	sbiw	r30, 0x01	; 1
    1e62:	26 e2       	ldi	r18, 0x26	; 38
    1e64:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1e66:	31 97       	sbiw	r30, 0x01	; 1
    1e68:	27 e2       	ldi	r18, 0x27	; 39
    1e6a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1e6c:	31 97       	sbiw	r30, 0x01	; 1
    1e6e:	28 e2       	ldi	r18, 0x28	; 40
    1e70:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1e72:	31 97       	sbiw	r30, 0x01	; 1
    1e74:	29 e2       	ldi	r18, 0x29	; 41
    1e76:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1e78:	31 97       	sbiw	r30, 0x01	; 1
    1e7a:	20 e3       	ldi	r18, 0x30	; 48
    1e7c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    1e7e:	31 97       	sbiw	r30, 0x01	; 1
    1e80:	21 e3       	ldi	r18, 0x31	; 49
    1e82:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1e84:	87 97       	sbiw	r24, 0x27	; 39
    1e86:	1f 91       	pop	r17
    1e88:	0f 91       	pop	r16
    1e8a:	08 95       	ret

00001e8c <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1e8c:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    1e8e:	e0 e7       	ldi	r30, 0x70	; 112
    1e90:	f0 e0       	ldi	r31, 0x00	; 0
    1e92:	83 81       	ldd	r24, Z+3	; 0x03
    1e94:	8a 7f       	andi	r24, 0xFA	; 250
    1e96:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1e98:	e0 e0       	ldi	r30, 0x00	; 0
    1e9a:	f8 e0       	ldi	r31, 0x08	; 8
    1e9c:	80 e0       	ldi	r24, 0x00	; 0
    1e9e:	9a ef       	ldi	r25, 0xFA	; 250
    1ea0:	86 a3       	std	Z+38, r24	; 0x26
    1ea2:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1ea4:	91 e0       	ldi	r25, 0x01	; 1
    1ea6:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1ea8:	a0 ea       	ldi	r26, 0xA0	; 160
    1eaa:	b0 e0       	ldi	r27, 0x00	; 0
    1eac:	12 96       	adiw	r26, 0x02	; 2
    1eae:	8c 91       	ld	r24, X
    1eb0:	12 97       	sbiw	r26, 0x02	; 2
    1eb2:	81 60       	ori	r24, 0x01	; 1
    1eb4:	12 96       	adiw	r26, 0x02	; 2
    1eb6:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1eb8:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1eba:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1ebc:	a0 91 9a 22 	lds	r26, 0x229A	; 0x80229a <pxCurrentTCB>
    1ec0:	b0 91 9b 22 	lds	r27, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    1ec4:	0d 90       	ld	r0, X+
    1ec6:	0d be       	out	0x3d, r0	; 61
    1ec8:	0d 90       	ld	r0, X+
    1eca:	0e be       	out	0x3e, r0	; 62
    1ecc:	ff 91       	pop	r31
    1ece:	ef 91       	pop	r30
    1ed0:	df 91       	pop	r29
    1ed2:	cf 91       	pop	r28
    1ed4:	bf 91       	pop	r27
    1ed6:	af 91       	pop	r26
    1ed8:	9f 91       	pop	r25
    1eda:	8f 91       	pop	r24
    1edc:	7f 91       	pop	r23
    1ede:	6f 91       	pop	r22
    1ee0:	5f 91       	pop	r21
    1ee2:	4f 91       	pop	r20
    1ee4:	3f 91       	pop	r19
    1ee6:	2f 91       	pop	r18
    1ee8:	1f 91       	pop	r17
    1eea:	0f 91       	pop	r16
    1eec:	ff 90       	pop	r15
    1eee:	ef 90       	pop	r14
    1ef0:	df 90       	pop	r13
    1ef2:	cf 90       	pop	r12
    1ef4:	bf 90       	pop	r11
    1ef6:	af 90       	pop	r10
    1ef8:	9f 90       	pop	r9
    1efa:	8f 90       	pop	r8
    1efc:	7f 90       	pop	r7
    1efe:	6f 90       	pop	r6
    1f00:	5f 90       	pop	r5
    1f02:	4f 90       	pop	r4
    1f04:	3f 90       	pop	r3
    1f06:	2f 90       	pop	r2
    1f08:	1f 90       	pop	r1
    1f0a:	0f 90       	pop	r0
    1f0c:	0f be       	out	0x3f, r0	; 63
    1f0e:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1f10:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1f12:	81 e0       	ldi	r24, 0x01	; 1
    1f14:	08 95       	ret

00001f16 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1f16:	0f 92       	push	r0
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	0f 92       	push	r0
    1f1e:	1f 92       	push	r1
    1f20:	11 24       	eor	r1, r1
    1f22:	2f 92       	push	r2
    1f24:	3f 92       	push	r3
    1f26:	4f 92       	push	r4
    1f28:	5f 92       	push	r5
    1f2a:	6f 92       	push	r6
    1f2c:	7f 92       	push	r7
    1f2e:	8f 92       	push	r8
    1f30:	9f 92       	push	r9
    1f32:	af 92       	push	r10
    1f34:	bf 92       	push	r11
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	2f 93       	push	r18
    1f44:	3f 93       	push	r19
    1f46:	4f 93       	push	r20
    1f48:	5f 93       	push	r21
    1f4a:	6f 93       	push	r22
    1f4c:	7f 93       	push	r23
    1f4e:	8f 93       	push	r24
    1f50:	9f 93       	push	r25
    1f52:	af 93       	push	r26
    1f54:	bf 93       	push	r27
    1f56:	cf 93       	push	r28
    1f58:	df 93       	push	r29
    1f5a:	ef 93       	push	r30
    1f5c:	ff 93       	push	r31
    1f5e:	a0 91 9a 22 	lds	r26, 0x229A	; 0x80229a <pxCurrentTCB>
    1f62:	b0 91 9b 22 	lds	r27, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    1f66:	0d b6       	in	r0, 0x3d	; 61
    1f68:	0d 92       	st	X+, r0
    1f6a:	0e b6       	in	r0, 0x3e	; 62
    vTaskSwitchContext();
    1f6c:	0d 92       	st	X+, r0
    portRESTORE_CONTEXT();
    1f6e:	0e d6       	rcall	.+3100   	; 0x2b8c <vTaskSwitchContext>
    1f70:	a0 91 9a 22 	lds	r26, 0x229A	; 0x80229a <pxCurrentTCB>
    1f74:	b0 91 9b 22 	lds	r27, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    1f78:	0d 90       	ld	r0, X+
    1f7a:	0d be       	out	0x3d, r0	; 61
    1f7c:	0d 90       	ld	r0, X+
    1f7e:	0e be       	out	0x3e, r0	; 62
    1f80:	ff 91       	pop	r31
    1f82:	ef 91       	pop	r30
    1f84:	df 91       	pop	r29
    1f86:	cf 91       	pop	r28
    1f88:	bf 91       	pop	r27
    1f8a:	af 91       	pop	r26
    1f8c:	9f 91       	pop	r25
    1f8e:	8f 91       	pop	r24
    1f90:	7f 91       	pop	r23
    1f92:	6f 91       	pop	r22
    1f94:	5f 91       	pop	r21
    1f96:	4f 91       	pop	r20
    1f98:	3f 91       	pop	r19
    1f9a:	2f 91       	pop	r18
    1f9c:	1f 91       	pop	r17
    1f9e:	0f 91       	pop	r16
    1fa0:	ff 90       	pop	r15
    1fa2:	ef 90       	pop	r14
    1fa4:	df 90       	pop	r13
    1fa6:	cf 90       	pop	r12
    1fa8:	bf 90       	pop	r11
    1faa:	af 90       	pop	r10
    1fac:	9f 90       	pop	r9
    1fae:	8f 90       	pop	r8
    1fb0:	7f 90       	pop	r7
    1fb2:	6f 90       	pop	r6
    1fb4:	5f 90       	pop	r5
    1fb6:	4f 90       	pop	r4
    1fb8:	3f 90       	pop	r3
    1fba:	2f 90       	pop	r2
    1fbc:	1f 90       	pop	r1
    1fbe:	0f 90       	pop	r0
    1fc0:	0f be       	out	0x3f, r0	; 63

    asm volatile ( "ret" );
    1fc2:	0f 90       	pop	r0
    1fc4:	08 95       	ret

00001fc6 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1fc6:	0f 92       	push	r0
    1fc8:	0f b6       	in	r0, 0x3f	; 63
    1fca:	f8 94       	cli
    1fcc:	0f 92       	push	r0
    1fce:	1f 92       	push	r1
    1fd0:	11 24       	eor	r1, r1
    1fd2:	2f 92       	push	r2
    1fd4:	3f 92       	push	r3
    1fd6:	4f 92       	push	r4
    1fd8:	5f 92       	push	r5
    1fda:	6f 92       	push	r6
    1fdc:	7f 92       	push	r7
    1fde:	8f 92       	push	r8
    1fe0:	9f 92       	push	r9
    1fe2:	af 92       	push	r10
    1fe4:	bf 92       	push	r11
    1fe6:	cf 92       	push	r12
    1fe8:	df 92       	push	r13
    1fea:	ef 92       	push	r14
    1fec:	ff 92       	push	r15
    1fee:	0f 93       	push	r16
    1ff0:	1f 93       	push	r17
    1ff2:	2f 93       	push	r18
    1ff4:	3f 93       	push	r19
    1ff6:	4f 93       	push	r20
    1ff8:	5f 93       	push	r21
    1ffa:	6f 93       	push	r22
    1ffc:	7f 93       	push	r23
    1ffe:	8f 93       	push	r24
    2000:	9f 93       	push	r25
    2002:	af 93       	push	r26
    2004:	bf 93       	push	r27
    2006:	cf 93       	push	r28
    2008:	df 93       	push	r29
    200a:	ef 93       	push	r30
    200c:	ff 93       	push	r31
    200e:	a0 91 9a 22 	lds	r26, 0x229A	; 0x80229a <pxCurrentTCB>
    2012:	b0 91 9b 22 	lds	r27, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2016:	0d b6       	in	r0, 0x3d	; 61
    2018:	0d 92       	st	X+, r0
    201a:	0e b6       	in	r0, 0x3e	; 62
        if( xTaskIncrementTick() != pdFALSE )
    201c:	0d 92       	st	X+, r0
        {
            vTaskSwitchContext();
    201e:	4b d4       	rcall	.+2198   	; 0x28b6 <xTaskIncrementTick>
    2020:	81 11       	cpse	r24, r1
        }
        portRESTORE_CONTEXT();
    2022:	b4 d5       	rcall	.+2920   	; 0x2b8c <vTaskSwitchContext>
    2024:	a0 91 9a 22 	lds	r26, 0x229A	; 0x80229a <pxCurrentTCB>
    2028:	b0 91 9b 22 	lds	r27, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    202c:	0d 90       	ld	r0, X+
    202e:	0d be       	out	0x3d, r0	; 61
    2030:	0d 90       	ld	r0, X+
    2032:	0e be       	out	0x3e, r0	; 62
    2034:	ff 91       	pop	r31
    2036:	ef 91       	pop	r30
    2038:	df 91       	pop	r29
    203a:	cf 91       	pop	r28
    203c:	bf 91       	pop	r27
    203e:	af 91       	pop	r26
    2040:	9f 91       	pop	r25
    2042:	8f 91       	pop	r24
    2044:	7f 91       	pop	r23
    2046:	6f 91       	pop	r22
    2048:	5f 91       	pop	r21
    204a:	4f 91       	pop	r20
    204c:	3f 91       	pop	r19
    204e:	2f 91       	pop	r18
    2050:	1f 91       	pop	r17
    2052:	0f 91       	pop	r16
    2054:	ff 90       	pop	r15
    2056:	ef 90       	pop	r14
    2058:	df 90       	pop	r13
    205a:	cf 90       	pop	r12
    205c:	bf 90       	pop	r11
    205e:	af 90       	pop	r10
    2060:	9f 90       	pop	r9
    2062:	8f 90       	pop	r8
    2064:	7f 90       	pop	r7
    2066:	6f 90       	pop	r6
    2068:	5f 90       	pop	r5
    206a:	4f 90       	pop	r4
    206c:	3f 90       	pop	r3
    206e:	2f 90       	pop	r2
    2070:	1f 90       	pop	r1
    2072:	0f 90       	pop	r0
    2074:	0f be       	out	0x3f, r0	; 63

        asm volatile ( "reti" );
    2076:	0f 90       	pop	r0
    2078:	18 95       	reti

0000207a <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    207a:	cf 93       	push	r28
    207c:	df 93       	push	r29
void *pvReturn;

	vTaskSuspendAll();
    207e:	ec 01       	movw	r28, r24
	{
		pvReturn = malloc( xWantedSize );
    2080:	0a d4       	rcall	.+2068   	; 0x2896 <vTaskSuspendAll>
    2082:	ce 01       	movw	r24, r28
    2084:	0e 94 69 1c 	call	0x38d2	; 0x38d2 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    2088:	ec 01       	movw	r28, r24
		}
	}
	#endif

	return pvReturn;
}
    208a:	e8 d4       	rcall	.+2512   	; 0x2a5c <xTaskResumeAll>
    208c:	ce 01       	movw	r24, r28
    208e:	df 91       	pop	r29
    2090:	cf 91       	pop	r28
    2092:	08 95       	ret

00002094 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
	if( pv )
    2098:	00 97       	sbiw	r24, 0x00	; 0
    209a:	31 f0       	breq	.+12     	; 0x20a8 <vPortFree+0x14>
	{
		vTaskSuspendAll();
    209c:	ec 01       	movw	r28, r24
		{
			free( pv );
    209e:	fb d3       	rcall	.+2038   	; 0x2896 <vTaskSuspendAll>
    20a0:	ce 01       	movw	r24, r28
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    20a2:	0e 94 01 1d 	call	0x3a02	; 0x3a02 <free>
	}
}
    20a6:	da d4       	rcall	.+2484   	; 0x2a5c <xTaskResumeAll>
    20a8:	df 91       	pop	r29
    20aa:	cf 91       	pop	r28
    20ac:	08 95       	ret

000020ae <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    20ae:	1f 93       	push	r17
    20b0:	cf 93       	push	r28
    20b2:	df 93       	push	r29
    20b4:	ec 01       	movw	r28, r24
    20b6:	14 2f       	mov	r17, r20
    20b8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    20ba:	44 23       	and	r20, r20
    20bc:	d9 f1       	breq	.+118    	; 0x2134 <prvCopyDataToQueue+0x86>
    20be:	11 11       	cpse	r17, r1
    20c0:	16 c0       	rjmp	.+44     	; 0x20ee <prvCopyDataToQueue+0x40>
    20c2:	50 e0       	ldi	r21, 0x00	; 0
    20c4:	8c 81       	ldd	r24, Y+4	; 0x04
    20c6:	9d 81       	ldd	r25, Y+5	; 0x05
    20c8:	0e 94 8a 1d 	call	0x3b14	; 0x3b14 <memcpy>
    20cc:	2c 8d       	ldd	r18, Y+28	; 0x1c
    20ce:	8c 81       	ldd	r24, Y+4	; 0x04
    20d0:	9d 81       	ldd	r25, Y+5	; 0x05
    20d2:	82 0f       	add	r24, r18
    20d4:	91 1d       	adc	r25, r1
    20d6:	8c 83       	std	Y+4, r24	; 0x04
    20d8:	9d 83       	std	Y+5, r25	; 0x05
    20da:	2a 81       	ldd	r18, Y+2	; 0x02
    20dc:	3b 81       	ldd	r19, Y+3	; 0x03
    20de:	82 17       	cp	r24, r18
    20e0:	93 07       	cpc	r25, r19
    20e2:	40 f1       	brcs	.+80     	; 0x2134 <prvCopyDataToQueue+0x86>
    20e4:	88 81       	ld	r24, Y
    20e6:	99 81       	ldd	r25, Y+1	; 0x01
    20e8:	8c 83       	std	Y+4, r24	; 0x04
    20ea:	9d 83       	std	Y+5, r25	; 0x05
    20ec:	23 c0       	rjmp	.+70     	; 0x2134 <prvCopyDataToQueue+0x86>
    20ee:	50 e0       	ldi	r21, 0x00	; 0
    20f0:	8e 81       	ldd	r24, Y+6	; 0x06
    20f2:	9f 81       	ldd	r25, Y+7	; 0x07
    20f4:	0e 94 8a 1d 	call	0x3b14	; 0x3b14 <memcpy>
    20f8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    20fa:	90 e0       	ldi	r25, 0x00	; 0
    20fc:	91 95       	neg	r25
    20fe:	81 95       	neg	r24
    2100:	91 09       	sbc	r25, r1
    2102:	2e 81       	ldd	r18, Y+6	; 0x06
    2104:	3f 81       	ldd	r19, Y+7	; 0x07
    2106:	28 0f       	add	r18, r24
    2108:	39 1f       	adc	r19, r25
    210a:	2e 83       	std	Y+6, r18	; 0x06
    210c:	3f 83       	std	Y+7, r19	; 0x07
    210e:	48 81       	ld	r20, Y
    2110:	59 81       	ldd	r21, Y+1	; 0x01
    2112:	24 17       	cp	r18, r20
    2114:	35 07       	cpc	r19, r21
    2116:	30 f4       	brcc	.+12     	; 0x2124 <prvCopyDataToQueue+0x76>
    2118:	2a 81       	ldd	r18, Y+2	; 0x02
    211a:	3b 81       	ldd	r19, Y+3	; 0x03
    211c:	82 0f       	add	r24, r18
    211e:	93 1f       	adc	r25, r19
    2120:	8e 83       	std	Y+6, r24	; 0x06
    2122:	9f 83       	std	Y+7, r25	; 0x07
    2124:	12 30       	cpi	r17, 0x02	; 2
    2126:	31 f4       	brne	.+12     	; 0x2134 <prvCopyDataToQueue+0x86>
    2128:	8a 8d       	ldd	r24, Y+26	; 0x1a
    212a:	88 23       	and	r24, r24
    212c:	19 f0       	breq	.+6      	; 0x2134 <prvCopyDataToQueue+0x86>
    212e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2130:	81 50       	subi	r24, 0x01	; 1
    2132:	8a 8f       	std	Y+26, r24	; 0x1a
    2134:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2136:	8f 5f       	subi	r24, 0xFF	; 255
    2138:	8a 8f       	std	Y+26, r24	; 0x1a
    213a:	80 e0       	ldi	r24, 0x00	; 0
    213c:	df 91       	pop	r29
    213e:	cf 91       	pop	r28
    2140:	1f 91       	pop	r17
    2142:	08 95       	ret

00002144 <prvCopyDataFromQueue>:
    2144:	fc 01       	movw	r30, r24
    2146:	44 8d       	ldd	r20, Z+28	; 0x1c
    2148:	44 23       	and	r20, r20
    214a:	a9 f0       	breq	.+42     	; 0x2176 <prvCopyDataFromQueue+0x32>
    214c:	50 e0       	ldi	r21, 0x00	; 0
    214e:	26 81       	ldd	r18, Z+6	; 0x06
    2150:	37 81       	ldd	r19, Z+7	; 0x07
    2152:	24 0f       	add	r18, r20
    2154:	35 1f       	adc	r19, r21
    2156:	26 83       	std	Z+6, r18	; 0x06
    2158:	37 83       	std	Z+7, r19	; 0x07
    215a:	82 81       	ldd	r24, Z+2	; 0x02
    215c:	93 81       	ldd	r25, Z+3	; 0x03
    215e:	28 17       	cp	r18, r24
    2160:	39 07       	cpc	r19, r25
    2162:	20 f0       	brcs	.+8      	; 0x216c <prvCopyDataFromQueue+0x28>
    2164:	80 81       	ld	r24, Z
    2166:	91 81       	ldd	r25, Z+1	; 0x01
    2168:	86 83       	std	Z+6, r24	; 0x06
    216a:	97 83       	std	Z+7, r25	; 0x07
    216c:	cb 01       	movw	r24, r22
    216e:	66 81       	ldd	r22, Z+6	; 0x06
    2170:	77 81       	ldd	r23, Z+7	; 0x07
    2172:	0c 94 8a 1d 	jmp	0x3b14	; 0x3b14 <memcpy>
    2176:	08 95       	ret

00002178 <prvUnlockQueue>:
    2178:	0f 93       	push	r16
    217a:	1f 93       	push	r17
    217c:	cf 93       	push	r28
    217e:	df 93       	push	r29
    2180:	ec 01       	movw	r28, r24
    2182:	0f b6       	in	r0, 0x3f	; 63
    2184:	f8 94       	cli
    2186:	0f 92       	push	r0
    2188:	8e 8d       	ldd	r24, Y+30	; 0x1e
    218a:	18 16       	cp	r1, r24
    218c:	ac f4       	brge	.+42     	; 0x21b8 <prvUnlockQueue+0x40>
    218e:	89 89       	ldd	r24, Y+17	; 0x11
    2190:	81 11       	cpse	r24, r1
    2192:	05 c0       	rjmp	.+10     	; 0x219e <prvUnlockQueue+0x26>
    2194:	11 c0       	rjmp	.+34     	; 0x21b8 <prvUnlockQueue+0x40>
    2196:	89 89       	ldd	r24, Y+17	; 0x11
    2198:	81 11       	cpse	r24, r1
    219a:	04 c0       	rjmp	.+8      	; 0x21a4 <prvUnlockQueue+0x2c>
    219c:	0d c0       	rjmp	.+26     	; 0x21b8 <prvUnlockQueue+0x40>
    219e:	8e 01       	movw	r16, r28
    21a0:	0f 5e       	subi	r16, 0xEF	; 239
    21a2:	1f 4f       	sbci	r17, 0xFF	; 255
    21a4:	c8 01       	movw	r24, r16
    21a6:	93 d5       	rcall	.+2854   	; 0x2cce <xTaskRemoveFromEventList>
    21a8:	81 11       	cpse	r24, r1
    21aa:	13 d6       	rcall	.+3110   	; 0x2dd2 <vTaskMissedYield>
    21ac:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21ae:	81 50       	subi	r24, 0x01	; 1
    21b0:	8e 8f       	std	Y+30, r24	; 0x1e
    21b2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    21b4:	18 16       	cp	r1, r24
    21b6:	7c f3       	brlt	.-34     	; 0x2196 <prvUnlockQueue+0x1e>
    21b8:	8f ef       	ldi	r24, 0xFF	; 255
    21ba:	8e 8f       	std	Y+30, r24	; 0x1e
    21bc:	0f 90       	pop	r0
    21be:	0f be       	out	0x3f, r0	; 63
    21c0:	0f b6       	in	r0, 0x3f	; 63
    21c2:	f8 94       	cli
    21c4:	0f 92       	push	r0
    21c6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    21c8:	18 16       	cp	r1, r24
    21ca:	ac f4       	brge	.+42     	; 0x21f6 <prvUnlockQueue+0x7e>
    21cc:	88 85       	ldd	r24, Y+8	; 0x08
    21ce:	81 11       	cpse	r24, r1
    21d0:	05 c0       	rjmp	.+10     	; 0x21dc <prvUnlockQueue+0x64>
    21d2:	11 c0       	rjmp	.+34     	; 0x21f6 <prvUnlockQueue+0x7e>
    21d4:	88 85       	ldd	r24, Y+8	; 0x08
    21d6:	81 11       	cpse	r24, r1
    21d8:	04 c0       	rjmp	.+8      	; 0x21e2 <prvUnlockQueue+0x6a>
    21da:	0d c0       	rjmp	.+26     	; 0x21f6 <prvUnlockQueue+0x7e>
    21dc:	8e 01       	movw	r16, r28
    21de:	08 5f       	subi	r16, 0xF8	; 248
    21e0:	1f 4f       	sbci	r17, 0xFF	; 255
    21e2:	c8 01       	movw	r24, r16
    21e4:	74 d5       	rcall	.+2792   	; 0x2cce <xTaskRemoveFromEventList>
    21e6:	81 11       	cpse	r24, r1
    21e8:	f4 d5       	rcall	.+3048   	; 0x2dd2 <vTaskMissedYield>
    21ea:	8d 8d       	ldd	r24, Y+29	; 0x1d
    21ec:	81 50       	subi	r24, 0x01	; 1
    21ee:	8d 8f       	std	Y+29, r24	; 0x1d
    21f0:	8d 8d       	ldd	r24, Y+29	; 0x1d
    21f2:	18 16       	cp	r1, r24
    21f4:	7c f3       	brlt	.-34     	; 0x21d4 <prvUnlockQueue+0x5c>
    21f6:	8f ef       	ldi	r24, 0xFF	; 255
    21f8:	8d 8f       	std	Y+29, r24	; 0x1d
    21fa:	0f 90       	pop	r0
    21fc:	0f be       	out	0x3f, r0	; 63
    21fe:	df 91       	pop	r29
    2200:	cf 91       	pop	r28
    2202:	1f 91       	pop	r17
    2204:	0f 91       	pop	r16
    2206:	08 95       	ret

00002208 <xQueueGenericReset>:
    2208:	cf 93       	push	r28
    220a:	df 93       	push	r29
    220c:	ec 01       	movw	r28, r24
    220e:	0f b6       	in	r0, 0x3f	; 63
    2210:	f8 94       	cli
    2212:	0f 92       	push	r0
    2214:	48 81       	ld	r20, Y
    2216:	59 81       	ldd	r21, Y+1	; 0x01
    2218:	2c 8d       	ldd	r18, Y+28	; 0x1c
    221a:	30 e0       	ldi	r19, 0x00	; 0
    221c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    221e:	72 9f       	mul	r23, r18
    2220:	c0 01       	movw	r24, r0
    2222:	73 9f       	mul	r23, r19
    2224:	90 0d       	add	r25, r0
    2226:	11 24       	eor	r1, r1
    2228:	fa 01       	movw	r30, r20
    222a:	e8 0f       	add	r30, r24
    222c:	f9 1f       	adc	r31, r25
    222e:	ea 83       	std	Y+2, r30	; 0x02
    2230:	fb 83       	std	Y+3, r31	; 0x03
    2232:	1a 8e       	std	Y+26, r1	; 0x1a
    2234:	4c 83       	std	Y+4, r20	; 0x04
    2236:	5d 83       	std	Y+5, r21	; 0x05
    2238:	82 1b       	sub	r24, r18
    223a:	93 0b       	sbc	r25, r19
    223c:	84 0f       	add	r24, r20
    223e:	95 1f       	adc	r25, r21
    2240:	8e 83       	std	Y+6, r24	; 0x06
    2242:	9f 83       	std	Y+7, r25	; 0x07
    2244:	8f ef       	ldi	r24, 0xFF	; 255
    2246:	8d 8f       	std	Y+29, r24	; 0x1d
    2248:	8e 8f       	std	Y+30, r24	; 0x1e
    224a:	61 11       	cpse	r22, r1
    224c:	0a c0       	rjmp	.+20     	; 0x2262 <xQueueGenericReset+0x5a>
    224e:	88 85       	ldd	r24, Y+8	; 0x08
    2250:	88 23       	and	r24, r24
    2252:	69 f0       	breq	.+26     	; 0x226e <xQueueGenericReset+0x66>
    2254:	ce 01       	movw	r24, r28
    2256:	08 96       	adiw	r24, 0x08	; 8
    2258:	3a d5       	rcall	.+2676   	; 0x2cce <xTaskRemoveFromEventList>
    225a:	81 30       	cpi	r24, 0x01	; 1
    225c:	41 f4       	brne	.+16     	; 0x226e <xQueueGenericReset+0x66>
    225e:	5b de       	rcall	.-842    	; 0x1f16 <vPortYield>
    2260:	06 c0       	rjmp	.+12     	; 0x226e <xQueueGenericReset+0x66>
    2262:	ce 01       	movw	r24, r28
    2264:	08 96       	adiw	r24, 0x08	; 8
    2266:	11 dd       	rcall	.-1502   	; 0x1c8a <vListInitialise>
    2268:	ce 01       	movw	r24, r28
    226a:	41 96       	adiw	r24, 0x11	; 17
    226c:	0e dd       	rcall	.-1508   	; 0x1c8a <vListInitialise>
    226e:	0f 90       	pop	r0
    2270:	0f be       	out	0x3f, r0	; 63
    2272:	81 e0       	ldi	r24, 0x01	; 1
    2274:	df 91       	pop	r29
    2276:	cf 91       	pop	r28
    2278:	08 95       	ret

0000227a <xQueueGenericCreate>:
    227a:	0f 93       	push	r16
    227c:	1f 93       	push	r17
    227e:	cf 93       	push	r28
    2280:	df 93       	push	r29
    2282:	08 2f       	mov	r16, r24
    2284:	16 2f       	mov	r17, r22
    2286:	66 23       	and	r22, r22
    2288:	a9 f0       	breq	.+42     	; 0x22b4 <xQueueGenericCreate+0x3a>
    228a:	86 9f       	mul	r24, r22
    228c:	c0 01       	movw	r24, r0
    228e:	11 24       	eor	r1, r1
    2290:	80 96       	adiw	r24, 0x20	; 32
    2292:	f3 de       	rcall	.-538    	; 0x207a <pvPortMalloc>
    2294:	ec 01       	movw	r28, r24
    2296:	00 97       	sbiw	r24, 0x00	; 0
    2298:	21 f4       	brne	.+8      	; 0x22a2 <xQueueGenericCreate+0x28>
    229a:	12 c0       	rjmp	.+36     	; 0x22c0 <xQueueGenericCreate+0x46>
    229c:	c8 83       	st	Y, r28
    229e:	d9 83       	std	Y+1, r29	; 0x01
    22a0:	03 c0       	rjmp	.+6      	; 0x22a8 <xQueueGenericCreate+0x2e>
    22a2:	4f 96       	adiw	r24, 0x1f	; 31
    22a4:	88 83       	st	Y, r24
    22a6:	99 83       	std	Y+1, r25	; 0x01
    22a8:	0b 8f       	std	Y+27, r16	; 0x1b
    22aa:	1c 8f       	std	Y+28, r17	; 0x1c
    22ac:	61 e0       	ldi	r22, 0x01	; 1
    22ae:	ce 01       	movw	r24, r28
    22b0:	ab df       	rcall	.-170    	; 0x2208 <xQueueGenericReset>
    22b2:	06 c0       	rjmp	.+12     	; 0x22c0 <xQueueGenericCreate+0x46>
    22b4:	8f e1       	ldi	r24, 0x1F	; 31
    22b6:	90 e0       	ldi	r25, 0x00	; 0
    22b8:	e0 de       	rcall	.-576    	; 0x207a <pvPortMalloc>
    22ba:	ec 01       	movw	r28, r24
    22bc:	89 2b       	or	r24, r25
    22be:	71 f7       	brne	.-36     	; 0x229c <xQueueGenericCreate+0x22>
    22c0:	ce 01       	movw	r24, r28
    22c2:	df 91       	pop	r29
    22c4:	cf 91       	pop	r28
    22c6:	1f 91       	pop	r17
    22c8:	0f 91       	pop	r16
    22ca:	08 95       	ret

000022cc <xQueueGenericSend>:
    22cc:	af 92       	push	r10
    22ce:	bf 92       	push	r11
    22d0:	cf 92       	push	r12
    22d2:	df 92       	push	r13
    22d4:	ef 92       	push	r14
    22d6:	ff 92       	push	r15
    22d8:	0f 93       	push	r16
    22da:	1f 93       	push	r17
    22dc:	cf 93       	push	r28
    22de:	df 93       	push	r29
    22e0:	cd b7       	in	r28, 0x3d	; 61
    22e2:	de b7       	in	r29, 0x3e	; 62
    22e4:	25 97       	sbiw	r28, 0x05	; 5
    22e6:	cd bf       	out	0x3d, r28	; 61
    22e8:	de bf       	out	0x3e, r29	; 62
    22ea:	8c 01       	movw	r16, r24
    22ec:	6b 01       	movw	r12, r22
    22ee:	4c 83       	std	Y+4, r20	; 0x04
    22f0:	5d 83       	std	Y+5, r21	; 0x05
    22f2:	a2 2e       	mov	r10, r18
    22f4:	b1 2c       	mov	r11, r1
    22f6:	7c 01       	movw	r14, r24
    22f8:	88 e0       	ldi	r24, 0x08	; 8
    22fa:	e8 0e       	add	r14, r24
    22fc:	f1 1c       	adc	r15, r1
    22fe:	0f b6       	in	r0, 0x3f	; 63
    2300:	f8 94       	cli
    2302:	0f 92       	push	r0
    2304:	f8 01       	movw	r30, r16
    2306:	92 8d       	ldd	r25, Z+26	; 0x1a
    2308:	83 8d       	ldd	r24, Z+27	; 0x1b
    230a:	98 17       	cp	r25, r24
    230c:	18 f0       	brcs	.+6      	; 0x2314 <xQueueGenericSend+0x48>
    230e:	f2 e0       	ldi	r31, 0x02	; 2
    2310:	af 12       	cpse	r10, r31
    2312:	15 c0       	rjmp	.+42     	; 0x233e <xQueueGenericSend+0x72>
    2314:	4a 2d       	mov	r20, r10
    2316:	b6 01       	movw	r22, r12
    2318:	c8 01       	movw	r24, r16
    231a:	c9 de       	rcall	.-622    	; 0x20ae <prvCopyDataToQueue>
    231c:	f8 01       	movw	r30, r16
    231e:	91 89       	ldd	r25, Z+17	; 0x11
    2320:	99 23       	and	r25, r25
    2322:	39 f0       	breq	.+14     	; 0x2332 <xQueueGenericSend+0x66>
    2324:	c8 01       	movw	r24, r16
    2326:	41 96       	adiw	r24, 0x11	; 17
    2328:	d2 d4       	rcall	.+2468   	; 0x2cce <xTaskRemoveFromEventList>
    232a:	81 30       	cpi	r24, 0x01	; 1
    232c:	21 f4       	brne	.+8      	; 0x2336 <xQueueGenericSend+0x6a>
    232e:	f3 dd       	rcall	.-1050   	; 0x1f16 <vPortYield>
    2330:	02 c0       	rjmp	.+4      	; 0x2336 <xQueueGenericSend+0x6a>
    2332:	81 11       	cpse	r24, r1
    2334:	f0 dd       	rcall	.-1056   	; 0x1f16 <vPortYield>
    2336:	0f 90       	pop	r0
    2338:	0f be       	out	0x3f, r0	; 63
    233a:	81 e0       	ldi	r24, 0x01	; 1
    233c:	46 c0       	rjmp	.+140    	; 0x23ca <xQueueGenericSend+0xfe>
    233e:	8c 81       	ldd	r24, Y+4	; 0x04
    2340:	9d 81       	ldd	r25, Y+5	; 0x05
    2342:	89 2b       	or	r24, r25
    2344:	21 f4       	brne	.+8      	; 0x234e <xQueueGenericSend+0x82>
    2346:	0f 90       	pop	r0
    2348:	0f be       	out	0x3f, r0	; 63
    234a:	80 e0       	ldi	r24, 0x00	; 0
    234c:	3e c0       	rjmp	.+124    	; 0x23ca <xQueueGenericSend+0xfe>
    234e:	b1 10       	cpse	r11, r1
    2350:	05 c0       	rjmp	.+10     	; 0x235c <xQueueGenericSend+0x90>
    2352:	ce 01       	movw	r24, r28
    2354:	01 96       	adiw	r24, 0x01	; 1
    2356:	01 d5       	rcall	.+2562   	; 0x2d5a <vTaskSetTimeOutState>
    2358:	bb 24       	eor	r11, r11
    235a:	b3 94       	inc	r11
    235c:	0f 90       	pop	r0
    235e:	0f be       	out	0x3f, r0	; 63
    2360:	9a d2       	rcall	.+1332   	; 0x2896 <vTaskSuspendAll>
    2362:	0f b6       	in	r0, 0x3f	; 63
    2364:	f8 94       	cli
    2366:	0f 92       	push	r0
    2368:	f8 01       	movw	r30, r16
    236a:	85 8d       	ldd	r24, Z+29	; 0x1d
    236c:	8f 3f       	cpi	r24, 0xFF	; 255
    236e:	09 f4       	brne	.+2      	; 0x2372 <xQueueGenericSend+0xa6>
    2370:	15 8e       	std	Z+29, r1	; 0x1d
    2372:	f8 01       	movw	r30, r16
    2374:	86 8d       	ldd	r24, Z+30	; 0x1e
    2376:	8f 3f       	cpi	r24, 0xFF	; 255
    2378:	09 f4       	brne	.+2      	; 0x237c <xQueueGenericSend+0xb0>
    237a:	16 8e       	std	Z+30, r1	; 0x1e
    237c:	0f 90       	pop	r0
    237e:	0f be       	out	0x3f, r0	; 63
    2380:	be 01       	movw	r22, r28
    2382:	6c 5f       	subi	r22, 0xFC	; 252
    2384:	7f 4f       	sbci	r23, 0xFF	; 255
    2386:	ce 01       	movw	r24, r28
    2388:	01 96       	adiw	r24, 0x01	; 1
    238a:	f2 d4       	rcall	.+2532   	; 0x2d70 <xTaskCheckForTimeOut>
    238c:	81 11       	cpse	r24, r1
    238e:	19 c0       	rjmp	.+50     	; 0x23c2 <xQueueGenericSend+0xf6>
    2390:	0f b6       	in	r0, 0x3f	; 63
    2392:	f8 94       	cli
    2394:	0f 92       	push	r0
    2396:	f8 01       	movw	r30, r16
    2398:	92 8d       	ldd	r25, Z+26	; 0x1a
    239a:	0f 90       	pop	r0
    239c:	0f be       	out	0x3f, r0	; 63
    239e:	83 8d       	ldd	r24, Z+27	; 0x1b
    23a0:	98 13       	cpse	r25, r24
    23a2:	0b c0       	rjmp	.+22     	; 0x23ba <xQueueGenericSend+0xee>
    23a4:	6c 81       	ldd	r22, Y+4	; 0x04
    23a6:	7d 81       	ldd	r23, Y+5	; 0x05
    23a8:	c7 01       	movw	r24, r14
    23aa:	5d d4       	rcall	.+2234   	; 0x2c66 <vTaskPlaceOnEventList>
    23ac:	c8 01       	movw	r24, r16
    23ae:	e4 de       	rcall	.-568    	; 0x2178 <prvUnlockQueue>
    23b0:	55 d3       	rcall	.+1706   	; 0x2a5c <xTaskResumeAll>
    23b2:	81 11       	cpse	r24, r1
    23b4:	a4 cf       	rjmp	.-184    	; 0x22fe <xQueueGenericSend+0x32>
    23b6:	af dd       	rcall	.-1186   	; 0x1f16 <vPortYield>
    23b8:	a2 cf       	rjmp	.-188    	; 0x22fe <xQueueGenericSend+0x32>
    23ba:	c8 01       	movw	r24, r16
    23bc:	dd de       	rcall	.-582    	; 0x2178 <prvUnlockQueue>
    23be:	4e d3       	rcall	.+1692   	; 0x2a5c <xTaskResumeAll>
    23c0:	9e cf       	rjmp	.-196    	; 0x22fe <xQueueGenericSend+0x32>
    23c2:	c8 01       	movw	r24, r16
    23c4:	d9 de       	rcall	.-590    	; 0x2178 <prvUnlockQueue>
    23c6:	4a d3       	rcall	.+1684   	; 0x2a5c <xTaskResumeAll>
    23c8:	80 e0       	ldi	r24, 0x00	; 0
    23ca:	25 96       	adiw	r28, 0x05	; 5
    23cc:	cd bf       	out	0x3d, r28	; 61
    23ce:	de bf       	out	0x3e, r29	; 62
    23d0:	df 91       	pop	r29
    23d2:	cf 91       	pop	r28
    23d4:	1f 91       	pop	r17
    23d6:	0f 91       	pop	r16
    23d8:	ff 90       	pop	r15
    23da:	ef 90       	pop	r14
    23dc:	df 90       	pop	r13
    23de:	cf 90       	pop	r12
    23e0:	bf 90       	pop	r11
    23e2:	af 90       	pop	r10
    23e4:	08 95       	ret

000023e6 <xQueueGenericSendFromISR>:
    23e6:	0f 93       	push	r16
    23e8:	1f 93       	push	r17
    23ea:	cf 93       	push	r28
    23ec:	df 93       	push	r29
    23ee:	fa 01       	movw	r30, r20
    23f0:	dc 01       	movw	r26, r24
    23f2:	5a 96       	adiw	r26, 0x1a	; 26
    23f4:	5c 91       	ld	r21, X
    23f6:	5a 97       	sbiw	r26, 0x1a	; 26
    23f8:	5b 96       	adiw	r26, 0x1b	; 27
    23fa:	3c 91       	ld	r19, X
    23fc:	53 17       	cp	r21, r19
    23fe:	10 f0       	brcs	.+4      	; 0x2404 <xQueueGenericSendFromISR+0x1e>
    2400:	22 30       	cpi	r18, 0x02	; 2
    2402:	d9 f4       	brne	.+54     	; 0x243a <xQueueGenericSendFromISR+0x54>
    2404:	42 2f       	mov	r20, r18
    2406:	8f 01       	movw	r16, r30
    2408:	ec 01       	movw	r28, r24
    240a:	51 de       	rcall	.-862    	; 0x20ae <prvCopyDataToQueue>
    240c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    240e:	8f 3f       	cpi	r24, 0xFF	; 255
    2410:	79 f4       	brne	.+30     	; 0x2430 <xQueueGenericSendFromISR+0x4a>
    2412:	89 89       	ldd	r24, Y+17	; 0x11
    2414:	88 23       	and	r24, r24
    2416:	99 f0       	breq	.+38     	; 0x243e <xQueueGenericSendFromISR+0x58>
    2418:	ce 01       	movw	r24, r28
    241a:	41 96       	adiw	r24, 0x11	; 17
    241c:	58 d4       	rcall	.+2224   	; 0x2cce <xTaskRemoveFromEventList>
    241e:	88 23       	and	r24, r24
    2420:	81 f0       	breq	.+32     	; 0x2442 <xQueueGenericSendFromISR+0x5c>
    2422:	01 15       	cp	r16, r1
    2424:	11 05       	cpc	r17, r1
    2426:	79 f0       	breq	.+30     	; 0x2446 <xQueueGenericSendFromISR+0x60>
    2428:	81 e0       	ldi	r24, 0x01	; 1
    242a:	f8 01       	movw	r30, r16
    242c:	80 83       	st	Z, r24
    242e:	0c c0       	rjmp	.+24     	; 0x2448 <xQueueGenericSendFromISR+0x62>
    2430:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2432:	8f 5f       	subi	r24, 0xFF	; 255
    2434:	8e 8f       	std	Y+30, r24	; 0x1e
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	07 c0       	rjmp	.+14     	; 0x2448 <xQueueGenericSendFromISR+0x62>
    243a:	80 e0       	ldi	r24, 0x00	; 0
    243c:	05 c0       	rjmp	.+10     	; 0x2448 <xQueueGenericSendFromISR+0x62>
    243e:	81 e0       	ldi	r24, 0x01	; 1
    2440:	03 c0       	rjmp	.+6      	; 0x2448 <xQueueGenericSendFromISR+0x62>
    2442:	81 e0       	ldi	r24, 0x01	; 1
    2444:	01 c0       	rjmp	.+2      	; 0x2448 <xQueueGenericSendFromISR+0x62>
    2446:	81 e0       	ldi	r24, 0x01	; 1
    2448:	df 91       	pop	r29
    244a:	cf 91       	pop	r28
    244c:	1f 91       	pop	r17
    244e:	0f 91       	pop	r16
    2450:	08 95       	ret

00002452 <xQueueGenericReceive>:
    2452:	af 92       	push	r10
    2454:	bf 92       	push	r11
    2456:	cf 92       	push	r12
    2458:	df 92       	push	r13
    245a:	ef 92       	push	r14
    245c:	ff 92       	push	r15
    245e:	0f 93       	push	r16
    2460:	1f 93       	push	r17
    2462:	cf 93       	push	r28
    2464:	df 93       	push	r29
    2466:	cd b7       	in	r28, 0x3d	; 61
    2468:	de b7       	in	r29, 0x3e	; 62
    246a:	25 97       	sbiw	r28, 0x05	; 5
    246c:	cd bf       	out	0x3d, r28	; 61
    246e:	de bf       	out	0x3e, r29	; 62
    2470:	8c 01       	movw	r16, r24
    2472:	6b 01       	movw	r12, r22
    2474:	4c 83       	std	Y+4, r20	; 0x04
    2476:	5d 83       	std	Y+5, r21	; 0x05
    2478:	a2 2e       	mov	r10, r18
    247a:	b1 2c       	mov	r11, r1
    247c:	7c 01       	movw	r14, r24
    247e:	81 e1       	ldi	r24, 0x11	; 17
    2480:	e8 0e       	add	r14, r24
    2482:	f1 1c       	adc	r15, r1
    2484:	0f b6       	in	r0, 0x3f	; 63
    2486:	f8 94       	cli
    2488:	0f 92       	push	r0
    248a:	f8 01       	movw	r30, r16
    248c:	82 8d       	ldd	r24, Z+26	; 0x1a
    248e:	88 23       	and	r24, r24
    2490:	21 f1       	breq	.+72     	; 0x24da <xQueueGenericReceive+0x88>
    2492:	e6 80       	ldd	r14, Z+6	; 0x06
    2494:	f7 80       	ldd	r15, Z+7	; 0x07
    2496:	b6 01       	movw	r22, r12
    2498:	c8 01       	movw	r24, r16
    249a:	54 de       	rcall	.-856    	; 0x2144 <prvCopyDataFromQueue>
    249c:	a1 10       	cpse	r10, r1
    249e:	0e c0       	rjmp	.+28     	; 0x24bc <xQueueGenericReceive+0x6a>
    24a0:	f8 01       	movw	r30, r16
    24a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    24a4:	81 50       	subi	r24, 0x01	; 1
    24a6:	82 8f       	std	Z+26, r24	; 0x1a
    24a8:	80 85       	ldd	r24, Z+8	; 0x08
    24aa:	88 23       	and	r24, r24
    24ac:	91 f0       	breq	.+36     	; 0x24d2 <xQueueGenericReceive+0x80>
    24ae:	c8 01       	movw	r24, r16
    24b0:	08 96       	adiw	r24, 0x08	; 8
    24b2:	0d d4       	rcall	.+2074   	; 0x2cce <xTaskRemoveFromEventList>
    24b4:	81 30       	cpi	r24, 0x01	; 1
    24b6:	69 f4       	brne	.+26     	; 0x24d2 <xQueueGenericReceive+0x80>
    24b8:	2e dd       	rcall	.-1444   	; 0x1f16 <vPortYield>
    24ba:	0b c0       	rjmp	.+22     	; 0x24d2 <xQueueGenericReceive+0x80>
    24bc:	f8 01       	movw	r30, r16
    24be:	e6 82       	std	Z+6, r14	; 0x06
    24c0:	f7 82       	std	Z+7, r15	; 0x07
    24c2:	81 89       	ldd	r24, Z+17	; 0x11
    24c4:	88 23       	and	r24, r24
    24c6:	29 f0       	breq	.+10     	; 0x24d2 <xQueueGenericReceive+0x80>
    24c8:	c8 01       	movw	r24, r16
    24ca:	41 96       	adiw	r24, 0x11	; 17
    24cc:	00 d4       	rcall	.+2048   	; 0x2cce <xTaskRemoveFromEventList>
    24ce:	81 11       	cpse	r24, r1
    24d0:	22 dd       	rcall	.-1468   	; 0x1f16 <vPortYield>
    24d2:	0f 90       	pop	r0
    24d4:	0f be       	out	0x3f, r0	; 63
    24d6:	81 e0       	ldi	r24, 0x01	; 1
    24d8:	45 c0       	rjmp	.+138    	; 0x2564 <xQueueGenericReceive+0x112>
    24da:	8c 81       	ldd	r24, Y+4	; 0x04
    24dc:	9d 81       	ldd	r25, Y+5	; 0x05
    24de:	89 2b       	or	r24, r25
    24e0:	21 f4       	brne	.+8      	; 0x24ea <xQueueGenericReceive+0x98>
    24e2:	0f 90       	pop	r0
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	80 e0       	ldi	r24, 0x00	; 0
    24e8:	3d c0       	rjmp	.+122    	; 0x2564 <xQueueGenericReceive+0x112>
    24ea:	b1 10       	cpse	r11, r1
    24ec:	05 c0       	rjmp	.+10     	; 0x24f8 <xQueueGenericReceive+0xa6>
    24ee:	ce 01       	movw	r24, r28
    24f0:	01 96       	adiw	r24, 0x01	; 1
    24f2:	33 d4       	rcall	.+2150   	; 0x2d5a <vTaskSetTimeOutState>
    24f4:	bb 24       	eor	r11, r11
    24f6:	b3 94       	inc	r11
    24f8:	0f 90       	pop	r0
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	cc d1       	rcall	.+920    	; 0x2896 <vTaskSuspendAll>
    24fe:	0f b6       	in	r0, 0x3f	; 63
    2500:	f8 94       	cli
    2502:	0f 92       	push	r0
    2504:	f8 01       	movw	r30, r16
    2506:	85 8d       	ldd	r24, Z+29	; 0x1d
    2508:	8f 3f       	cpi	r24, 0xFF	; 255
    250a:	09 f4       	brne	.+2      	; 0x250e <xQueueGenericReceive+0xbc>
    250c:	15 8e       	std	Z+29, r1	; 0x1d
    250e:	f8 01       	movw	r30, r16
    2510:	86 8d       	ldd	r24, Z+30	; 0x1e
    2512:	8f 3f       	cpi	r24, 0xFF	; 255
    2514:	09 f4       	brne	.+2      	; 0x2518 <xQueueGenericReceive+0xc6>
    2516:	16 8e       	std	Z+30, r1	; 0x1e
    2518:	0f 90       	pop	r0
    251a:	0f be       	out	0x3f, r0	; 63
    251c:	be 01       	movw	r22, r28
    251e:	6c 5f       	subi	r22, 0xFC	; 252
    2520:	7f 4f       	sbci	r23, 0xFF	; 255
    2522:	ce 01       	movw	r24, r28
    2524:	01 96       	adiw	r24, 0x01	; 1
    2526:	24 d4       	rcall	.+2120   	; 0x2d70 <xTaskCheckForTimeOut>
    2528:	81 11       	cpse	r24, r1
    252a:	18 c0       	rjmp	.+48     	; 0x255c <xQueueGenericReceive+0x10a>
    252c:	0f b6       	in	r0, 0x3f	; 63
    252e:	f8 94       	cli
    2530:	0f 92       	push	r0
    2532:	f8 01       	movw	r30, r16
    2534:	82 8d       	ldd	r24, Z+26	; 0x1a
    2536:	0f 90       	pop	r0
    2538:	0f be       	out	0x3f, r0	; 63
    253a:	81 11       	cpse	r24, r1
    253c:	0b c0       	rjmp	.+22     	; 0x2554 <xQueueGenericReceive+0x102>
    253e:	6c 81       	ldd	r22, Y+4	; 0x04
    2540:	7d 81       	ldd	r23, Y+5	; 0x05
    2542:	c7 01       	movw	r24, r14
    2544:	90 d3       	rcall	.+1824   	; 0x2c66 <vTaskPlaceOnEventList>
    2546:	c8 01       	movw	r24, r16
    2548:	17 de       	rcall	.-978    	; 0x2178 <prvUnlockQueue>
    254a:	88 d2       	rcall	.+1296   	; 0x2a5c <xTaskResumeAll>
    254c:	81 11       	cpse	r24, r1
    254e:	9a cf       	rjmp	.-204    	; 0x2484 <xQueueGenericReceive+0x32>
    2550:	e2 dc       	rcall	.-1596   	; 0x1f16 <vPortYield>
    2552:	98 cf       	rjmp	.-208    	; 0x2484 <xQueueGenericReceive+0x32>
    2554:	c8 01       	movw	r24, r16
    2556:	10 de       	rcall	.-992    	; 0x2178 <prvUnlockQueue>
    2558:	81 d2       	rcall	.+1282   	; 0x2a5c <xTaskResumeAll>
    255a:	94 cf       	rjmp	.-216    	; 0x2484 <xQueueGenericReceive+0x32>
    255c:	c8 01       	movw	r24, r16
    255e:	0c de       	rcall	.-1000   	; 0x2178 <prvUnlockQueue>
    2560:	7d d2       	rcall	.+1274   	; 0x2a5c <xTaskResumeAll>
    2562:	80 e0       	ldi	r24, 0x00	; 0
    2564:	25 96       	adiw	r28, 0x05	; 5
    2566:	cd bf       	out	0x3d, r28	; 61
    2568:	de bf       	out	0x3e, r29	; 62
    256a:	df 91       	pop	r29
    256c:	cf 91       	pop	r28
    256e:	1f 91       	pop	r17
    2570:	0f 91       	pop	r16
    2572:	ff 90       	pop	r15
    2574:	ef 90       	pop	r14
    2576:	df 90       	pop	r13
    2578:	cf 90       	pop	r12
    257a:	bf 90       	pop	r11
    257c:	af 90       	pop	r10
    257e:	08 95       	ret

00002580 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2580:	cf 93       	push	r28
    2582:	df 93       	push	r29
    2584:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2586:	0f b6       	in	r0, 0x3f	; 63
    2588:	f8 94       	cli
    258a:	0f 92       	push	r0
    258c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    258e:	8f 3f       	cpi	r24, 0xFF	; 255
    2590:	09 f4       	brne	.+2      	; 0x2594 <vQueueWaitForMessageRestricted+0x14>
    2592:	1d 8e       	std	Y+29, r1	; 0x1d
    2594:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2596:	8f 3f       	cpi	r24, 0xFF	; 255
    2598:	09 f4       	brne	.+2      	; 0x259c <vQueueWaitForMessageRestricted+0x1c>
    259a:	1e 8e       	std	Y+30, r1	; 0x1e
    259c:	0f 90       	pop	r0
    259e:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    25a0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    25a2:	81 11       	cpse	r24, r1
    25a4:	03 c0       	rjmp	.+6      	; 0x25ac <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    25a6:	ce 01       	movw	r24, r28
    25a8:	41 96       	adiw	r24, 0x11	; 17
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    25aa:	77 d3       	rcall	.+1774   	; 0x2c9a <vTaskPlaceOnEventListRestricted>
    25ac:	ce 01       	movw	r24, r28
	}
    25ae:	e4 dd       	rcall	.-1080   	; 0x2178 <prvUnlockQueue>
    25b0:	df 91       	pop	r29
    25b2:	cf 91       	pop	r28
    25b4:	08 95       	ret

000025b6 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    25b6:	cd e6       	ldi	r28, 0x6D	; 109
    25b8:	d2 e2       	ldi	r29, 0x22	; 34
    25ba:	88 81       	ld	r24, Y
    25bc:	82 30       	cpi	r24, 0x02	; 2
    25be:	f0 f3       	brcs	.-4      	; 0x25bc <prvIdleTask+0x6>
    25c0:	aa dc       	rcall	.-1708   	; 0x1f16 <vPortYield>
    25c2:	fb cf       	rjmp	.-10     	; 0x25ba <prvIdleTask+0x4>

000025c4 <prvAddCurrentTaskToDelayedList>:
    25c4:	cf 93       	push	r28
    25c6:	df 93       	push	r29
    25c8:	ec 01       	movw	r28, r24
    25ca:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    25ce:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    25d2:	82 83       	std	Z+2, r24	; 0x02
    25d4:	93 83       	std	Z+3, r25	; 0x03
    25d6:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xTickCount>
    25da:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <xTickCount+0x1>
    25de:	c8 17       	cp	r28, r24
    25e0:	d9 07       	cpc	r29, r25
    25e2:	60 f4       	brcc	.+24     	; 0x25fc <prvAddCurrentTaskToDelayedList+0x38>
    25e4:	60 91 9a 22 	lds	r22, 0x229A	; 0x80229a <pxCurrentTCB>
    25e8:	70 91 9b 22 	lds	r23, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    25ec:	80 91 57 22 	lds	r24, 0x2257	; 0x802257 <pxOverflowDelayedTaskList>
    25f0:	90 91 58 22 	lds	r25, 0x2258	; 0x802258 <pxOverflowDelayedTaskList+0x1>
    25f4:	6e 5f       	subi	r22, 0xFE	; 254
    25f6:	7f 4f       	sbci	r23, 0xFF	; 255
    25f8:	7b db       	rcall	.-2314   	; 0x1cf0 <vListInsert>
    25fa:	16 c0       	rjmp	.+44     	; 0x2628 <prvAddCurrentTaskToDelayedList+0x64>
    25fc:	60 91 9a 22 	lds	r22, 0x229A	; 0x80229a <pxCurrentTCB>
    2600:	70 91 9b 22 	lds	r23, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2604:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <pxDelayedTaskList>
    2608:	90 91 5a 22 	lds	r25, 0x225A	; 0x80225a <pxDelayedTaskList+0x1>
    260c:	6e 5f       	subi	r22, 0xFE	; 254
    260e:	7f 4f       	sbci	r23, 0xFF	; 255
    2610:	6f db       	rcall	.-2338   	; 0x1cf0 <vListInsert>
    2612:	80 91 43 22 	lds	r24, 0x2243	; 0x802243 <xNextTaskUnblockTime>
    2616:	90 91 44 22 	lds	r25, 0x2244	; 0x802244 <xNextTaskUnblockTime+0x1>
    261a:	c8 17       	cp	r28, r24
    261c:	d9 07       	cpc	r29, r25
    261e:	20 f4       	brcc	.+8      	; 0x2628 <prvAddCurrentTaskToDelayedList+0x64>
    2620:	c0 93 43 22 	sts	0x2243, r28	; 0x802243 <xNextTaskUnblockTime>
    2624:	d0 93 44 22 	sts	0x2244, r29	; 0x802244 <xNextTaskUnblockTime+0x1>
    2628:	df 91       	pop	r29
    262a:	cf 91       	pop	r28
    262c:	08 95       	ret

0000262e <xTaskGenericCreate>:
    262e:	4f 92       	push	r4
    2630:	5f 92       	push	r5
    2632:	6f 92       	push	r6
    2634:	7f 92       	push	r7
    2636:	8f 92       	push	r8
    2638:	9f 92       	push	r9
    263a:	af 92       	push	r10
    263c:	bf 92       	push	r11
    263e:	cf 92       	push	r12
    2640:	df 92       	push	r13
    2642:	ef 92       	push	r14
    2644:	ff 92       	push	r15
    2646:	0f 93       	push	r16
    2648:	1f 93       	push	r17
    264a:	cf 93       	push	r28
    264c:	df 93       	push	r29
    264e:	4c 01       	movw	r8, r24
    2650:	eb 01       	movw	r28, r22
    2652:	5a 01       	movw	r10, r20
    2654:	29 01       	movw	r4, r18
    2656:	c1 14       	cp	r12, r1
    2658:	d1 04       	cpc	r13, r1
    265a:	31 f4       	brne	.+12     	; 0x2668 <xTaskGenericCreate+0x3a>
    265c:	ca 01       	movw	r24, r20
    265e:	0d dd       	rcall	.-1510   	; 0x207a <pvPortMalloc>
    2660:	6c 01       	movw	r12, r24
    2662:	89 2b       	or	r24, r25
    2664:	09 f4       	brne	.+2      	; 0x2668 <xTaskGenericCreate+0x3a>
    2666:	d2 c0       	rjmp	.+420    	; 0x280c <xTaskGenericCreate+0x1de>
    2668:	86 e2       	ldi	r24, 0x26	; 38
    266a:	90 e0       	ldi	r25, 0x00	; 0
    266c:	06 dd       	rcall	.-1524   	; 0x207a <pvPortMalloc>
    266e:	3c 01       	movw	r6, r24
    2670:	00 97       	sbiw	r24, 0x00	; 0
    2672:	79 f0       	breq	.+30     	; 0x2692 <xTaskGenericCreate+0x64>
    2674:	fc 01       	movw	r30, r24
    2676:	c7 8a       	std	Z+23, r12	; 0x17
    2678:	d0 8e       	std	Z+24, r13	; 0x18
    267a:	f1 e0       	ldi	r31, 0x01	; 1
    267c:	af 1a       	sub	r10, r31
    267e:	b1 08       	sbc	r11, r1
    2680:	ca 0c       	add	r12, r10
    2682:	db 1c       	adc	r13, r11
    2684:	88 81       	ld	r24, Y
    2686:	f3 01       	movw	r30, r6
    2688:	81 8f       	std	Z+25, r24	; 0x19
    268a:	88 81       	ld	r24, Y
    268c:	81 11       	cpse	r24, r1
    268e:	04 c0       	rjmp	.+8      	; 0x2698 <xTaskGenericCreate+0x6a>
    2690:	13 c0       	rjmp	.+38     	; 0x26b8 <xTaskGenericCreate+0x8a>
    2692:	c6 01       	movw	r24, r12
    2694:	ff dc       	rcall	.-1538   	; 0x2094 <vPortFree>
    2696:	ba c0       	rjmp	.+372    	; 0x280c <xTaskGenericCreate+0x1de>
    2698:	d3 01       	movw	r26, r6
    269a:	5a 96       	adiw	r26, 0x1a	; 26
    269c:	fe 01       	movw	r30, r28
    269e:	31 96       	adiw	r30, 0x01	; 1
    26a0:	9e 01       	movw	r18, r28
    26a2:	28 5f       	subi	r18, 0xF8	; 248
    26a4:	3f 4f       	sbci	r19, 0xFF	; 255
    26a6:	ef 01       	movw	r28, r30
    26a8:	81 91       	ld	r24, Z+
    26aa:	8d 93       	st	X+, r24
    26ac:	88 81       	ld	r24, Y
    26ae:	88 23       	and	r24, r24
    26b0:	19 f0       	breq	.+6      	; 0x26b8 <xTaskGenericCreate+0x8a>
    26b2:	2e 17       	cp	r18, r30
    26b4:	3f 07       	cpc	r19, r31
    26b6:	b9 f7       	brne	.-18     	; 0x26a6 <xTaskGenericCreate+0x78>
    26b8:	f3 01       	movw	r30, r6
    26ba:	10 a2       	std	Z+32, r1	; 0x20
    26bc:	10 2f       	mov	r17, r16
    26be:	05 30       	cpi	r16, 0x05	; 5
    26c0:	08 f0       	brcs	.+2      	; 0x26c4 <xTaskGenericCreate+0x96>
    26c2:	14 e0       	ldi	r17, 0x04	; 4
    26c4:	f3 01       	movw	r30, r6
    26c6:	16 8b       	std	Z+22, r17	; 0x16
    26c8:	e3 01       	movw	r28, r6
    26ca:	22 96       	adiw	r28, 0x02	; 2
    26cc:	ce 01       	movw	r24, r28
    26ce:	eb da       	rcall	.-2602   	; 0x1ca6 <vListInitialiseItem>
    26d0:	c3 01       	movw	r24, r6
    26d2:	0c 96       	adiw	r24, 0x0c	; 12
    26d4:	e8 da       	rcall	.-2608   	; 0x1ca6 <vListInitialiseItem>
    26d6:	f3 01       	movw	r30, r6
    26d8:	60 86       	std	Z+8, r6	; 0x08
    26da:	71 86       	std	Z+9, r7	; 0x09
    26dc:	85 e0       	ldi	r24, 0x05	; 5
    26de:	90 e0       	ldi	r25, 0x00	; 0
    26e0:	81 1b       	sub	r24, r17
    26e2:	91 09       	sbc	r25, r1
    26e4:	84 87       	std	Z+12, r24	; 0x0c
    26e6:	95 87       	std	Z+13, r25	; 0x0d
    26e8:	62 8a       	std	Z+18, r6	; 0x12
    26ea:	73 8a       	std	Z+19, r7	; 0x13
    26ec:	11 a2       	std	Z+33, r1	; 0x21
    26ee:	12 a2       	std	Z+34, r1	; 0x22
    26f0:	13 a2       	std	Z+35, r1	; 0x23
    26f2:	14 a2       	std	Z+36, r1	; 0x24
    26f4:	15 a2       	std	Z+37, r1	; 0x25
    26f6:	a2 01       	movw	r20, r4
    26f8:	b4 01       	movw	r22, r8
    26fa:	c6 01       	movw	r24, r12
    26fc:	50 db       	rcall	.-2400   	; 0x1d9e <pxPortInitialiseStack>
    26fe:	f3 01       	movw	r30, r6
    2700:	80 83       	st	Z, r24
    2702:	91 83       	std	Z+1, r25	; 0x01
    2704:	e1 14       	cp	r14, r1
    2706:	f1 04       	cpc	r15, r1
    2708:	19 f0       	breq	.+6      	; 0x2710 <xTaskGenericCreate+0xe2>
    270a:	f7 01       	movw	r30, r14
    270c:	60 82       	st	Z, r6
    270e:	71 82       	std	Z+1, r7	; 0x01
    2710:	0f b6       	in	r0, 0x3f	; 63
    2712:	f8 94       	cli
    2714:	0f 92       	push	r0
    2716:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <uxCurrentNumberOfTasks>
    271a:	8f 5f       	subi	r24, 0xFF	; 255
    271c:	80 93 4d 22 	sts	0x224D, r24	; 0x80224d <uxCurrentNumberOfTasks>
    2720:	80 91 9a 22 	lds	r24, 0x229A	; 0x80229a <pxCurrentTCB>
    2724:	90 91 9b 22 	lds	r25, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2728:	89 2b       	or	r24, r25
    272a:	91 f5       	brne	.+100    	; 0x2790 <xTaskGenericCreate+0x162>
    272c:	60 92 9a 22 	sts	0x229A, r6	; 0x80229a <pxCurrentTCB>
    2730:	70 92 9b 22 	sts	0x229B, r7	; 0x80229b <pxCurrentTCB+0x1>
    2734:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <uxCurrentNumberOfTasks>
    2738:	81 30       	cpi	r24, 0x01	; 1
    273a:	c9 f5       	brne	.+114    	; 0x27ae <xTaskGenericCreate+0x180>
    273c:	0f 2e       	mov	r0, r31
    273e:	fd e6       	ldi	r31, 0x6D	; 109
    2740:	ef 2e       	mov	r14, r31
    2742:	f2 e2       	ldi	r31, 0x22	; 34
    2744:	ff 2e       	mov	r15, r31
    2746:	f0 2d       	mov	r31, r0
    2748:	0f 2e       	mov	r0, r31
    274a:	fa e9       	ldi	r31, 0x9A	; 154
    274c:	cf 2e       	mov	r12, r31
    274e:	f2 e2       	ldi	r31, 0x22	; 34
    2750:	df 2e       	mov	r13, r31
    2752:	f0 2d       	mov	r31, r0
    2754:	c7 01       	movw	r24, r14
    2756:	99 da       	rcall	.-2766   	; 0x1c8a <vListInitialise>
    2758:	f9 e0       	ldi	r31, 0x09	; 9
    275a:	ef 0e       	add	r14, r31
    275c:	f1 1c       	adc	r15, r1
    275e:	ec 14       	cp	r14, r12
    2760:	fd 04       	cpc	r15, r13
    2762:	c1 f7       	brne	.-16     	; 0x2754 <xTaskGenericCreate+0x126>
    2764:	84 e6       	ldi	r24, 0x64	; 100
    2766:	92 e2       	ldi	r25, 0x22	; 34
    2768:	90 da       	rcall	.-2784   	; 0x1c8a <vListInitialise>
    276a:	8b e5       	ldi	r24, 0x5B	; 91
    276c:	92 e2       	ldi	r25, 0x22	; 34
    276e:	8d da       	rcall	.-2790   	; 0x1c8a <vListInitialise>
    2770:	8e e4       	ldi	r24, 0x4E	; 78
    2772:	92 e2       	ldi	r25, 0x22	; 34
    2774:	8a da       	rcall	.-2796   	; 0x1c8a <vListInitialise>
    2776:	84 e6       	ldi	r24, 0x64	; 100
    2778:	92 e2       	ldi	r25, 0x22	; 34
    277a:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <pxDelayedTaskList>
    277e:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <pxDelayedTaskList+0x1>
    2782:	8b e5       	ldi	r24, 0x5B	; 91
    2784:	92 e2       	ldi	r25, 0x22	; 34
    2786:	80 93 57 22 	sts	0x2257, r24	; 0x802257 <pxOverflowDelayedTaskList>
    278a:	90 93 58 22 	sts	0x2258, r25	; 0x802258 <pxOverflowDelayedTaskList+0x1>
    278e:	0f c0       	rjmp	.+30     	; 0x27ae <xTaskGenericCreate+0x180>
    2790:	80 91 49 22 	lds	r24, 0x2249	; 0x802249 <xSchedulerRunning>
    2794:	81 11       	cpse	r24, r1
    2796:	0b c0       	rjmp	.+22     	; 0x27ae <xTaskGenericCreate+0x180>
    2798:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    279c:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    27a0:	86 89       	ldd	r24, Z+22	; 0x16
    27a2:	08 17       	cp	r16, r24
    27a4:	20 f0       	brcs	.+8      	; 0x27ae <xTaskGenericCreate+0x180>
    27a6:	60 92 9a 22 	sts	0x229A, r6	; 0x80229a <pxCurrentTCB>
    27aa:	70 92 9b 22 	sts	0x229B, r7	; 0x80229b <pxCurrentTCB+0x1>
    27ae:	80 91 45 22 	lds	r24, 0x2245	; 0x802245 <uxTaskNumber>
    27b2:	8f 5f       	subi	r24, 0xFF	; 255
    27b4:	80 93 45 22 	sts	0x2245, r24	; 0x802245 <uxTaskNumber>
    27b8:	f3 01       	movw	r30, r6
    27ba:	86 89       	ldd	r24, Z+22	; 0x16
    27bc:	90 91 4a 22 	lds	r25, 0x224A	; 0x80224a <uxTopReadyPriority>
    27c0:	98 17       	cp	r25, r24
    27c2:	10 f4       	brcc	.+4      	; 0x27c8 <xTaskGenericCreate+0x19a>
    27c4:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxTopReadyPriority>
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	9c 01       	movw	r18, r24
    27cc:	22 0f       	add	r18, r18
    27ce:	33 1f       	adc	r19, r19
    27d0:	22 0f       	add	r18, r18
    27d2:	33 1f       	adc	r19, r19
    27d4:	22 0f       	add	r18, r18
    27d6:	33 1f       	adc	r19, r19
    27d8:	82 0f       	add	r24, r18
    27da:	93 1f       	adc	r25, r19
    27dc:	be 01       	movw	r22, r28
    27de:	83 59       	subi	r24, 0x93	; 147
    27e0:	9d 4d       	sbci	r25, 0xDD	; 221
    27e2:	65 da       	rcall	.-2870   	; 0x1cae <vListInsertEnd>
    27e4:	0f 90       	pop	r0
    27e6:	0f be       	out	0x3f, r0	; 63
    27e8:	80 91 49 22 	lds	r24, 0x2249	; 0x802249 <xSchedulerRunning>
    27ec:	88 23       	and	r24, r24
    27ee:	51 f0       	breq	.+20     	; 0x2804 <xTaskGenericCreate+0x1d6>
    27f0:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    27f4:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    27f8:	86 89       	ldd	r24, Z+22	; 0x16
    27fa:	80 17       	cp	r24, r16
    27fc:	28 f4       	brcc	.+10     	; 0x2808 <xTaskGenericCreate+0x1da>
    27fe:	8b db       	rcall	.-2282   	; 0x1f16 <vPortYield>
    2800:	81 e0       	ldi	r24, 0x01	; 1
    2802:	05 c0       	rjmp	.+10     	; 0x280e <xTaskGenericCreate+0x1e0>
    2804:	81 e0       	ldi	r24, 0x01	; 1
    2806:	03 c0       	rjmp	.+6      	; 0x280e <xTaskGenericCreate+0x1e0>
    2808:	81 e0       	ldi	r24, 0x01	; 1
    280a:	01 c0       	rjmp	.+2      	; 0x280e <xTaskGenericCreate+0x1e0>
    280c:	8f ef       	ldi	r24, 0xFF	; 255
    280e:	df 91       	pop	r29
    2810:	cf 91       	pop	r28
    2812:	1f 91       	pop	r17
    2814:	0f 91       	pop	r16
    2816:	ff 90       	pop	r15
    2818:	ef 90       	pop	r14
    281a:	df 90       	pop	r13
    281c:	cf 90       	pop	r12
    281e:	bf 90       	pop	r11
    2820:	af 90       	pop	r10
    2822:	9f 90       	pop	r9
    2824:	8f 90       	pop	r8
    2826:	7f 90       	pop	r7
    2828:	6f 90       	pop	r6
    282a:	5f 90       	pop	r5
    282c:	4f 90       	pop	r4
    282e:	08 95       	ret

00002830 <vTaskStartScheduler>:
    2830:	af 92       	push	r10
    2832:	bf 92       	push	r11
    2834:	cf 92       	push	r12
    2836:	df 92       	push	r13
    2838:	ef 92       	push	r14
    283a:	ff 92       	push	r15
    283c:	0f 93       	push	r16
    283e:	a1 2c       	mov	r10, r1
    2840:	b1 2c       	mov	r11, r1
    2842:	c1 2c       	mov	r12, r1
    2844:	d1 2c       	mov	r13, r1
    2846:	e1 2c       	mov	r14, r1
    2848:	f1 2c       	mov	r15, r1
    284a:	00 e0       	ldi	r16, 0x00	; 0
    284c:	20 e0       	ldi	r18, 0x00	; 0
    284e:	30 e0       	ldi	r19, 0x00	; 0
    2850:	45 e5       	ldi	r20, 0x55	; 85
    2852:	50 e0       	ldi	r21, 0x00	; 0
    2854:	64 e1       	ldi	r22, 0x14	; 20
    2856:	70 e2       	ldi	r23, 0x20	; 32
    2858:	8b ed       	ldi	r24, 0xDB	; 219
    285a:	92 e1       	ldi	r25, 0x12	; 18
    285c:	e8 de       	rcall	.-560    	; 0x262e <xTaskGenericCreate>
    285e:	81 30       	cpi	r24, 0x01	; 1
    2860:	91 f4       	brne	.+36     	; 0x2886 <vTaskStartScheduler+0x56>
    2862:	20 d3       	rcall	.+1600   	; 0x2ea4 <xTimerCreateTimerTask>
    2864:	81 30       	cpi	r24, 0x01	; 1
    2866:	79 f4       	brne	.+30     	; 0x2886 <vTaskStartScheduler+0x56>
    2868:	f8 94       	cli
    286a:	8f ef       	ldi	r24, 0xFF	; 255
    286c:	9f ef       	ldi	r25, 0xFF	; 255
    286e:	80 93 43 22 	sts	0x2243, r24	; 0x802243 <xNextTaskUnblockTime>
    2872:	90 93 44 22 	sts	0x2244, r25	; 0x802244 <xNextTaskUnblockTime+0x1>
    2876:	81 e0       	ldi	r24, 0x01	; 1
    2878:	80 93 49 22 	sts	0x2249, r24	; 0x802249 <xSchedulerRunning>
    287c:	10 92 4b 22 	sts	0x224B, r1	; 0x80224b <xTickCount>
    2880:	10 92 4c 22 	sts	0x224C, r1	; 0x80224c <xTickCount+0x1>
    2884:	03 db       	rcall	.-2554   	; 0x1e8c <xPortStartScheduler>
    2886:	0f 91       	pop	r16
    2888:	ff 90       	pop	r15
    288a:	ef 90       	pop	r14
    288c:	df 90       	pop	r13
    288e:	cf 90       	pop	r12
    2890:	bf 90       	pop	r11
    2892:	af 90       	pop	r10
    2894:	08 95       	ret

00002896 <vTaskSuspendAll>:
    2896:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    289a:	8f 5f       	subi	r24, 0xFF	; 255
    289c:	80 93 42 22 	sts	0x2242, r24	; 0x802242 <uxSchedulerSuspended>
    28a0:	08 95       	ret

000028a2 <xTaskGetTickCount>:
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	0f 92       	push	r0
    28a8:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xTickCount>
    28ac:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <xTickCount+0x1>
    28b0:	0f 90       	pop	r0
    28b2:	0f be       	out	0x3f, r0	; 63
    28b4:	08 95       	ret

000028b6 <xTaskIncrementTick>:
    28b6:	df 92       	push	r13
    28b8:	ef 92       	push	r14
    28ba:	ff 92       	push	r15
    28bc:	0f 93       	push	r16
    28be:	1f 93       	push	r17
    28c0:	cf 93       	push	r28
    28c2:	df 93       	push	r29
    28c4:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    28c8:	81 11       	cpse	r24, r1
    28ca:	b3 c0       	rjmp	.+358    	; 0x2a32 <xTaskIncrementTick+0x17c>
    28cc:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xTickCount>
    28d0:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <xTickCount+0x1>
    28d4:	01 96       	adiw	r24, 0x01	; 1
    28d6:	80 93 4b 22 	sts	0x224B, r24	; 0x80224b <xTickCount>
    28da:	90 93 4c 22 	sts	0x224C, r25	; 0x80224c <xTickCount+0x1>
    28de:	e0 90 4b 22 	lds	r14, 0x224B	; 0x80224b <xTickCount>
    28e2:	f0 90 4c 22 	lds	r15, 0x224C	; 0x80224c <xTickCount+0x1>
    28e6:	e1 14       	cp	r14, r1
    28e8:	f1 04       	cpc	r15, r1
    28ea:	99 f5       	brne	.+102    	; 0x2952 <xTaskIncrementTick+0x9c>
    28ec:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <pxDelayedTaskList>
    28f0:	90 91 5a 22 	lds	r25, 0x225A	; 0x80225a <pxDelayedTaskList+0x1>
    28f4:	20 91 57 22 	lds	r18, 0x2257	; 0x802257 <pxOverflowDelayedTaskList>
    28f8:	30 91 58 22 	lds	r19, 0x2258	; 0x802258 <pxOverflowDelayedTaskList+0x1>
    28fc:	20 93 59 22 	sts	0x2259, r18	; 0x802259 <pxDelayedTaskList>
    2900:	30 93 5a 22 	sts	0x225A, r19	; 0x80225a <pxDelayedTaskList+0x1>
    2904:	80 93 57 22 	sts	0x2257, r24	; 0x802257 <pxOverflowDelayedTaskList>
    2908:	90 93 58 22 	sts	0x2258, r25	; 0x802258 <pxOverflowDelayedTaskList+0x1>
    290c:	80 91 46 22 	lds	r24, 0x2246	; 0x802246 <xNumOfOverflows>
    2910:	8f 5f       	subi	r24, 0xFF	; 255
    2912:	80 93 46 22 	sts	0x2246, r24	; 0x802246 <xNumOfOverflows>
    2916:	e0 91 59 22 	lds	r30, 0x2259	; 0x802259 <pxDelayedTaskList>
    291a:	f0 91 5a 22 	lds	r31, 0x225A	; 0x80225a <pxDelayedTaskList+0x1>
    291e:	80 81       	ld	r24, Z
    2920:	81 11       	cpse	r24, r1
    2922:	07 c0       	rjmp	.+14     	; 0x2932 <xTaskIncrementTick+0x7c>
    2924:	8f ef       	ldi	r24, 0xFF	; 255
    2926:	9f ef       	ldi	r25, 0xFF	; 255
    2928:	80 93 43 22 	sts	0x2243, r24	; 0x802243 <xNextTaskUnblockTime>
    292c:	90 93 44 22 	sts	0x2244, r25	; 0x802244 <xNextTaskUnblockTime+0x1>
    2930:	10 c0       	rjmp	.+32     	; 0x2952 <xTaskIncrementTick+0x9c>
    2932:	e0 91 59 22 	lds	r30, 0x2259	; 0x802259 <pxDelayedTaskList>
    2936:	f0 91 5a 22 	lds	r31, 0x225A	; 0x80225a <pxDelayedTaskList+0x1>
    293a:	05 80       	ldd	r0, Z+5	; 0x05
    293c:	f6 81       	ldd	r31, Z+6	; 0x06
    293e:	e0 2d       	mov	r30, r0
    2940:	06 80       	ldd	r0, Z+6	; 0x06
    2942:	f7 81       	ldd	r31, Z+7	; 0x07
    2944:	e0 2d       	mov	r30, r0
    2946:	82 81       	ldd	r24, Z+2	; 0x02
    2948:	93 81       	ldd	r25, Z+3	; 0x03
    294a:	80 93 43 22 	sts	0x2243, r24	; 0x802243 <xNextTaskUnblockTime>
    294e:	90 93 44 22 	sts	0x2244, r25	; 0x802244 <xNextTaskUnblockTime+0x1>
    2952:	80 91 43 22 	lds	r24, 0x2243	; 0x802243 <xNextTaskUnblockTime>
    2956:	90 91 44 22 	lds	r25, 0x2244	; 0x802244 <xNextTaskUnblockTime+0x1>
    295a:	e8 16       	cp	r14, r24
    295c:	f9 06       	cpc	r15, r25
    295e:	10 f4       	brcc	.+4      	; 0x2964 <xTaskIncrementTick+0xae>
    2960:	d1 2c       	mov	r13, r1
    2962:	4f c0       	rjmp	.+158    	; 0x2a02 <xTaskIncrementTick+0x14c>
    2964:	d1 2c       	mov	r13, r1
    2966:	e0 91 59 22 	lds	r30, 0x2259	; 0x802259 <pxDelayedTaskList>
    296a:	f0 91 5a 22 	lds	r31, 0x225A	; 0x80225a <pxDelayedTaskList+0x1>
    296e:	80 81       	ld	r24, Z
    2970:	81 11       	cpse	r24, r1
    2972:	07 c0       	rjmp	.+14     	; 0x2982 <xTaskIncrementTick+0xcc>
    2974:	8f ef       	ldi	r24, 0xFF	; 255
    2976:	9f ef       	ldi	r25, 0xFF	; 255
    2978:	80 93 43 22 	sts	0x2243, r24	; 0x802243 <xNextTaskUnblockTime>
    297c:	90 93 44 22 	sts	0x2244, r25	; 0x802244 <xNextTaskUnblockTime+0x1>
    2980:	40 c0       	rjmp	.+128    	; 0x2a02 <xTaskIncrementTick+0x14c>
    2982:	e0 91 59 22 	lds	r30, 0x2259	; 0x802259 <pxDelayedTaskList>
    2986:	f0 91 5a 22 	lds	r31, 0x225A	; 0x80225a <pxDelayedTaskList+0x1>
    298a:	05 80       	ldd	r0, Z+5	; 0x05
    298c:	f6 81       	ldd	r31, Z+6	; 0x06
    298e:	e0 2d       	mov	r30, r0
    2990:	c6 81       	ldd	r28, Z+6	; 0x06
    2992:	d7 81       	ldd	r29, Z+7	; 0x07
    2994:	8a 81       	ldd	r24, Y+2	; 0x02
    2996:	9b 81       	ldd	r25, Y+3	; 0x03
    2998:	e8 16       	cp	r14, r24
    299a:	f9 06       	cpc	r15, r25
    299c:	28 f4       	brcc	.+10     	; 0x29a8 <xTaskIncrementTick+0xf2>
    299e:	80 93 43 22 	sts	0x2243, r24	; 0x802243 <xNextTaskUnblockTime>
    29a2:	90 93 44 22 	sts	0x2244, r25	; 0x802244 <xNextTaskUnblockTime+0x1>
    29a6:	2d c0       	rjmp	.+90     	; 0x2a02 <xTaskIncrementTick+0x14c>
    29a8:	8e 01       	movw	r16, r28
    29aa:	0e 5f       	subi	r16, 0xFE	; 254
    29ac:	1f 4f       	sbci	r17, 0xFF	; 255
    29ae:	c8 01       	movw	r24, r16
    29b0:	d0 d9       	rcall	.-3168   	; 0x1d52 <uxListRemove>
    29b2:	8c 89       	ldd	r24, Y+20	; 0x14
    29b4:	9d 89       	ldd	r25, Y+21	; 0x15
    29b6:	89 2b       	or	r24, r25
    29b8:	19 f0       	breq	.+6      	; 0x29c0 <xTaskIncrementTick+0x10a>
    29ba:	ce 01       	movw	r24, r28
    29bc:	0c 96       	adiw	r24, 0x0c	; 12
    29be:	c9 d9       	rcall	.-3182   	; 0x1d52 <uxListRemove>
    29c0:	8e 89       	ldd	r24, Y+22	; 0x16
    29c2:	90 91 4a 22 	lds	r25, 0x224A	; 0x80224a <uxTopReadyPriority>
    29c6:	98 17       	cp	r25, r24
    29c8:	10 f4       	brcc	.+4      	; 0x29ce <xTaskIncrementTick+0x118>
    29ca:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxTopReadyPriority>
    29ce:	90 e0       	ldi	r25, 0x00	; 0
    29d0:	9c 01       	movw	r18, r24
    29d2:	22 0f       	add	r18, r18
    29d4:	33 1f       	adc	r19, r19
    29d6:	22 0f       	add	r18, r18
    29d8:	33 1f       	adc	r19, r19
    29da:	22 0f       	add	r18, r18
    29dc:	33 1f       	adc	r19, r19
    29de:	82 0f       	add	r24, r18
    29e0:	93 1f       	adc	r25, r19
    29e2:	b8 01       	movw	r22, r16
    29e4:	83 59       	subi	r24, 0x93	; 147
    29e6:	9d 4d       	sbci	r25, 0xDD	; 221
    29e8:	62 d9       	rcall	.-3388   	; 0x1cae <vListInsertEnd>
    29ea:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    29ee:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    29f2:	9e 89       	ldd	r25, Y+22	; 0x16
    29f4:	86 89       	ldd	r24, Z+22	; 0x16
    29f6:	98 17       	cp	r25, r24
    29f8:	08 f4       	brcc	.+2      	; 0x29fc <xTaskIncrementTick+0x146>
    29fa:	b5 cf       	rjmp	.-150    	; 0x2966 <xTaskIncrementTick+0xb0>
    29fc:	dd 24       	eor	r13, r13
    29fe:	d3 94       	inc	r13
    2a00:	b2 cf       	rjmp	.-156    	; 0x2966 <xTaskIncrementTick+0xb0>
    2a02:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    2a06:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2a0a:	86 89       	ldd	r24, Z+22	; 0x16
    2a0c:	90 e0       	ldi	r25, 0x00	; 0
    2a0e:	fc 01       	movw	r30, r24
    2a10:	ee 0f       	add	r30, r30
    2a12:	ff 1f       	adc	r31, r31
    2a14:	ee 0f       	add	r30, r30
    2a16:	ff 1f       	adc	r31, r31
    2a18:	ee 0f       	add	r30, r30
    2a1a:	ff 1f       	adc	r31, r31
    2a1c:	8e 0f       	add	r24, r30
    2a1e:	9f 1f       	adc	r25, r31
    2a20:	fc 01       	movw	r30, r24
    2a22:	e3 59       	subi	r30, 0x93	; 147
    2a24:	fd 4d       	sbci	r31, 0xDD	; 221
    2a26:	80 81       	ld	r24, Z
    2a28:	82 30       	cpi	r24, 0x02	; 2
    2a2a:	48 f0       	brcs	.+18     	; 0x2a3e <xTaskIncrementTick+0x188>
    2a2c:	dd 24       	eor	r13, r13
    2a2e:	d3 94       	inc	r13
    2a30:	06 c0       	rjmp	.+12     	; 0x2a3e <xTaskIncrementTick+0x188>
    2a32:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <uxPendedTicks>
    2a36:	8f 5f       	subi	r24, 0xFF	; 255
    2a38:	80 93 48 22 	sts	0x2248, r24	; 0x802248 <uxPendedTicks>
    2a3c:	d1 2c       	mov	r13, r1
    2a3e:	80 91 47 22 	lds	r24, 0x2247	; 0x802247 <xYieldPending>
    2a42:	88 23       	and	r24, r24
    2a44:	11 f0       	breq	.+4      	; 0x2a4a <xTaskIncrementTick+0x194>
    2a46:	dd 24       	eor	r13, r13
    2a48:	d3 94       	inc	r13
    2a4a:	8d 2d       	mov	r24, r13
    2a4c:	df 91       	pop	r29
    2a4e:	cf 91       	pop	r28
    2a50:	1f 91       	pop	r17
    2a52:	0f 91       	pop	r16
    2a54:	ff 90       	pop	r15
    2a56:	ef 90       	pop	r14
    2a58:	df 90       	pop	r13
    2a5a:	08 95       	ret

00002a5c <xTaskResumeAll>:
    2a5c:	df 92       	push	r13
    2a5e:	ef 92       	push	r14
    2a60:	ff 92       	push	r15
    2a62:	0f 93       	push	r16
    2a64:	1f 93       	push	r17
    2a66:	cf 93       	push	r28
    2a68:	df 93       	push	r29
    2a6a:	0f b6       	in	r0, 0x3f	; 63
    2a6c:	f8 94       	cli
    2a6e:	0f 92       	push	r0
    2a70:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    2a74:	81 50       	subi	r24, 0x01	; 1
    2a76:	80 93 42 22 	sts	0x2242, r24	; 0x802242 <uxSchedulerSuspended>
    2a7a:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    2a7e:	81 11       	cpse	r24, r1
    2a80:	5d c0       	rjmp	.+186    	; 0x2b3c <xTaskResumeAll+0xe0>
    2a82:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <uxCurrentNumberOfTasks>
    2a86:	81 11       	cpse	r24, r1
    2a88:	30 c0       	rjmp	.+96     	; 0x2aea <xTaskResumeAll+0x8e>
    2a8a:	5b c0       	rjmp	.+182    	; 0x2b42 <xTaskResumeAll+0xe6>
    2a8c:	d7 01       	movw	r26, r14
    2a8e:	15 96       	adiw	r26, 0x05	; 5
    2a90:	ed 91       	ld	r30, X+
    2a92:	fc 91       	ld	r31, X
    2a94:	16 97       	sbiw	r26, 0x06	; 6
    2a96:	c6 81       	ldd	r28, Z+6	; 0x06
    2a98:	d7 81       	ldd	r29, Z+7	; 0x07
    2a9a:	ce 01       	movw	r24, r28
    2a9c:	0c 96       	adiw	r24, 0x0c	; 12
    2a9e:	59 d9       	rcall	.-3406   	; 0x1d52 <uxListRemove>
    2aa0:	8e 01       	movw	r16, r28
    2aa2:	0e 5f       	subi	r16, 0xFE	; 254
    2aa4:	1f 4f       	sbci	r17, 0xFF	; 255
    2aa6:	c8 01       	movw	r24, r16
    2aa8:	54 d9       	rcall	.-3416   	; 0x1d52 <uxListRemove>
    2aaa:	8e 89       	ldd	r24, Y+22	; 0x16
    2aac:	90 91 4a 22 	lds	r25, 0x224A	; 0x80224a <uxTopReadyPriority>
    2ab0:	98 17       	cp	r25, r24
    2ab2:	10 f4       	brcc	.+4      	; 0x2ab8 <xTaskResumeAll+0x5c>
    2ab4:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxTopReadyPriority>
    2ab8:	90 e0       	ldi	r25, 0x00	; 0
    2aba:	9c 01       	movw	r18, r24
    2abc:	22 0f       	add	r18, r18
    2abe:	33 1f       	adc	r19, r19
    2ac0:	22 0f       	add	r18, r18
    2ac2:	33 1f       	adc	r19, r19
    2ac4:	22 0f       	add	r18, r18
    2ac6:	33 1f       	adc	r19, r19
    2ac8:	82 0f       	add	r24, r18
    2aca:	93 1f       	adc	r25, r19
    2acc:	b8 01       	movw	r22, r16
    2ace:	83 59       	subi	r24, 0x93	; 147
    2ad0:	9d 4d       	sbci	r25, 0xDD	; 221
    2ad2:	ed d8       	rcall	.-3622   	; 0x1cae <vListInsertEnd>
    2ad4:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    2ad8:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2adc:	9e 89       	ldd	r25, Y+22	; 0x16
    2ade:	86 89       	ldd	r24, Z+22	; 0x16
    2ae0:	98 17       	cp	r25, r24
    2ae2:	58 f0       	brcs	.+22     	; 0x2afa <xTaskResumeAll+0x9e>
    2ae4:	d0 92 47 22 	sts	0x2247, r13	; 0x802247 <xYieldPending>
    2ae8:	08 c0       	rjmp	.+16     	; 0x2afa <xTaskResumeAll+0x9e>
    2aea:	0f 2e       	mov	r0, r31
    2aec:	fe e4       	ldi	r31, 0x4E	; 78
    2aee:	ef 2e       	mov	r14, r31
    2af0:	f2 e2       	ldi	r31, 0x22	; 34
    2af2:	ff 2e       	mov	r15, r31
    2af4:	f0 2d       	mov	r31, r0
    2af6:	dd 24       	eor	r13, r13
    2af8:	d3 94       	inc	r13
    2afa:	f7 01       	movw	r30, r14
    2afc:	80 81       	ld	r24, Z
    2afe:	81 11       	cpse	r24, r1
    2b00:	c5 cf       	rjmp	.-118    	; 0x2a8c <xTaskResumeAll+0x30>
    2b02:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <uxPendedTicks>
    2b06:	88 23       	and	r24, r24
    2b08:	91 f0       	breq	.+36     	; 0x2b2e <xTaskResumeAll+0xd2>
    2b0a:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <uxPendedTicks>
    2b0e:	88 23       	and	r24, r24
    2b10:	71 f0       	breq	.+28     	; 0x2b2e <xTaskResumeAll+0xd2>
    2b12:	c1 e0       	ldi	r28, 0x01	; 1
    2b14:	d0 de       	rcall	.-608    	; 0x28b6 <xTaskIncrementTick>
    2b16:	81 11       	cpse	r24, r1
    2b18:	c0 93 47 22 	sts	0x2247, r28	; 0x802247 <xYieldPending>
    2b1c:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <uxPendedTicks>
    2b20:	81 50       	subi	r24, 0x01	; 1
    2b22:	80 93 48 22 	sts	0x2248, r24	; 0x802248 <uxPendedTicks>
    2b26:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <uxPendedTicks>
    2b2a:	81 11       	cpse	r24, r1
    2b2c:	f3 cf       	rjmp	.-26     	; 0x2b14 <xTaskResumeAll+0xb8>
    2b2e:	80 91 47 22 	lds	r24, 0x2247	; 0x802247 <xYieldPending>
    2b32:	81 30       	cpi	r24, 0x01	; 1
    2b34:	29 f4       	brne	.+10     	; 0x2b40 <xTaskResumeAll+0xe4>
    2b36:	ef d9       	rcall	.-3106   	; 0x1f16 <vPortYield>
    2b38:	81 e0       	ldi	r24, 0x01	; 1
    2b3a:	03 c0       	rjmp	.+6      	; 0x2b42 <xTaskResumeAll+0xe6>
    2b3c:	80 e0       	ldi	r24, 0x00	; 0
    2b3e:	01 c0       	rjmp	.+2      	; 0x2b42 <xTaskResumeAll+0xe6>
    2b40:	80 e0       	ldi	r24, 0x00	; 0
    2b42:	0f 90       	pop	r0
    2b44:	0f be       	out	0x3f, r0	; 63
    2b46:	df 91       	pop	r29
    2b48:	cf 91       	pop	r28
    2b4a:	1f 91       	pop	r17
    2b4c:	0f 91       	pop	r16
    2b4e:	ff 90       	pop	r15
    2b50:	ef 90       	pop	r14
    2b52:	df 90       	pop	r13
    2b54:	08 95       	ret

00002b56 <vTaskDelay>:
    2b56:	cf 93       	push	r28
    2b58:	df 93       	push	r29
    2b5a:	ec 01       	movw	r28, r24
    2b5c:	89 2b       	or	r24, r25
    2b5e:	91 f0       	breq	.+36     	; 0x2b84 <vTaskDelay+0x2e>
    2b60:	9a de       	rcall	.-716    	; 0x2896 <vTaskSuspendAll>
    2b62:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xTickCount>
    2b66:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <xTickCount+0x1>
    2b6a:	c8 0f       	add	r28, r24
    2b6c:	d9 1f       	adc	r29, r25
    2b6e:	80 91 9a 22 	lds	r24, 0x229A	; 0x80229a <pxCurrentTCB>
    2b72:	90 91 9b 22 	lds	r25, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2b76:	02 96       	adiw	r24, 0x02	; 2
    2b78:	ec d8       	rcall	.-3624   	; 0x1d52 <uxListRemove>
    2b7a:	ce 01       	movw	r24, r28
    2b7c:	23 dd       	rcall	.-1466   	; 0x25c4 <prvAddCurrentTaskToDelayedList>
    2b7e:	6e df       	rcall	.-292    	; 0x2a5c <xTaskResumeAll>
    2b80:	81 11       	cpse	r24, r1
    2b82:	01 c0       	rjmp	.+2      	; 0x2b86 <vTaskDelay+0x30>
    2b84:	c8 d9       	rcall	.-3184   	; 0x1f16 <vPortYield>
    2b86:	df 91       	pop	r29
    2b88:	cf 91       	pop	r28
    2b8a:	08 95       	ret

00002b8c <vTaskSwitchContext>:
    2b8c:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    2b90:	88 23       	and	r24, r24
    2b92:	21 f0       	breq	.+8      	; 0x2b9c <vTaskSwitchContext+0x10>
    2b94:	81 e0       	ldi	r24, 0x01	; 1
    2b96:	80 93 47 22 	sts	0x2247, r24	; 0x802247 <xYieldPending>
    2b9a:	08 95       	ret
    2b9c:	10 92 47 22 	sts	0x2247, r1	; 0x802247 <xYieldPending>
    2ba0:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxTopReadyPriority>
    2ba4:	90 e0       	ldi	r25, 0x00	; 0
    2ba6:	fc 01       	movw	r30, r24
    2ba8:	ee 0f       	add	r30, r30
    2baa:	ff 1f       	adc	r31, r31
    2bac:	ee 0f       	add	r30, r30
    2bae:	ff 1f       	adc	r31, r31
    2bb0:	ee 0f       	add	r30, r30
    2bb2:	ff 1f       	adc	r31, r31
    2bb4:	8e 0f       	add	r24, r30
    2bb6:	9f 1f       	adc	r25, r31
    2bb8:	fc 01       	movw	r30, r24
    2bba:	e3 59       	subi	r30, 0x93	; 147
    2bbc:	fd 4d       	sbci	r31, 0xDD	; 221
    2bbe:	80 81       	ld	r24, Z
    2bc0:	81 11       	cpse	r24, r1
    2bc2:	17 c0       	rjmp	.+46     	; 0x2bf2 <vTaskSwitchContext+0x66>
    2bc4:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxTopReadyPriority>
    2bc8:	81 50       	subi	r24, 0x01	; 1
    2bca:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxTopReadyPriority>
    2bce:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxTopReadyPriority>
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	fc 01       	movw	r30, r24
    2bd6:	ee 0f       	add	r30, r30
    2bd8:	ff 1f       	adc	r31, r31
    2bda:	ee 0f       	add	r30, r30
    2bdc:	ff 1f       	adc	r31, r31
    2bde:	ee 0f       	add	r30, r30
    2be0:	ff 1f       	adc	r31, r31
    2be2:	8e 0f       	add	r24, r30
    2be4:	9f 1f       	adc	r25, r31
    2be6:	fc 01       	movw	r30, r24
    2be8:	e3 59       	subi	r30, 0x93	; 147
    2bea:	fd 4d       	sbci	r31, 0xDD	; 221
    2bec:	80 81       	ld	r24, Z
    2bee:	88 23       	and	r24, r24
    2bf0:	49 f3       	breq	.-46     	; 0x2bc4 <vTaskSwitchContext+0x38>
    2bf2:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxTopReadyPriority>
    2bf6:	90 e0       	ldi	r25, 0x00	; 0
    2bf8:	9c 01       	movw	r18, r24
    2bfa:	22 0f       	add	r18, r18
    2bfc:	33 1f       	adc	r19, r19
    2bfe:	22 0f       	add	r18, r18
    2c00:	33 1f       	adc	r19, r19
    2c02:	22 0f       	add	r18, r18
    2c04:	33 1f       	adc	r19, r19
    2c06:	28 0f       	add	r18, r24
    2c08:	39 1f       	adc	r19, r25
    2c0a:	d9 01       	movw	r26, r18
    2c0c:	a3 59       	subi	r26, 0x93	; 147
    2c0e:	bd 4d       	sbci	r27, 0xDD	; 221
    2c10:	11 96       	adiw	r26, 0x01	; 1
    2c12:	ed 91       	ld	r30, X+
    2c14:	fc 91       	ld	r31, X
    2c16:	12 97       	sbiw	r26, 0x02	; 2
    2c18:	02 80       	ldd	r0, Z+2	; 0x02
    2c1a:	f3 81       	ldd	r31, Z+3	; 0x03
    2c1c:	e0 2d       	mov	r30, r0
    2c1e:	11 96       	adiw	r26, 0x01	; 1
    2c20:	ed 93       	st	X+, r30
    2c22:	fc 93       	st	X, r31
    2c24:	12 97       	sbiw	r26, 0x02	; 2
    2c26:	20 59       	subi	r18, 0x90	; 144
    2c28:	3d 4d       	sbci	r19, 0xDD	; 221
    2c2a:	e2 17       	cp	r30, r18
    2c2c:	f3 07       	cpc	r31, r19
    2c2e:	29 f4       	brne	.+10     	; 0x2c3a <vTaskSwitchContext+0xae>
    2c30:	22 81       	ldd	r18, Z+2	; 0x02
    2c32:	33 81       	ldd	r19, Z+3	; 0x03
    2c34:	fd 01       	movw	r30, r26
    2c36:	21 83       	std	Z+1, r18	; 0x01
    2c38:	32 83       	std	Z+2, r19	; 0x02
    2c3a:	fc 01       	movw	r30, r24
    2c3c:	ee 0f       	add	r30, r30
    2c3e:	ff 1f       	adc	r31, r31
    2c40:	ee 0f       	add	r30, r30
    2c42:	ff 1f       	adc	r31, r31
    2c44:	ee 0f       	add	r30, r30
    2c46:	ff 1f       	adc	r31, r31
    2c48:	8e 0f       	add	r24, r30
    2c4a:	9f 1f       	adc	r25, r31
    2c4c:	fc 01       	movw	r30, r24
    2c4e:	e3 59       	subi	r30, 0x93	; 147
    2c50:	fd 4d       	sbci	r31, 0xDD	; 221
    2c52:	01 80       	ldd	r0, Z+1	; 0x01
    2c54:	f2 81       	ldd	r31, Z+2	; 0x02
    2c56:	e0 2d       	mov	r30, r0
    2c58:	86 81       	ldd	r24, Z+6	; 0x06
    2c5a:	97 81       	ldd	r25, Z+7	; 0x07
    2c5c:	80 93 9a 22 	sts	0x229A, r24	; 0x80229a <pxCurrentTCB>
    2c60:	90 93 9b 22 	sts	0x229B, r25	; 0x80229b <pxCurrentTCB+0x1>
    2c64:	08 95       	ret

00002c66 <vTaskPlaceOnEventList>:
    2c66:	cf 93       	push	r28
    2c68:	df 93       	push	r29
    2c6a:	eb 01       	movw	r28, r22
    2c6c:	60 91 9a 22 	lds	r22, 0x229A	; 0x80229a <pxCurrentTCB>
    2c70:	70 91 9b 22 	lds	r23, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2c74:	64 5f       	subi	r22, 0xF4	; 244
    2c76:	7f 4f       	sbci	r23, 0xFF	; 255
    2c78:	3b d8       	rcall	.-3978   	; 0x1cf0 <vListInsert>
    2c7a:	80 91 9a 22 	lds	r24, 0x229A	; 0x80229a <pxCurrentTCB>
    2c7e:	90 91 9b 22 	lds	r25, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2c82:	02 96       	adiw	r24, 0x02	; 2
    2c84:	66 d8       	rcall	.-3892   	; 0x1d52 <uxListRemove>
    2c86:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xTickCount>
    2c8a:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <xTickCount+0x1>
    2c8e:	8c 0f       	add	r24, r28
    2c90:	9d 1f       	adc	r25, r29
    2c92:	98 dc       	rcall	.-1744   	; 0x25c4 <prvAddCurrentTaskToDelayedList>
    2c94:	df 91       	pop	r29
    2c96:	cf 91       	pop	r28
    2c98:	08 95       	ret

00002c9a <vTaskPlaceOnEventListRestricted>:
    2c9a:	cf 93       	push	r28
    2c9c:	df 93       	push	r29
    2c9e:	eb 01       	movw	r28, r22
    2ca0:	60 91 9a 22 	lds	r22, 0x229A	; 0x80229a <pxCurrentTCB>
    2ca4:	70 91 9b 22 	lds	r23, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2ca8:	64 5f       	subi	r22, 0xF4	; 244
    2caa:	7f 4f       	sbci	r23, 0xFF	; 255
    2cac:	00 d8       	rcall	.-4096   	; 0x1cae <vListInsertEnd>
    2cae:	80 91 9a 22 	lds	r24, 0x229A	; 0x80229a <pxCurrentTCB>
    2cb2:	90 91 9b 22 	lds	r25, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2cb6:	02 96       	adiw	r24, 0x02	; 2
    2cb8:	4c d8       	rcall	.-3944   	; 0x1d52 <uxListRemove>
    2cba:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xTickCount>
    2cbe:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <xTickCount+0x1>
    2cc2:	8c 0f       	add	r24, r28
    2cc4:	9d 1f       	adc	r25, r29
    2cc6:	7e dc       	rcall	.-1796   	; 0x25c4 <prvAddCurrentTaskToDelayedList>
    2cc8:	df 91       	pop	r29
    2cca:	cf 91       	pop	r28
    2ccc:	08 95       	ret

00002cce <xTaskRemoveFromEventList>:
    2cce:	0f 93       	push	r16
    2cd0:	1f 93       	push	r17
    2cd2:	cf 93       	push	r28
    2cd4:	df 93       	push	r29
    2cd6:	dc 01       	movw	r26, r24
    2cd8:	15 96       	adiw	r26, 0x05	; 5
    2cda:	ed 91       	ld	r30, X+
    2cdc:	fc 91       	ld	r31, X
    2cde:	16 97       	sbiw	r26, 0x06	; 6
    2ce0:	c6 81       	ldd	r28, Z+6	; 0x06
    2ce2:	d7 81       	ldd	r29, Z+7	; 0x07
    2ce4:	8e 01       	movw	r16, r28
    2ce6:	04 5f       	subi	r16, 0xF4	; 244
    2ce8:	1f 4f       	sbci	r17, 0xFF	; 255
    2cea:	c8 01       	movw	r24, r16
    2cec:	32 d8       	rcall	.-3996   	; 0x1d52 <uxListRemove>
    2cee:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    2cf2:	81 11       	cpse	r24, r1
    2cf4:	1b c0       	rjmp	.+54     	; 0x2d2c <xTaskRemoveFromEventList+0x5e>
    2cf6:	0a 50       	subi	r16, 0x0A	; 10
    2cf8:	11 09       	sbc	r17, r1
    2cfa:	c8 01       	movw	r24, r16
    2cfc:	2a d8       	rcall	.-4012   	; 0x1d52 <uxListRemove>
    2cfe:	8e 89       	ldd	r24, Y+22	; 0x16
    2d00:	90 91 4a 22 	lds	r25, 0x224A	; 0x80224a <uxTopReadyPriority>
    2d04:	98 17       	cp	r25, r24
    2d06:	10 f4       	brcc	.+4      	; 0x2d0c <xTaskRemoveFromEventList+0x3e>
    2d08:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxTopReadyPriority>
    2d0c:	90 e0       	ldi	r25, 0x00	; 0
    2d0e:	9c 01       	movw	r18, r24
    2d10:	22 0f       	add	r18, r18
    2d12:	33 1f       	adc	r19, r19
    2d14:	22 0f       	add	r18, r18
    2d16:	33 1f       	adc	r19, r19
    2d18:	22 0f       	add	r18, r18
    2d1a:	33 1f       	adc	r19, r19
    2d1c:	82 0f       	add	r24, r18
    2d1e:	93 1f       	adc	r25, r19
    2d20:	b8 01       	movw	r22, r16
    2d22:	83 59       	subi	r24, 0x93	; 147
    2d24:	9d 4d       	sbci	r25, 0xDD	; 221
    2d26:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vListInsertEnd>
    2d2a:	05 c0       	rjmp	.+10     	; 0x2d36 <xTaskRemoveFromEventList+0x68>
    2d2c:	b8 01       	movw	r22, r16
    2d2e:	8e e4       	ldi	r24, 0x4E	; 78
    2d30:	92 e2       	ldi	r25, 0x22	; 34
    2d32:	0e 94 57 0e 	call	0x1cae	; 0x1cae <vListInsertEnd>
    2d36:	e0 91 9a 22 	lds	r30, 0x229A	; 0x80229a <pxCurrentTCB>
    2d3a:	f0 91 9b 22 	lds	r31, 0x229B	; 0x80229b <pxCurrentTCB+0x1>
    2d3e:	9e 89       	ldd	r25, Y+22	; 0x16
    2d40:	86 89       	ldd	r24, Z+22	; 0x16
    2d42:	89 17       	cp	r24, r25
    2d44:	20 f4       	brcc	.+8      	; 0x2d4e <xTaskRemoveFromEventList+0x80>
    2d46:	81 e0       	ldi	r24, 0x01	; 1
    2d48:	80 93 47 22 	sts	0x2247, r24	; 0x802247 <xYieldPending>
    2d4c:	01 c0       	rjmp	.+2      	; 0x2d50 <xTaskRemoveFromEventList+0x82>
    2d4e:	80 e0       	ldi	r24, 0x00	; 0
    2d50:	df 91       	pop	r29
    2d52:	cf 91       	pop	r28
    2d54:	1f 91       	pop	r17
    2d56:	0f 91       	pop	r16
    2d58:	08 95       	ret

00002d5a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2d5a:	20 91 46 22 	lds	r18, 0x2246	; 0x802246 <xNumOfOverflows>
    2d5e:	fc 01       	movw	r30, r24
    2d60:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2d62:	20 91 4b 22 	lds	r18, 0x224B	; 0x80224b <xTickCount>
    2d66:	30 91 4c 22 	lds	r19, 0x224C	; 0x80224c <xTickCount+0x1>
    2d6a:	21 83       	std	Z+1, r18	; 0x01
    2d6c:	32 83       	std	Z+2, r19	; 0x02
    2d6e:	08 95       	ret

00002d70 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2d70:	cf 93       	push	r28
    2d72:	df 93       	push	r29
    2d74:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2d76:	0f b6       	in	r0, 0x3f	; 63
    2d78:	f8 94       	cli
    2d7a:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2d7c:	20 91 4b 22 	lds	r18, 0x224B	; 0x80224b <xTickCount>
    2d80:	30 91 4c 22 	lds	r19, 0x224C	; 0x80224c <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2d84:	80 91 46 22 	lds	r24, 0x2246	; 0x802246 <xNumOfOverflows>
    2d88:	90 81       	ld	r25, Z
    2d8a:	98 17       	cp	r25, r24
    2d8c:	29 f0       	breq	.+10     	; 0x2d98 <xTaskCheckForTimeOut+0x28>
    2d8e:	81 81       	ldd	r24, Z+1	; 0x01
    2d90:	92 81       	ldd	r25, Z+2	; 0x02
    2d92:	28 17       	cp	r18, r24
    2d94:	39 07       	cpc	r19, r25
    2d96:	a8 f4       	brcc	.+42     	; 0x2dc2 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2d98:	a1 81       	ldd	r26, Z+1	; 0x01
    2d9a:	b2 81       	ldd	r27, Z+2	; 0x02
    2d9c:	eb 01       	movw	r28, r22
    2d9e:	48 81       	ld	r20, Y
    2da0:	59 81       	ldd	r21, Y+1	; 0x01
    2da2:	c9 01       	movw	r24, r18
    2da4:	8a 1b       	sub	r24, r26
    2da6:	9b 0b       	sbc	r25, r27
    2da8:	84 17       	cp	r24, r20
    2daa:	95 07       	cpc	r25, r21
    2dac:	60 f4       	brcc	.+24     	; 0x2dc6 <xTaskCheckForTimeOut+0x56>
    2dae:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2db0:	a2 1b       	sub	r26, r18
    2db2:	b3 0b       	sbc	r27, r19
    2db4:	4a 0f       	add	r20, r26
    2db6:	5b 1f       	adc	r21, r27
    2db8:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    2dba:	59 83       	std	Y+1, r21	; 0x01
			xReturn = pdFALSE;
    2dbc:	ce df       	rcall	.-100    	; 0x2d5a <vTaskSetTimeOutState>
    2dbe:	80 e0       	ldi	r24, 0x00	; 0
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2dc0:	03 c0       	rjmp	.+6      	; 0x2dc8 <xTaskCheckForTimeOut+0x58>
    2dc2:	81 e0       	ldi	r24, 0x01	; 1
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2dc4:	01 c0       	rjmp	.+2      	; 0x2dc8 <xTaskCheckForTimeOut+0x58>
		}
	}
	taskEXIT_CRITICAL();
    2dc6:	81 e0       	ldi	r24, 0x01	; 1
    2dc8:	0f 90       	pop	r0

	return xReturn;
}
    2dca:	0f be       	out	0x3f, r0	; 63
    2dcc:	df 91       	pop	r29
    2dce:	cf 91       	pop	r28
    2dd0:	08 95       	ret

00002dd2 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2dd2:	81 e0       	ldi	r24, 0x01	; 1
    2dd4:	80 93 47 22 	sts	0x2247, r24	; 0x802247 <xYieldPending>
    2dd8:	08 95       	ret

00002dda <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2dda:	80 91 49 22 	lds	r24, 0x2249	; 0x802249 <xSchedulerRunning>
    2dde:	88 23       	and	r24, r24
    2de0:	31 f0       	breq	.+12     	; 0x2dee <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2de2:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <uxSchedulerSuspended>
    2de6:	88 23       	and	r24, r24
    2de8:	21 f0       	breq	.+8      	; 0x2df2 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2dea:	80 e0       	ldi	r24, 0x00	; 0
    2dec:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2dee:	81 e0       	ldi	r24, 0x01	; 1
    2df0:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2df2:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2df4:	08 95       	ret

00002df6 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2df6:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2df8:	62 83       	std	Z+2, r22	; 0x02
    2dfa:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2dfc:	80 87       	std	Z+8, r24	; 0x08
    2dfe:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    2e00:	46 17       	cp	r20, r22
    2e02:	57 07       	cpc	r21, r23
    2e04:	90 f0       	brcs	.+36     	; 0x2e2a <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2e06:	42 1b       	sub	r20, r18
    2e08:	53 0b       	sbc	r21, r19
    2e0a:	84 85       	ldd	r24, Z+12	; 0x0c
    2e0c:	95 85       	ldd	r25, Z+13	; 0x0d
    2e0e:	48 17       	cp	r20, r24
    2e10:	59 07       	cpc	r21, r25
    2e12:	e0 f4       	brcc	.+56     	; 0x2e4c <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2e14:	bf 01       	movw	r22, r30
    2e16:	6e 5f       	subi	r22, 0xFE	; 254
    2e18:	7f 4f       	sbci	r23, 0xFF	; 255
    2e1a:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <pxOverflowTimerList>
    2e1e:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <pxOverflowTimerList+0x1>
    2e22:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2e26:	80 e0       	ldi	r24, 0x00	; 0
    2e28:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2e2a:	42 17       	cp	r20, r18
    2e2c:	53 07       	cpc	r21, r19
    2e2e:	18 f4       	brcc	.+6      	; 0x2e36 <prvInsertTimerInActiveList+0x40>
    2e30:	62 17       	cp	r22, r18
    2e32:	73 07       	cpc	r23, r19
    2e34:	68 f4       	brcc	.+26     	; 0x2e50 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2e36:	bf 01       	movw	r22, r30
    2e38:	6e 5f       	subi	r22, 0xFE	; 254
    2e3a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e3c:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <pxCurrentTimerList>
    2e40:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <pxCurrentTimerList+0x1>
    2e44:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2e48:	80 e0       	ldi	r24, 0x00	; 0
    2e4a:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2e4c:	81 e0       	ldi	r24, 0x01	; 1
    2e4e:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2e50:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2e52:	08 95       	ret

00002e54 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2e54:	0f b6       	in	r0, 0x3f	; 63
    2e56:	f8 94       	cli
    2e58:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2e5a:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xTimerQueue>
    2e5e:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xTimerQueue+0x1>
    2e62:	89 2b       	or	r24, r25
    2e64:	e1 f4       	brne	.+56     	; 0x2e9e <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    2e66:	8d ea       	ldi	r24, 0xAD	; 173
    2e68:	92 e2       	ldi	r25, 0x22	; 34
    2e6a:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    2e6e:	84 ea       	ldi	r24, 0xA4	; 164
    2e70:	92 e2       	ldi	r25, 0x22	; 34
    2e72:	0e 94 45 0e 	call	0x1c8a	; 0x1c8a <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    2e76:	8d ea       	ldi	r24, 0xAD	; 173
    2e78:	92 e2       	ldi	r25, 0x22	; 34
    2e7a:	80 93 a2 22 	sts	0x22A2, r24	; 0x8022a2 <pxCurrentTimerList>
    2e7e:	90 93 a3 22 	sts	0x22A3, r25	; 0x8022a3 <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    2e82:	84 ea       	ldi	r24, 0xA4	; 164
    2e84:	92 e2       	ldi	r25, 0x22	; 34
    2e86:	80 93 a0 22 	sts	0x22A0, r24	; 0x8022a0 <pxOverflowTimerList>
    2e8a:	90 93 a1 22 	sts	0x22A1, r25	; 0x8022a1 <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2e8e:	40 e0       	ldi	r20, 0x00	; 0
    2e90:	65 e0       	ldi	r22, 0x05	; 5
    2e92:	8a e0       	ldi	r24, 0x0A	; 10
    2e94:	f2 d9       	rcall	.-3100   	; 0x227a <xQueueGenericCreate>
    2e96:	80 93 9e 22 	sts	0x229E, r24	; 0x80229e <xTimerQueue>
    2e9a:	90 93 9f 22 	sts	0x229F, r25	; 0x80229f <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2e9e:	0f 90       	pop	r0
    2ea0:	0f be       	out	0x3f, r0	; 63
    2ea2:	08 95       	ret

00002ea4 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    2ea4:	af 92       	push	r10
    2ea6:	bf 92       	push	r11
    2ea8:	cf 92       	push	r12
    2eaa:	df 92       	push	r13
    2eac:	ef 92       	push	r14
    2eae:	ff 92       	push	r15

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2eb0:	0f 93       	push	r16

	if( xTimerQueue != NULL )
    2eb2:	d0 df       	rcall	.-96     	; 0x2e54 <prvCheckForValidListAndQueue>
    2eb4:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xTimerQueue>
    2eb8:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xTimerQueue+0x1>
    2ebc:	89 2b       	or	r24, r25
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    2ebe:	89 f0       	breq	.+34     	; 0x2ee2 <xTimerCreateTimerTask+0x3e>
    2ec0:	a1 2c       	mov	r10, r1
    2ec2:	b1 2c       	mov	r11, r1
    2ec4:	c1 2c       	mov	r12, r1
    2ec6:	d1 2c       	mov	r13, r1
    2ec8:	e1 2c       	mov	r14, r1
    2eca:	f1 2c       	mov	r15, r1
    2ecc:	03 e0       	ldi	r16, 0x03	; 3
    2ece:	20 e0       	ldi	r18, 0x00	; 0
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
    2ed2:	45 e5       	ldi	r20, 0x55	; 85
    2ed4:	50 e0       	ldi	r21, 0x00	; 0
    2ed6:	69 e1       	ldi	r22, 0x19	; 25
    2ed8:	70 e2       	ldi	r23, 0x20	; 32
    2eda:	80 e6       	ldi	r24, 0x60	; 96
    2edc:	98 e1       	ldi	r25, 0x18	; 24
    2ede:	a7 db       	rcall	.-2226   	; 0x262e <xTaskGenericCreate>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2ee0:	01 c0       	rjmp	.+2      	; 0x2ee4 <xTimerCreateTimerTask+0x40>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2ee2:	80 e0       	ldi	r24, 0x00	; 0
    2ee4:	0f 91       	pop	r16
    2ee6:	ff 90       	pop	r15
    2ee8:	ef 90       	pop	r14
    2eea:	df 90       	pop	r13
    2eec:	cf 90       	pop	r12
    2eee:	bf 90       	pop	r11
    2ef0:	af 90       	pop	r10
    2ef2:	08 95       	ret

00002ef4 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2ef4:	8f 92       	push	r8
    2ef6:	9f 92       	push	r9
    2ef8:	bf 92       	push	r11
    2efa:	cf 92       	push	r12
    2efc:	df 92       	push	r13
    2efe:	ef 92       	push	r14
    2f00:	ff 92       	push	r15
    2f02:	0f 93       	push	r16
    2f04:	1f 93       	push	r17
    2f06:	cf 93       	push	r28
    2f08:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    2f0a:	61 15       	cp	r22, r1
    2f0c:	71 05       	cpc	r23, r1
    2f0e:	c9 f0       	breq	.+50     	; 0x2f42 <xTimerCreate+0x4e>
    2f10:	69 01       	movw	r12, r18
    2f12:	b4 2e       	mov	r11, r20
    2f14:	7b 01       	movw	r14, r22
    2f16:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2f18:	83 e1       	ldi	r24, 0x13	; 19
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	ae d8       	rcall	.-3748   	; 0x207a <pvPortMalloc>
    2f1e:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2f20:	89 2b       	or	r24, r25
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2f22:	89 f0       	breq	.+34     	; 0x2f46 <xTimerCreate+0x52>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2f24:	97 df       	rcall	.-210    	; 0x2e54 <prvCheckForValidListAndQueue>
    2f26:	88 82       	st	Y, r8
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2f28:	99 82       	std	Y+1, r9	; 0x01
    2f2a:	ec 86       	std	Y+12, r14	; 0x0c
			pxNewTimer->uxAutoReload = uxAutoReload;
    2f2c:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->pvTimerID = pvTimerID;
    2f2e:	be 86       	std	Y+14, r11	; 0x0e
    2f30:	cf 86       	std	Y+15, r12	; 0x0f
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2f32:	d8 8a       	std	Y+16, r13	; 0x10
    2f34:	09 8b       	std	Y+17, r16	; 0x11
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2f36:	1a 8b       	std	Y+18, r17	; 0x12
    2f38:	ce 01       	movw	r24, r28
    2f3a:	02 96       	adiw	r24, 0x02	; 2
    2f3c:	0e 94 53 0e 	call	0x1ca6	; 0x1ca6 <vListInitialiseItem>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2f40:	02 c0       	rjmp	.+4      	; 0x2f46 <xTimerCreate+0x52>
    2f42:	c0 e0       	ldi	r28, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2f44:	d0 e0       	ldi	r29, 0x00	; 0
    2f46:	ce 01       	movw	r24, r28
    2f48:	df 91       	pop	r29
    2f4a:	cf 91       	pop	r28
    2f4c:	1f 91       	pop	r17
    2f4e:	0f 91       	pop	r16
    2f50:	ff 90       	pop	r15
    2f52:	ef 90       	pop	r14
    2f54:	df 90       	pop	r13
    2f56:	cf 90       	pop	r12
    2f58:	bf 90       	pop	r11
    2f5a:	9f 90       	pop	r9
    2f5c:	8f 90       	pop	r8
    2f5e:	08 95       	ret

00002f60 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2f60:	0f 93       	push	r16
    2f62:	1f 93       	push	r17
    2f64:	cf 93       	push	r28
    2f66:	df 93       	push	r29
    2f68:	cd b7       	in	r28, 0x3d	; 61
    2f6a:	de b7       	in	r29, 0x3e	; 62
    2f6c:	25 97       	sbiw	r28, 0x05	; 5
    2f6e:	cd bf       	out	0x3d, r28	; 61
    2f70:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2f72:	e0 91 9e 22 	lds	r30, 0x229E	; 0x80229e <xTimerQueue>
    2f76:	f0 91 9f 22 	lds	r31, 0x229F	; 0x80229f <xTimerQueue+0x1>
    2f7a:	30 97       	sbiw	r30, 0x00	; 0
    2f7c:	51 f1       	breq	.+84     	; 0x2fd2 <xTimerGenericCommand+0x72>
    2f7e:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2f80:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2f82:	4a 83       	std	Y+2, r20	; 0x02
    2f84:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2f86:	8c 83       	std	Y+4, r24	; 0x04
    2f88:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2f8a:	66 30       	cpi	r22, 0x06	; 6
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2f8c:	d4 f4       	brge	.+52     	; 0x2fc2 <xTimerGenericCommand+0x62>
    2f8e:	25 df       	rcall	.-438    	; 0x2dda <xTaskGetSchedulerState>
    2f90:	82 30       	cpi	r24, 0x02	; 2
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2f92:	59 f4       	brne	.+22     	; 0x2faa <xTimerGenericCommand+0x4a>
    2f94:	20 e0       	ldi	r18, 0x00	; 0
    2f96:	a8 01       	movw	r20, r16
    2f98:	be 01       	movw	r22, r28
    2f9a:	6f 5f       	subi	r22, 0xFF	; 255
    2f9c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f9e:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xTimerQueue>
    2fa2:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xTimerQueue+0x1>
    2fa6:	92 d9       	rcall	.-3292   	; 0x22cc <xQueueGenericSend>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2fa8:	15 c0       	rjmp	.+42     	; 0x2fd4 <xTimerGenericCommand+0x74>
    2faa:	20 e0       	ldi	r18, 0x00	; 0
    2fac:	40 e0       	ldi	r20, 0x00	; 0
    2fae:	50 e0       	ldi	r21, 0x00	; 0
    2fb0:	be 01       	movw	r22, r28
    2fb2:	6f 5f       	subi	r22, 0xFF	; 255
    2fb4:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb6:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xTimerQueue>
    2fba:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xTimerQueue+0x1>
    2fbe:	86 d9       	rcall	.-3316   	; 0x22cc <xQueueGenericSend>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2fc0:	09 c0       	rjmp	.+18     	; 0x2fd4 <xTimerGenericCommand+0x74>
    2fc2:	20 e0       	ldi	r18, 0x00	; 0
    2fc4:	ad 01       	movw	r20, r26
    2fc6:	be 01       	movw	r22, r28
    2fc8:	6f 5f       	subi	r22, 0xFF	; 255
    2fca:	7f 4f       	sbci	r23, 0xFF	; 255
    2fcc:	cf 01       	movw	r24, r30
    2fce:	0b da       	rcall	.-3050   	; 0x23e6 <xQueueGenericSendFromISR>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2fd0:	01 c0       	rjmp	.+2      	; 0x2fd4 <xTimerGenericCommand+0x74>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2fd2:	80 e0       	ldi	r24, 0x00	; 0
    2fd4:	25 96       	adiw	r28, 0x05	; 5
    2fd6:	cd bf       	out	0x3d, r28	; 61
    2fd8:	de bf       	out	0x3e, r29	; 62
    2fda:	df 91       	pop	r29
    2fdc:	cf 91       	pop	r28
    2fde:	1f 91       	pop	r17
    2fe0:	0f 91       	pop	r16
    2fe2:	08 95       	ret

00002fe4 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2fe4:	af 92       	push	r10
    2fe6:	bf 92       	push	r11
    2fe8:	cf 92       	push	r12
    2fea:	df 92       	push	r13
    2fec:	ef 92       	push	r14
    2fee:	ff 92       	push	r15
    2ff0:	0f 93       	push	r16
    2ff2:	1f 93       	push	r17
    2ff4:	cf 93       	push	r28
    2ff6:	df 93       	push	r29
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2ff8:	6c 01       	movw	r12, r24
    2ffa:	53 dc       	rcall	.-1882   	; 0x28a2 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
    2ffc:	7c 01       	movw	r14, r24
    2ffe:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <xLastTime.4459>
    3002:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <xLastTime.4459+0x1>
    3006:	e8 16       	cp	r14, r24
    3008:	f9 06       	cpc	r15, r25
    300a:	08 f0       	brcs	.+2      	; 0x300e <prvSampleTimeNow+0x2a>
    300c:	47 c0       	rjmp	.+142    	; 0x309c <prvSampleTimeNow+0xb8>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    300e:	2f c0       	rjmp	.+94     	; 0x306e <prvSampleTimeNow+0x8a>
    3010:	05 80       	ldd	r0, Z+5	; 0x05
    3012:	f6 81       	ldd	r31, Z+6	; 0x06
    3014:	e0 2d       	mov	r30, r0
    3016:	a0 80       	ld	r10, Z

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3018:	b1 80       	ldd	r11, Z+1	; 0x01
    301a:	c6 81       	ldd	r28, Z+6	; 0x06
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    301c:	d7 81       	ldd	r29, Z+7	; 0x07
    301e:	8e 01       	movw	r16, r28
    3020:	0e 5f       	subi	r16, 0xFE	; 254
    3022:	1f 4f       	sbci	r17, 0xFF	; 255
    3024:	c8 01       	movw	r24, r16
    3026:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    302a:	e9 89       	ldd	r30, Y+17	; 0x11
    302c:	fa 89       	ldd	r31, Y+18	; 0x12
    302e:	ce 01       	movw	r24, r28

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    3030:	19 95       	eicall
    3032:	8e 85       	ldd	r24, Y+14	; 0x0e
    3034:	81 30       	cpi	r24, 0x01	; 1
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3036:	d9 f4       	brne	.+54     	; 0x306e <prvSampleTimeNow+0x8a>
    3038:	8c 85       	ldd	r24, Y+12	; 0x0c
    303a:	9d 85       	ldd	r25, Y+13	; 0x0d
    303c:	8a 0d       	add	r24, r10
			if( xReloadTime > xNextExpireTime )
    303e:	9b 1d       	adc	r25, r11
    3040:	a8 16       	cp	r10, r24
    3042:	b9 06       	cpc	r11, r25
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3044:	60 f4       	brcc	.+24     	; 0x305e <prvSampleTimeNow+0x7a>
    3046:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3048:	9b 83       	std	Y+3, r25	; 0x03
    304a:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    304c:	d9 87       	std	Y+9, r29	; 0x09
    304e:	b8 01       	movw	r22, r16
    3050:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <pxCurrentTimerList>
    3054:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <pxCurrentTimerList+0x1>
    3058:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <vListInsert>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    305c:	08 c0       	rjmp	.+16     	; 0x306e <prvSampleTimeNow+0x8a>
    305e:	00 e0       	ldi	r16, 0x00	; 0
    3060:	10 e0       	ldi	r17, 0x00	; 0
    3062:	20 e0       	ldi	r18, 0x00	; 0
    3064:	30 e0       	ldi	r19, 0x00	; 0
    3066:	a5 01       	movw	r20, r10
    3068:	60 e0       	ldi	r22, 0x00	; 0
    306a:	ce 01       	movw	r24, r28

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    306c:	79 df       	rcall	.-270    	; 0x2f60 <xTimerGenericCommand>
    306e:	e0 91 a2 22 	lds	r30, 0x22A2	; 0x8022a2 <pxCurrentTimerList>
    3072:	f0 91 a3 22 	lds	r31, 0x22A3	; 0x8022a3 <pxCurrentTimerList+0x1>
    3076:	80 81       	ld	r24, Z
    3078:	81 11       	cpse	r24, r1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    307a:	ca cf       	rjmp	.-108    	; 0x3010 <prvSampleTimeNow+0x2c>
    307c:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <pxOverflowTimerList>
    3080:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <pxOverflowTimerList+0x1>
    3084:	80 93 a2 22 	sts	0x22A2, r24	; 0x8022a2 <pxCurrentTimerList>
    3088:	90 93 a3 22 	sts	0x22A3, r25	; 0x8022a3 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    308c:	e0 93 a0 22 	sts	0x22A0, r30	; 0x8022a0 <pxOverflowTimerList>
    3090:	f0 93 a1 22 	sts	0x22A1, r31	; 0x8022a1 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    3094:	81 e0       	ldi	r24, 0x01	; 1
    3096:	f6 01       	movw	r30, r12
    3098:	80 83       	st	Z, r24
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    309a:	02 c0       	rjmp	.+4      	; 0x30a0 <prvSampleTimeNow+0xbc>
    309c:	f6 01       	movw	r30, r12
	}

	xLastTime = xTimeNow;
    309e:	10 82       	st	Z, r1
    30a0:	e0 92 9c 22 	sts	0x229C, r14	; 0x80229c <xLastTime.4459>
    30a4:	f0 92 9d 22 	sts	0x229D, r15	; 0x80229d <xLastTime.4459+0x1>

	return xTimeNow;
}
    30a8:	c7 01       	movw	r24, r14
    30aa:	df 91       	pop	r29
    30ac:	cf 91       	pop	r28
    30ae:	1f 91       	pop	r17
    30b0:	0f 91       	pop	r16
    30b2:	ff 90       	pop	r15
    30b4:	ef 90       	pop	r14
    30b6:	df 90       	pop	r13
    30b8:	cf 90       	pop	r12
    30ba:	bf 90       	pop	r11
    30bc:	af 90       	pop	r10
    30be:	08 95       	ret

000030c0 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    30c0:	cf 93       	push	r28
    30c2:	df 93       	push	r29
    30c4:	00 d0       	rcall	.+0      	; 0x30c6 <prvTimerTask+0x6>
    30c6:	00 d0       	rcall	.+0      	; 0x30c8 <prvTimerTask+0x8>
    30c8:	cd b7       	in	r28, 0x3d	; 61
    30ca:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    30cc:	ce 01       	movw	r24, r28
    30ce:	01 96       	adiw	r24, 0x01	; 1
    30d0:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    30d2:	e8 2e       	mov	r14, r24
    30d4:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    30d6:	e0 91 a2 22 	lds	r30, 0x22A2	; 0x8022a2 <pxCurrentTimerList>
    30da:	f0 91 a3 22 	lds	r31, 0x22A3	; 0x8022a3 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    30de:	80 81       	ld	r24, Z
    30e0:	88 23       	and	r24, r24
    30e2:	09 f4       	brne	.+2      	; 0x30e6 <prvTimerTask+0x26>
    30e4:	b6 c0       	rjmp	.+364    	; 0x3252 <prvTimerTask+0x192>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    30e6:	05 80       	ldd	r0, Z+5	; 0x05
    30e8:	f6 81       	ldd	r31, Z+6	; 0x06
    30ea:	e0 2d       	mov	r30, r0
    30ec:	c0 80       	ld	r12, Z
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    30ee:	d1 80       	ldd	r13, Z+1	; 0x01
    30f0:	d2 db       	rcall	.-2140   	; 0x2896 <vTaskSuspendAll>
    30f2:	c5 01       	movw	r24, r10
		if( xTimerListsWereSwitched == pdFALSE )
    30f4:	77 df       	rcall	.-274    	; 0x2fe4 <prvSampleTimeNow>
    30f6:	8c 01       	movw	r16, r24
    30f8:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    30fa:	81 11       	cpse	r24, r1
    30fc:	42 c0       	rjmp	.+132    	; 0x3182 <prvTimerTask+0xc2>
			{
				( void ) xTaskResumeAll();
    30fe:	0c 15       	cp	r16, r12
    3100:	1d 05       	cpc	r17, r13
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3102:	80 f1       	brcs	.+96     	; 0x3164 <prvTimerTask+0xa4>
    3104:	ab dc       	rcall	.-1706   	; 0x2a5c <xTaskResumeAll>
    3106:	e0 91 a2 22 	lds	r30, 0x22A2	; 0x8022a2 <pxCurrentTimerList>
    310a:	f0 91 a3 22 	lds	r31, 0x22A3	; 0x8022a3 <pxCurrentTimerList+0x1>
    310e:	05 80       	ldd	r0, Z+5	; 0x05
    3110:	f6 81       	ldd	r31, Z+6	; 0x06
    3112:	e0 2d       	mov	r30, r0

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3114:	86 80       	ldd	r8, Z+6	; 0x06
    3116:	97 80       	ldd	r9, Z+7	; 0x07
    3118:	c4 01       	movw	r24, r8
    311a:	02 96       	adiw	r24, 0x02	; 2
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    311c:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <uxListRemove>
    3120:	d4 01       	movw	r26, r8
    3122:	1e 96       	adiw	r26, 0x0e	; 14
    3124:	8c 91       	ld	r24, X
    3126:	1e 97       	sbiw	r26, 0x0e	; 14
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3128:	81 30       	cpi	r24, 0x01	; 1
    312a:	a1 f4       	brne	.+40     	; 0x3154 <prvTimerTask+0x94>
    312c:	1c 96       	adiw	r26, 0x0c	; 12
    312e:	6d 91       	ld	r22, X+
    3130:	7c 91       	ld	r23, X
    3132:	1d 97       	sbiw	r26, 0x0d	; 13
    3134:	6c 0d       	add	r22, r12
    3136:	7d 1d       	adc	r23, r13
    3138:	96 01       	movw	r18, r12
    313a:	a8 01       	movw	r20, r16
    313c:	c4 01       	movw	r24, r8
    313e:	5b de       	rcall	.-842    	; 0x2df6 <prvInsertTimerInActiveList>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3140:	81 30       	cpi	r24, 0x01	; 1
    3142:	41 f4       	brne	.+16     	; 0x3154 <prvTimerTask+0x94>
    3144:	00 e0       	ldi	r16, 0x00	; 0
    3146:	10 e0       	ldi	r17, 0x00	; 0
    3148:	20 e0       	ldi	r18, 0x00	; 0
    314a:	30 e0       	ldi	r19, 0x00	; 0
    314c:	a6 01       	movw	r20, r12
    314e:	60 e0       	ldi	r22, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    3150:	c4 01       	movw	r24, r8
    3152:	06 df       	rcall	.-500    	; 0x2f60 <xTimerGenericCommand>
    3154:	d4 01       	movw	r26, r8
    3156:	51 96       	adiw	r26, 0x11	; 17
    3158:	ed 91       	ld	r30, X+
    315a:	fc 91       	ld	r31, X
    315c:	52 97       	sbiw	r26, 0x12	; 18
    315e:	c4 01       	movw	r24, r8
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3160:	19 95       	eicall
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3162:	6a c0       	rjmp	.+212    	; 0x3238 <prvTimerTask+0x178>
    3164:	40 e0       	ldi	r20, 0x00	; 0
    3166:	b6 01       	movw	r22, r12
    3168:	60 1b       	sub	r22, r16
    316a:	71 0b       	sbc	r23, r17
    316c:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xTimerQueue>

				if( xTaskResumeAll() == pdFALSE )
    3170:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xTimerQueue+0x1>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3174:	05 da       	rcall	.-3062   	; 0x2580 <vQueueWaitForMessageRestricted>
    3176:	72 dc       	rcall	.-1820   	; 0x2a5c <xTaskResumeAll>
    3178:	81 11       	cpse	r24, r1
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    317a:	5e c0       	rjmp	.+188    	; 0x3238 <prvTimerTask+0x178>
    317c:	0e 94 8b 0f 	call	0x1f16	; 0x1f16 <vPortYield>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3180:	5b c0       	rjmp	.+182    	; 0x3238 <prvTimerTask+0x178>
    3182:	6c dc       	rcall	.-1832   	; 0x2a5c <xTaskResumeAll>
    3184:	59 c0       	rjmp	.+178    	; 0x3238 <prvTimerTask+0x178>
    3186:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    3188:	88 23       	and	r24, r24
    318a:	0c f4       	brge	.+2      	; 0x318e <prvTimerTask+0xce>

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    318c:	55 c0       	rjmp	.+170    	; 0x3238 <prvTimerTask+0x178>
    318e:	cc 80       	ldd	r12, Y+4	; 0x04
    3190:	dd 80       	ldd	r13, Y+5	; 0x05
    3192:	f6 01       	movw	r30, r12
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3194:	82 85       	ldd	r24, Z+10	; 0x0a
    3196:	93 85       	ldd	r25, Z+11	; 0x0b
    3198:	89 2b       	or	r24, r25
    319a:	21 f0       	breq	.+8      	; 0x31a4 <prvTimerTask+0xe4>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    319c:	c6 01       	movw	r24, r12
    319e:	02 96       	adiw	r24, 0x02	; 2
    31a0:	0e 94 a9 0e 	call	0x1d52	; 0x1d52 <uxListRemove>
    31a4:	ce 01       	movw	r24, r28

			switch( xMessage.xMessageID )
    31a6:	06 96       	adiw	r24, 0x06	; 6
    31a8:	1d df       	rcall	.-454    	; 0x2fe4 <prvSampleTimeNow>
    31aa:	ac 01       	movw	r20, r24
    31ac:	89 81       	ldd	r24, Y+1	; 0x01
    31ae:	08 2e       	mov	r0, r24
    31b0:	00 0c       	add	r0, r0
    31b2:	99 0b       	sbc	r25, r25
    31b4:	aa 0b       	sbc	r26, r26
    31b6:	bb 0b       	sbc	r27, r27
    31b8:	8a 30       	cpi	r24, 0x0A	; 10
    31ba:	91 05       	cpc	r25, r1
    31bc:	08 f0       	brcs	.+2      	; 0x31c0 <prvTimerTask+0x100>
    31be:	3c c0       	rjmp	.+120    	; 0x3238 <prvTimerTask+0x178>
    31c0:	fc 01       	movw	r30, r24
    31c2:	88 27       	eor	r24, r24
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    31c4:	e2 50       	subi	r30, 0x02	; 2
    31c6:	ff 4f       	sbci	r31, 0xFF	; 255
    31c8:	8f 4f       	sbci	r24, 0xFF	; 255
    31ca:	7b c3       	rjmp	.+1782   	; 0x38c2 <__tablejump2__>
    31cc:	2a 81       	ldd	r18, Y+2	; 0x02
    31ce:	3b 81       	ldd	r19, Y+3	; 0x03
    31d0:	d6 01       	movw	r26, r12
    31d2:	1c 96       	adiw	r26, 0x0c	; 12
    31d4:	6d 91       	ld	r22, X+
    31d6:	7c 91       	ld	r23, X
    31d8:	1d 97       	sbiw	r26, 0x0d	; 13
    31da:	62 0f       	add	r22, r18
    31dc:	73 1f       	adc	r23, r19
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    31de:	c6 01       	movw	r24, r12
    31e0:	0a de       	rcall	.-1004   	; 0x2df6 <prvInsertTimerInActiveList>
    31e2:	81 30       	cpi	r24, 0x01	; 1
    31e4:	49 f5       	brne	.+82     	; 0x3238 <prvTimerTask+0x178>
    31e6:	d6 01       	movw	r26, r12
    31e8:	51 96       	adiw	r26, 0x11	; 17
    31ea:	ed 91       	ld	r30, X+
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    31ec:	fc 91       	ld	r31, X
    31ee:	52 97       	sbiw	r26, 0x12	; 18
    31f0:	c6 01       	movw	r24, r12
    31f2:	19 95       	eicall
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    31f4:	f6 01       	movw	r30, r12
    31f6:	86 85       	ldd	r24, Z+14	; 0x0e
    31f8:	81 30       	cpi	r24, 0x01	; 1
    31fa:	f1 f4       	brne	.+60     	; 0x3238 <prvTimerTask+0x178>
    31fc:	4a 81       	ldd	r20, Y+2	; 0x02
    31fe:	5b 81       	ldd	r21, Y+3	; 0x03
    3200:	84 85       	ldd	r24, Z+12	; 0x0c
    3202:	95 85       	ldd	r25, Z+13	; 0x0d
    3204:	48 0f       	add	r20, r24
    3206:	59 1f       	adc	r21, r25
    3208:	00 e0       	ldi	r16, 0x00	; 0
    320a:	10 e0       	ldi	r17, 0x00	; 0
    320c:	20 e0       	ldi	r18, 0x00	; 0
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    320e:	30 e0       	ldi	r19, 0x00	; 0
    3210:	60 e0       	ldi	r22, 0x00	; 0
    3212:	c6 01       	movw	r24, r12
    3214:	a5 de       	rcall	.-694    	; 0x2f60 <xTimerGenericCommand>
    3216:	10 c0       	rjmp	.+32     	; 0x3238 <prvTimerTask+0x178>
    3218:	6a 81       	ldd	r22, Y+2	; 0x02
    321a:	7b 81       	ldd	r23, Y+3	; 0x03
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    321c:	d6 01       	movw	r26, r12
    321e:	1c 96       	adiw	r26, 0x0c	; 12
    3220:	6d 93       	st	X+, r22
    3222:	7c 93       	st	X, r23
    3224:	1d 97       	sbiw	r26, 0x0d	; 13
    3226:	64 0f       	add	r22, r20
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    3228:	75 1f       	adc	r23, r21
    322a:	9a 01       	movw	r18, r20
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    322c:	c6 01       	movw	r24, r12
    322e:	e3 dd       	rcall	.-1082   	; 0x2df6 <prvInsertTimerInActiveList>
    3230:	03 c0       	rjmp	.+6      	; 0x3238 <prvTimerTask+0x178>
    3232:	c6 01       	movw	r24, r12
    3234:	0e 94 4a 10 	call	0x2094	; 0x2094 <vPortFree>
    3238:	20 e0       	ldi	r18, 0x00	; 0
    323a:	40 e0       	ldi	r20, 0x00	; 0
    323c:	50 e0       	ldi	r21, 0x00	; 0
    323e:	6e 2d       	mov	r22, r14
    3240:	7f 2d       	mov	r23, r15
    3242:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xTimerQueue>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3246:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xTimerQueue+0x1>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    324a:	03 d9       	rcall	.-3578   	; 0x2452 <xQueueGenericReceive>
    324c:	81 11       	cpse	r24, r1
    324e:	9b cf       	rjmp	.-202    	; 0x3186 <prvTimerTask+0xc6>
		if( xTimerListsWereSwitched == pdFALSE )
    3250:	42 cf       	rjmp	.-380    	; 0x30d6 <prvTimerTask+0x16>
    3252:	21 db       	rcall	.-2494   	; 0x2896 <vTaskSuspendAll>
    3254:	c5 01       	movw	r24, r10
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3256:	c6 de       	rcall	.-628    	; 0x2fe4 <prvSampleTimeNow>
    3258:	8c 01       	movw	r16, r24
    325a:	89 81       	ldd	r24, Y+1	; 0x01
    325c:	81 11       	cpse	r24, r1
    325e:	91 cf       	rjmp	.-222    	; 0x3182 <prvTimerTask+0xc2>
    3260:	e0 91 a0 22 	lds	r30, 0x22A0	; 0x8022a0 <pxOverflowTimerList>
    3264:	f0 91 a1 22 	lds	r31, 0x22A1	; 0x8022a1 <pxOverflowTimerList+0x1>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    3268:	41 e0       	ldi	r20, 0x01	; 1
    326a:	80 81       	ld	r24, Z
    326c:	81 11       	cpse	r24, r1
    326e:	40 e0       	ldi	r20, 0x00	; 0
    3270:	c1 2c       	mov	r12, r1
    3272:	d1 2c       	mov	r13, r1
    3274:	78 cf       	rjmp	.-272    	; 0x3166 <prvTimerTask+0xa6>

00003276 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    3276:	cf 93       	push	r28
    3278:	df 93       	push	r29
    327a:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    327c:	20 e0       	ldi	r18, 0x00	; 0
    327e:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    3280:	c6 2f       	mov	r28, r22
    3282:	d0 e0       	ldi	r29, 0x00	; 0
    3284:	de 01       	movw	r26, r28
    3286:	02 2e       	mov	r0, r18
    3288:	02 c0       	rjmp	.+4      	; 0x328e <ioport_configure_port_pin+0x18>
    328a:	b5 95       	asr	r27
    328c:	a7 95       	ror	r26
    328e:	0a 94       	dec	r0
    3290:	e2 f7       	brpl	.-8      	; 0x328a <ioport_configure_port_pin+0x14>
    3292:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    3294:	50 8b       	std	Z+16, r21	; 0x10
    3296:	2f 5f       	subi	r18, 0xFF	; 255
    3298:	3f 4f       	sbci	r19, 0xFF	; 255
    329a:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    329c:	28 30       	cpi	r18, 0x08	; 8
    329e:	31 05       	cpc	r19, r1
    32a0:	89 f7       	brne	.-30     	; 0x3284 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    32a2:	40 ff       	sbrs	r20, 0
    32a4:	0a c0       	rjmp	.+20     	; 0x32ba <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    32a6:	41 ff       	sbrs	r20, 1
    32a8:	03 c0       	rjmp	.+6      	; 0x32b0 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    32aa:	fc 01       	movw	r30, r24
    32ac:	65 83       	std	Z+5, r22	; 0x05
    32ae:	02 c0       	rjmp	.+4      	; 0x32b4 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    32b0:	fc 01       	movw	r30, r24
    32b2:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    32b4:	fc 01       	movw	r30, r24
    32b6:	61 83       	std	Z+1, r22	; 0x01
    32b8:	02 c0       	rjmp	.+4      	; 0x32be <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    32ba:	fc 01       	movw	r30, r24
    32bc:	62 83       	std	Z+2, r22	; 0x02
	}
}
    32be:	df 91       	pop	r29
    32c0:	cf 91       	pop	r28
    32c2:	08 95       	ret

000032c4 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    32c4:	43 e0       	ldi	r20, 0x03	; 3
    32c6:	50 e0       	ldi	r21, 0x00	; 0
    32c8:	61 e0       	ldi	r22, 0x01	; 1
    32ca:	80 ee       	ldi	r24, 0xE0	; 224
    32cc:	97 e0       	ldi	r25, 0x07	; 7
    32ce:	d3 df       	rcall	.-90     	; 0x3276 <ioport_configure_port_pin>
    32d0:	43 e0       	ldi	r20, 0x03	; 3
    32d2:	50 e0       	ldi	r21, 0x00	; 0
    32d4:	62 e0       	ldi	r22, 0x02	; 2
    32d6:	80 ee       	ldi	r24, 0xE0	; 224
    32d8:	97 e0       	ldi	r25, 0x07	; 7
    32da:	cd df       	rcall	.-102    	; 0x3276 <ioport_configure_port_pin>
    32dc:	43 e0       	ldi	r20, 0x03	; 3
    32de:	50 e0       	ldi	r21, 0x00	; 0
    32e0:	60 e1       	ldi	r22, 0x10	; 16
    32e2:	80 e6       	ldi	r24, 0x60	; 96
    32e4:	96 e0       	ldi	r25, 0x06	; 6
    32e6:	c7 df       	rcall	.-114    	; 0x3276 <ioport_configure_port_pin>
    32e8:	41 e0       	ldi	r20, 0x01	; 1
    32ea:	50 e4       	ldi	r21, 0x40	; 64
    32ec:	60 e2       	ldi	r22, 0x20	; 32
    32ee:	80 e6       	ldi	r24, 0x60	; 96
    32f0:	96 e0       	ldi	r25, 0x06	; 6
    32f2:	c1 df       	rcall	.-126    	; 0x3276 <ioport_configure_port_pin>
    32f4:	40 e0       	ldi	r20, 0x00	; 0
    32f6:	5b e1       	ldi	r21, 0x1B	; 27
    32f8:	60 e2       	ldi	r22, 0x20	; 32
    32fa:	80 e8       	ldi	r24, 0x80	; 128
    32fc:	96 e0       	ldi	r25, 0x06	; 6
    32fe:	bb df       	rcall	.-138    	; 0x3276 <ioport_configure_port_pin>
    3300:	40 e0       	ldi	r20, 0x00	; 0
    3302:	5b e1       	ldi	r21, 0x1B	; 27
    3304:	62 e0       	ldi	r22, 0x02	; 2
    3306:	80 ea       	ldi	r24, 0xA0	; 160
    3308:	96 e0       	ldi	r25, 0x06	; 6
    330a:	b5 df       	rcall	.-150    	; 0x3276 <ioport_configure_port_pin>
    330c:	40 e0       	ldi	r20, 0x00	; 0
    330e:	5b e1       	ldi	r21, 0x1B	; 27
    3310:	64 e0       	ldi	r22, 0x04	; 4
    3312:	80 ea       	ldi	r24, 0xA0	; 160
    3314:	96 e0       	ldi	r25, 0x06	; 6
    3316:	af df       	rcall	.-162    	; 0x3276 <ioport_configure_port_pin>
    3318:	43 e0       	ldi	r20, 0x03	; 3
    331a:	50 e0       	ldi	r21, 0x00	; 0
    331c:	62 e0       	ldi	r22, 0x02	; 2
    331e:	80 e6       	ldi	r24, 0x60	; 96
    3320:	96 e0       	ldi	r25, 0x06	; 6
    3322:	a9 df       	rcall	.-174    	; 0x3276 <ioport_configure_port_pin>
    3324:	43 e0       	ldi	r20, 0x03	; 3
    3326:	50 e0       	ldi	r21, 0x00	; 0
    3328:	68 e0       	ldi	r22, 0x08	; 8
    332a:	80 e6       	ldi	r24, 0x60	; 96
    332c:	96 e0       	ldi	r25, 0x06	; 6
    332e:	a3 df       	rcall	.-186    	; 0x3276 <ioport_configure_port_pin>
    3330:	43 e0       	ldi	r20, 0x03	; 3
    3332:	50 e0       	ldi	r21, 0x00	; 0
    3334:	68 e0       	ldi	r22, 0x08	; 8
    3336:	80 ea       	ldi	r24, 0xA0	; 160
    3338:	96 e0       	ldi	r25, 0x06	; 6
    333a:	9d df       	rcall	.-198    	; 0x3276 <ioport_configure_port_pin>
    333c:	43 e0       	ldi	r20, 0x03	; 3
    333e:	50 e0       	ldi	r21, 0x00	; 0
    3340:	61 e0       	ldi	r22, 0x01	; 1
    3342:	80 e6       	ldi	r24, 0x60	; 96
    3344:	96 e0       	ldi	r25, 0x06	; 6
    3346:	97 df       	rcall	.-210    	; 0x3276 <ioport_configure_port_pin>
    3348:	43 e0       	ldi	r20, 0x03	; 3
    334a:	50 e0       	ldi	r21, 0x00	; 0
    334c:	68 e0       	ldi	r22, 0x08	; 8
    334e:	80 e0       	ldi	r24, 0x00	; 0
    3350:	96 e0       	ldi	r25, 0x06	; 6
    3352:	91 df       	rcall	.-222    	; 0x3276 <ioport_configure_port_pin>
    3354:	41 e0       	ldi	r20, 0x01	; 1
    3356:	50 e0       	ldi	r21, 0x00	; 0
    3358:	60 e1       	ldi	r22, 0x10	; 16
    335a:	80 e8       	ldi	r24, 0x80	; 128
    335c:	96 e0       	ldi	r25, 0x06	; 6
    335e:	8b df       	rcall	.-234    	; 0x3276 <ioport_configure_port_pin>
    3360:	43 e0       	ldi	r20, 0x03	; 3
    3362:	50 e0       	ldi	r21, 0x00	; 0
    3364:	62 e0       	ldi	r22, 0x02	; 2
    3366:	80 e6       	ldi	r24, 0x60	; 96
    3368:	96 e0       	ldi	r25, 0x06	; 6
    336a:	85 df       	rcall	.-246    	; 0x3276 <ioport_configure_port_pin>
    336c:	43 e0       	ldi	r20, 0x03	; 3
    336e:	50 e0       	ldi	r21, 0x00	; 0
    3370:	68 e0       	ldi	r22, 0x08	; 8
    3372:	80 e6       	ldi	r24, 0x60	; 96
    3374:	96 e0       	ldi	r25, 0x06	; 6
    3376:	7f df       	rcall	.-258    	; 0x3276 <ioport_configure_port_pin>
    3378:	40 e0       	ldi	r20, 0x00	; 0
    337a:	50 e0       	ldi	r21, 0x00	; 0
    337c:	64 e0       	ldi	r22, 0x04	; 4
    337e:	80 e6       	ldi	r24, 0x60	; 96
    3380:	96 e0       	ldi	r25, 0x06	; 6
    3382:	79 df       	rcall	.-270    	; 0x3276 <ioport_configure_port_pin>
    3384:	43 e0       	ldi	r20, 0x03	; 3
    3386:	50 e0       	ldi	r21, 0x00	; 0
    3388:	60 e1       	ldi	r22, 0x10	; 16
    338a:	80 ea       	ldi	r24, 0xA0	; 160
    338c:	96 e0       	ldi	r25, 0x06	; 6
    338e:	73 df       	rcall	.-282    	; 0x3276 <ioport_configure_port_pin>
    3390:	40 e0       	ldi	r20, 0x00	; 0
    3392:	50 e0       	ldi	r21, 0x00	; 0
    3394:	61 e0       	ldi	r22, 0x01	; 1
    3396:	80 e0       	ldi	r24, 0x00	; 0
    3398:	96 e0       	ldi	r25, 0x06	; 6
    339a:	6d df       	rcall	.-294    	; 0x3276 <ioport_configure_port_pin>
    339c:	40 e0       	ldi	r20, 0x00	; 0
    339e:	50 e0       	ldi	r21, 0x00	; 0
    33a0:	64 e0       	ldi	r22, 0x04	; 4
    33a2:	80 e0       	ldi	r24, 0x00	; 0
    33a4:	96 e0       	ldi	r25, 0x06	; 6
    33a6:	67 df       	rcall	.-306    	; 0x3276 <ioport_configure_port_pin>
    33a8:	40 e0       	ldi	r20, 0x00	; 0
    33aa:	50 e0       	ldi	r21, 0x00	; 0
    33ac:	62 e0       	ldi	r22, 0x02	; 2
    33ae:	80 e2       	ldi	r24, 0x20	; 32
    33b0:	96 e0       	ldi	r25, 0x06	; 6
    33b2:	61 df       	rcall	.-318    	; 0x3276 <ioport_configure_port_pin>
    33b4:	43 e0       	ldi	r20, 0x03	; 3
    33b6:	50 e0       	ldi	r21, 0x00	; 0
    33b8:	68 e0       	ldi	r22, 0x08	; 8
    33ba:	80 e4       	ldi	r24, 0x40	; 64
    33bc:	96 e0       	ldi	r25, 0x06	; 6
    33be:	5b df       	rcall	.-330    	; 0x3276 <ioport_configure_port_pin>
    33c0:	40 e0       	ldi	r20, 0x00	; 0
    33c2:	50 e0       	ldi	r21, 0x00	; 0
    33c4:	64 e0       	ldi	r22, 0x04	; 4
    33c6:	80 e4       	ldi	r24, 0x40	; 64
    33c8:	96 e0       	ldi	r25, 0x06	; 6
    33ca:	55 df       	rcall	.-342    	; 0x3276 <ioport_configure_port_pin>
    33cc:	43 e0       	ldi	r20, 0x03	; 3
    33ce:	50 e0       	ldi	r21, 0x00	; 0
    33d0:	68 e0       	ldi	r22, 0x08	; 8
    33d2:	80 e6       	ldi	r24, 0x60	; 96
    33d4:	96 e0       	ldi	r25, 0x06	; 6
    33d6:	4f df       	rcall	.-354    	; 0x3276 <ioport_configure_port_pin>
    33d8:	40 e0       	ldi	r20, 0x00	; 0
    33da:	50 e0       	ldi	r21, 0x00	; 0
    33dc:	64 e0       	ldi	r22, 0x04	; 4
    33de:	80 e6       	ldi	r24, 0x60	; 96
    33e0:	96 e0       	ldi	r25, 0x06	; 6
    33e2:	49 df       	rcall	.-366    	; 0x3276 <ioport_configure_port_pin>
    33e4:	43 e0       	ldi	r20, 0x03	; 3
    33e6:	50 e0       	ldi	r21, 0x00	; 0
    33e8:	68 e0       	ldi	r22, 0x08	; 8
    33ea:	80 e8       	ldi	r24, 0x80	; 128
    33ec:	96 e0       	ldi	r25, 0x06	; 6
    33ee:	43 df       	rcall	.-378    	; 0x3276 <ioport_configure_port_pin>
    33f0:	40 e0       	ldi	r20, 0x00	; 0
    33f2:	50 e0       	ldi	r21, 0x00	; 0
    33f4:	64 e0       	ldi	r22, 0x04	; 4
    33f6:	80 e8       	ldi	r24, 0x80	; 128
    33f8:	96 e0       	ldi	r25, 0x06	; 6
    33fa:	3d cf       	rjmp	.-390    	; 0x3276 <ioport_configure_port_pin>
    33fc:	08 95       	ret

000033fe <vTimerCallback>:
		//gpio_set_pin_high(J2_PIN0);
		orang++;
		//}else{
		//gpio_set_pin_low(J2_PIN0);
	}
}
    33fe:	80 91 81 23 	lds	r24, 0x2381	; 0x802381 <increment>
    3402:	90 91 82 23 	lds	r25, 0x2382	; 0x802382 <increment+0x1>
    3406:	a0 91 83 23 	lds	r26, 0x2383	; 0x802383 <increment+0x2>
    340a:	b0 91 84 23 	lds	r27, 0x2384	; 0x802384 <increment+0x3>
    340e:	01 96       	adiw	r24, 0x01	; 1
    3410:	a1 1d       	adc	r26, r1
    3412:	b1 1d       	adc	r27, r1
    3414:	80 93 81 23 	sts	0x2381, r24	; 0x802381 <increment>
    3418:	90 93 82 23 	sts	0x2382, r25	; 0x802382 <increment+0x1>
    341c:	a0 93 83 23 	sts	0x2383, r26	; 0x802383 <increment+0x2>
    3420:	b0 93 84 23 	sts	0x2384, r27	; 0x802384 <increment+0x3>
    3424:	08 95       	ret

00003426 <testLamp>:
    3426:	00 ee       	ldi	r16, 0xE0	; 224
    3428:	17 e0       	ldi	r17, 0x07	; 7
    342a:	c1 e0       	ldi	r28, 0x01	; 1
    342c:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <orang>
    3430:	90 91 b7 22 	lds	r25, 0x22B7	; 0x8022b7 <orang+0x1>
    3434:	0a 97       	sbiw	r24, 0x0a	; 10
    3436:	5c f0       	brlt	.+22     	; 0x344e <testLamp+0x28>
    3438:	f8 01       	movw	r30, r16
    343a:	c6 83       	std	Z+6, r28	; 0x06
    343c:	84 ec       	ldi	r24, 0xC4	; 196
    343e:	99 e0       	ldi	r25, 0x09	; 9
    3440:	8a db       	rcall	.-2284   	; 0x2b56 <vTaskDelay>
    3442:	f8 01       	movw	r30, r16
    3444:	c5 83       	std	Z+5, r28	; 0x05
    3446:	10 92 b6 22 	sts	0x22B6, r1	; 0x8022b6 <orang>
    344a:	10 92 b7 22 	sts	0x22B7, r1	; 0x8022b7 <orang+0x1>
    344e:	82 e0       	ldi	r24, 0x02	; 2
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	81 db       	rcall	.-2302   	; 0x2b56 <vTaskDelay>
    3454:	eb cf       	rjmp	.-42     	; 0x342c <testLamp+0x6>

00003456 <testPot>:
    3456:	c0 e0       	ldi	r28, 0x00	; 0
    3458:	d2 e0       	ldi	r29, 0x02	; 2
    345a:	68 94       	set
    345c:	ff 24       	eor	r15, r15
    345e:	f2 f8       	bld	r15, 2
    3460:	00 e3       	ldi	r16, 0x30	; 48
    3462:	12 e0       	ldi	r17, 0x02	; 2
    3464:	ce 01       	movw	r24, r28
    3466:	0e 94 59 07 	call	0xeb2	; 0xeb2 <adc_enable>
    346a:	9f b7       	in	r25, 0x3f	; 63
    346c:	f8 94       	cli
    346e:	88 81       	ld	r24, Y
    3470:	80 61       	ori	r24, 0x10	; 16
    3472:	88 83       	st	Y, r24
    3474:	9f bf       	out	0x3f, r25	; 63
    3476:	8e 81       	ldd	r24, Y+6	; 0x06
    3478:	82 ff       	sbrs	r24, 2
    347a:	fd cf       	rjmp	.-6      	; 0x3476 <testPot+0x20>
    347c:	fe 82       	std	Y+6, r15	; 0x06
    347e:	f8 01       	movw	r30, r16
    3480:	84 81       	ldd	r24, Z+4	; 0x04
    3482:	95 81       	ldd	r25, Z+5	; 0x05
    3484:	80 93 85 23 	sts	0x2385, r24	; 0x802385 <result3>
    3488:	90 93 86 23 	sts	0x2386, r25	; 0x802386 <result3+0x1>
    348c:	85 e0       	ldi	r24, 0x05	; 5
    348e:	90 e0       	ldi	r25, 0x00	; 0
    3490:	62 db       	rcall	.-2364   	; 0x2b56 <vTaskDelay>
    3492:	e8 cf       	rjmp	.-48     	; 0x3464 <testPot+0xe>

00003494 <testTempS>:
    3494:	c0 e0       	ldi	r28, 0x00	; 0
    3496:	d2 e0       	ldi	r29, 0x02	; 2
    3498:	68 94       	set
    349a:	ff 24       	eor	r15, r15
    349c:	f1 f8       	bld	r15, 1
    349e:	08 e2       	ldi	r16, 0x28	; 40
    34a0:	12 e0       	ldi	r17, 0x02	; 2
    34a2:	ce 01       	movw	r24, r28
    34a4:	0e 94 59 07 	call	0xeb2	; 0xeb2 <adc_enable>
    34a8:	9f b7       	in	r25, 0x3f	; 63
    34aa:	f8 94       	cli
    34ac:	88 81       	ld	r24, Y
    34ae:	88 60       	ori	r24, 0x08	; 8
    34b0:	88 83       	st	Y, r24
    34b2:	9f bf       	out	0x3f, r25	; 63
    34b4:	8e 81       	ldd	r24, Y+6	; 0x06
    34b6:	81 ff       	sbrs	r24, 1
    34b8:	fd cf       	rjmp	.-6      	; 0x34b4 <testTempS+0x20>
    34ba:	fe 82       	std	Y+6, r15	; 0x06
    34bc:	f8 01       	movw	r30, r16
    34be:	84 81       	ldd	r24, Z+4	; 0x04
    34c0:	95 81       	ldd	r25, Z+5	; 0x05
    34c2:	80 93 87 23 	sts	0x2387, r24	; 0x802387 <result2>
    34c6:	90 93 88 23 	sts	0x2388, r25	; 0x802388 <result2+0x1>
    34ca:	85 e0       	ldi	r24, 0x05	; 5
    34cc:	90 e0       	ldi	r25, 0x00	; 0
    34ce:	43 db       	rcall	.-2426   	; 0x2b56 <vTaskDelay>
    34d0:	e8 cf       	rjmp	.-48     	; 0x34a2 <testTempS+0xe>

000034d2 <adc_read>:
    34d2:	80 e0       	ldi	r24, 0x00	; 0
    34d4:	92 e0       	ldi	r25, 0x02	; 2
    34d6:	0e 94 59 07 	call	0xeb2	; 0xeb2 <adc_enable>
    34da:	9f b7       	in	r25, 0x3f	; 63
    34dc:	f8 94       	cli
    34de:	e0 e0       	ldi	r30, 0x00	; 0
    34e0:	f2 e0       	ldi	r31, 0x02	; 2
    34e2:	80 81       	ld	r24, Z
    34e4:	84 60       	ori	r24, 0x04	; 4
    34e6:	80 83       	st	Z, r24
    34e8:	9f bf       	out	0x3f, r25	; 63
    34ea:	86 81       	ldd	r24, Z+6	; 0x06
    34ec:	80 ff       	sbrs	r24, 0
    34ee:	fd cf       	rjmp	.-6      	; 0x34ea <adc_read+0x18>
    34f0:	e0 e0       	ldi	r30, 0x00	; 0
    34f2:	f2 e0       	ldi	r31, 0x02	; 2
    34f4:	81 e0       	ldi	r24, 0x01	; 1
    34f6:	86 83       	std	Z+6, r24	; 0x06
    34f8:	84 a1       	ldd	r24, Z+36	; 0x24
    34fa:	95 a1       	ldd	r25, Z+37	; 0x25
    34fc:	08 95       	ret

000034fe <testLightS>:
    34fe:	e9 df       	rcall	.-46     	; 0x34d2 <adc_read>
    3500:	80 93 89 23 	sts	0x2389, r24	; 0x802389 <result>
    3504:	90 93 8a 23 	sts	0x238A, r25	; 0x80238a <result+0x1>
    3508:	85 e0       	ldi	r24, 0x05	; 5
    350a:	90 e0       	ldi	r25, 0x00	; 0
    350c:	24 db       	rcall	.-2488   	; 0x2b56 <vTaskDelay>
    350e:	f7 cf       	rjmp	.-18     	; 0x34fe <testLightS>

00003510 <receivePing>:
    3510:	e0 df       	rcall	.-64     	; 0x34d2 <adc_read>
    3512:	80 93 89 23 	sts	0x2389, r24	; 0x802389 <result>
    3516:	90 93 8a 23 	sts	0x238A, r25	; 0x80238a <result+0x1>
    351a:	85 e0       	ldi	r24, 0x05	; 5
    351c:	90 e0       	ldi	r25, 0x00	; 0
    351e:	1b db       	rcall	.-2506   	; 0x2b56 <vTaskDelay>
    3520:	f7 cf       	rjmp	.-18     	; 0x3510 <receivePing>

00003522 <testLCD>:
    3522:	80 e1       	ldi	r24, 0x10	; 16
    3524:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    3528:	01 e2       	ldi	r16, 0x21	; 33
    352a:	10 e2       	ldi	r17, 0x20	; 32
    352c:	0f 2e       	mov	r0, r31
    352e:	f9 ec       	ldi	r31, 0xC9	; 201
    3530:	ff 2e       	mov	r15, r31
    3532:	f0 2d       	mov	r31, r0
    3534:	c8 eb       	ldi	r28, 0xB8	; 184
    3536:	d2 e2       	ldi	r29, 0x22	; 34
    3538:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <orang+0x1>
    353c:	8f 93       	push	r24
    353e:	80 91 b6 22 	lds	r24, 0x22B6	; 0x8022b6 <orang>
    3542:	8f 93       	push	r24
    3544:	1f 93       	push	r17
    3546:	0f 93       	push	r16
    3548:	1f 92       	push	r1
    354a:	ff 92       	push	r15
    354c:	df 93       	push	r29
    354e:	cf 93       	push	r28
    3550:	ea d2       	rcall	.+1492   	; 0x3b26 <snprintf>
    3552:	26 e0       	ldi	r18, 0x06	; 6
    3554:	30 e2       	ldi	r19, 0x20	; 32
    3556:	40 e0       	ldi	r20, 0x00	; 0
    3558:	60 e0       	ldi	r22, 0x00	; 0
    355a:	ce 01       	movw	r24, r28
    355c:	0e 94 7f 06 	call	0xcfe	; 0xcfe <gfx_mono_draw_string>
    3560:	82 e0       	ldi	r24, 0x02	; 2
    3562:	90 e0       	ldi	r25, 0x00	; 0
    3564:	f8 da       	rcall	.-2576   	; 0x2b56 <vTaskDelay>
    3566:	8d b7       	in	r24, 0x3d	; 61
    3568:	9e b7       	in	r25, 0x3e	; 62
    356a:	08 96       	adiw	r24, 0x08	; 8
    356c:	8d bf       	out	0x3d, r24	; 61
    356e:	9e bf       	out	0x3e, r25	; 62
    3570:	e3 cf       	rjmp	.-58     	; 0x3538 <testLCD+0x16>

00003572 <PWM_Init>:
    3572:	e0 e4       	ldi	r30, 0x40	; 64
    3574:	f6 e0       	ldi	r31, 0x06	; 6
    3576:	80 81       	ld	r24, Z
    3578:	81 60       	ori	r24, 0x01	; 1
    357a:	80 83       	st	Z, r24
    357c:	e0 e0       	ldi	r30, 0x00	; 0
    357e:	f8 e0       	ldi	r31, 0x08	; 8
    3580:	85 e0       	ldi	r24, 0x05	; 5
    3582:	80 83       	st	Z, r24
    3584:	86 e1       	ldi	r24, 0x16	; 22
    3586:	81 83       	std	Z+1, r24	; 0x01
    3588:	88 ee       	ldi	r24, 0xE8	; 232
    358a:	93 e0       	ldi	r25, 0x03	; 3
    358c:	86 a3       	std	Z+38, r24	; 0x26
    358e:	97 a3       	std	Z+39, r25	; 0x27
    3590:	87 e7       	ldi	r24, 0x77	; 119
    3592:	91 e0       	ldi	r25, 0x01	; 1
    3594:	80 a7       	std	Z+40, r24	; 0x28
    3596:	91 a7       	std	Z+41, r25	; 0x29
    3598:	08 95       	ret

0000359a <testServo>:
    359a:	eb df       	rcall	.-42     	; 0x3572 <PWM_Init>
    359c:	e0 ea       	ldi	r30, 0xA0	; 160
    359e:	f6 e0       	ldi	r31, 0x06	; 6
    35a0:	c0 e0       	ldi	r28, 0x00	; 0
    35a2:	d8 e0       	ldi	r29, 0x08	; 8
    35a4:	6e e5       	ldi	r22, 0x5E	; 94
    35a6:	71 e0       	ldi	r23, 0x01	; 1
    35a8:	a0 e6       	ldi	r26, 0x60	; 96
    35aa:	b6 e0       	ldi	r27, 0x06	; 6
    35ac:	10 e2       	ldi	r17, 0x20	; 32
    35ae:	90 e1       	ldi	r25, 0x10	; 16
    35b0:	41 e0       	ldi	r20, 0x01	; 1
    35b2:	50 e0       	ldi	r21, 0x00	; 0
    35b4:	22 e8       	ldi	r18, 0x82	; 130
    35b6:	30 e0       	ldi	r19, 0x00	; 0
    35b8:	80 85       	ldd	r24, Z+8	; 0x08
    35ba:	81 fd       	sbrc	r24, 1
    35bc:	0c c0       	rjmp	.+24     	; 0x35d6 <testServo+0x3c>
    35be:	80 85       	ldd	r24, Z+8	; 0x08
    35c0:	82 ff       	sbrs	r24, 2
    35c2:	09 c0       	rjmp	.+18     	; 0x35d6 <testServo+0x3c>
    35c4:	28 a7       	std	Y+40, r18	; 0x28
    35c6:	39 a7       	std	Y+41, r19	; 0x29
    35c8:	16 96       	adiw	r26, 0x06	; 6
    35ca:	9c 93       	st	X, r25
    35cc:	16 97       	sbiw	r26, 0x06	; 6
    35ce:	15 96       	adiw	r26, 0x05	; 5
    35d0:	1c 93       	st	X, r17
    35d2:	15 97       	sbiw	r26, 0x05	; 5
    35d4:	f1 cf       	rjmp	.-30     	; 0x35b8 <testServo+0x1e>
    35d6:	80 85       	ldd	r24, Z+8	; 0x08
    35d8:	82 fd       	sbrc	r24, 2
    35da:	0c c0       	rjmp	.+24     	; 0x35f4 <testServo+0x5a>
    35dc:	80 85       	ldd	r24, Z+8	; 0x08
    35de:	81 ff       	sbrs	r24, 1
    35e0:	09 c0       	rjmp	.+18     	; 0x35f4 <testServo+0x5a>
    35e2:	48 a7       	std	Y+40, r20	; 0x28
    35e4:	59 a7       	std	Y+41, r21	; 0x29
    35e6:	16 96       	adiw	r26, 0x06	; 6
    35e8:	1c 93       	st	X, r17
    35ea:	16 97       	sbiw	r26, 0x06	; 6
    35ec:	15 96       	adiw	r26, 0x05	; 5
    35ee:	9c 93       	st	X, r25
    35f0:	15 97       	sbiw	r26, 0x05	; 5
    35f2:	e2 cf       	rjmp	.-60     	; 0x35b8 <testServo+0x1e>
    35f4:	80 85       	ldd	r24, Z+8	; 0x08
    35f6:	81 ff       	sbrs	r24, 1
    35f8:	df cf       	rjmp	.-66     	; 0x35b8 <testServo+0x1e>
    35fa:	80 85       	ldd	r24, Z+8	; 0x08
    35fc:	82 ff       	sbrs	r24, 2
    35fe:	dc cf       	rjmp	.-72     	; 0x35b8 <testServo+0x1e>
    3600:	68 a7       	std	Y+40, r22	; 0x28
    3602:	79 a7       	std	Y+41, r23	; 0x29
    3604:	15 96       	adiw	r26, 0x05	; 5
    3606:	1c 93       	st	X, r17
    3608:	15 97       	sbiw	r26, 0x05	; 5
    360a:	15 96       	adiw	r26, 0x05	; 5
    360c:	9c 93       	st	X, r25
    360e:	15 97       	sbiw	r26, 0x05	; 5
    3610:	d3 cf       	rjmp	.-90     	; 0x35b8 <testServo+0x1e>

00003612 <setUpSerial>:
    3612:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    3616:	8c e0       	ldi	r24, 0x0C	; 12
    3618:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    361c:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    3620:	83 e0       	ldi	r24, 0x03	; 3
    3622:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    3626:	88 e1       	ldi	r24, 0x18	; 24
    3628:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    362c:	08 95       	ret

0000362e <main>:
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
	return result;
}

int main (void)
{
    362e:	8f 92       	push	r8
    3630:	9f 92       	push	r9
    3632:	af 92       	push	r10
    3634:	bf 92       	push	r11
    3636:	cf 92       	push	r12
    3638:	df 92       	push	r13
    363a:	ef 92       	push	r14
    363c:	ff 92       	push	r15
    363e:	0f 93       	push	r16
    3640:	1f 93       	push	r17
    3642:	cf 93       	push	r28
    3644:	df 93       	push	r29
    3646:	cd b7       	in	r28, 0x3d	; 61
    3648:	de b7       	in	r29, 0x3e	; 62
    364a:	2b 97       	sbiw	r28, 0x0b	; 11
    364c:	cd bf       	out	0x3d, r28	; 61
	// Insert system clock initialization code here (sysclk_init()).

	
	board_init();
    364e:	de bf       	out	0x3e, r29	; 62
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    3650:	39 de       	rcall	.-910    	; 0x32c4 <board_init>
    3652:	87 e0       	ldi	r24, 0x07	; 7
    3654:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	pmic_init();
	// usart code
	sysclk_init();
    3658:	0e 94 3d 04 	call	0x87a	; 0x87a <sysclk_init>
    365c:	68 94       	set
    365e:	ee 24       	eor	r14, r14
    3660:	e4 f8       	bld	r14, 4
    3662:	e0 92 85 06 	sts	0x0685, r14	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
   
    gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
   
    PORTC_OUTSET = PIN3_bm; // PC3 as TX
    3666:	68 94       	set
    3668:	ff 24       	eor	r15, r15
    366a:	f3 f8       	bld	r15, 3
    366c:	f0 92 45 06 	sts	0x0645, r15	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    PORTC_DIRSET = PIN3_bm; //TX pin as output
    3670:	f0 92 41 06 	sts	0x0641, r15	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
   
    PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    3674:	84 e0       	ldi	r24, 0x04	; 4
    3676:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    PORTC_DIRCLR = PIN2_bm; //RX pin as input
   
    setUpSerial();
    367a:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    367e:	c9 df       	rcall	.-110    	; 0x3612 <setUpSerial>
    3680:	6d e0       	ldi	r22, 0x0D	; 13
    3682:	70 e2       	ldi	r23, 0x20	; 32
    3684:	80 ea       	ldi	r24, 0xA0	; 160
    3686:	98 e0       	ldi	r25, 0x08	; 8
    3688:	0e 94 48 0b 	call	0x1690	; 0x1690 <usart_init_rs232>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    368c:	11 e0       	ldi	r17, 0x01	; 1
    368e:	10 93 21 06 	sts	0x0621, r17	; 0x800621 <__TEXT_REGION_LENGTH__+0x700621>
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    3692:	be 01       	movw	r22, r28
    3694:	6f 5f       	subi	r22, 0xFF	; 255
    3696:	7f 4f       	sbci	r23, 0xFF	; 255
    3698:	80 e0       	ldi	r24, 0x00	; 0
    369a:	92 e0       	ldi	r25, 0x02	; 2
    369c:	0e 94 50 09 	call	0x12a0	; 0x12a0 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    36a0:	ae 01       	movw	r20, r28
    36a2:	48 5f       	subi	r20, 0xF8	; 248
    36a4:	5f 4f       	sbci	r21, 0xFF	; 255
    36a6:	61 e0       	ldi	r22, 0x01	; 1
    36a8:	80 e0       	ldi	r24, 0x00	; 0
    36aa:	92 e0       	ldi	r25, 0x02	; 2
    36ac:	0e 94 ac 09 	call	0x1358	; 0x1358 <adcch_read_configuration>
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    36b0:	9a 81       	ldd	r25, Y+2	; 0x02
    36b2:	8b 81       	ldd	r24, Y+3	; 0x03
    36b4:	8f 78       	andi	r24, 0x8F	; 143
    36b6:	80 61       	ori	r24, 0x10	; 16
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    36b8:	8b 83       	std	Y+3, r24	; 0x03
    36ba:	89 2f       	mov	r24, r25
    36bc:	81 7e       	andi	r24, 0xE1	; 225
		conf->evctrl = ADC_EVACT_NONE_gc;
    36be:	8a 83       	std	Y+2, r24	; 0x02
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    36c0:	1c 82       	std	Y+4, r1	; 0x04
    36c2:	02 e0       	ldi	r16, 0x02	; 2
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    36c4:	0d 83       	std	Y+5, r16	; 0x05
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    36c6:	18 87       	std	Y+8, r17	; 0x08
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    36c8:	19 86       	std	Y+9, r1	; 0x09
    36ca:	be 01       	movw	r22, r28
    36cc:	6f 5f       	subi	r22, 0xFF	; 255
    36ce:	7f 4f       	sbci	r23, 0xFF	; 255
    36d0:	80 e0       	ldi	r24, 0x00	; 0
    36d2:	92 e0       	ldi	r25, 0x02	; 2
    36d4:	0e 94 00 09 	call	0x1200	; 0x1200 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    36d8:	ae 01       	movw	r20, r28
    36da:	48 5f       	subi	r20, 0xF8	; 248
    36dc:	5f 4f       	sbci	r21, 0xFF	; 255
    36de:	61 e0       	ldi	r22, 0x01	; 1
    36e0:	80 e0       	ldi	r24, 0x00	; 0
    36e2:	92 e0       	ldi	r25, 0x02	; 2
    36e4:	0e 94 73 09 	call	0x12e6	; 0x12e6 <adcch_write_configuration>
static void adc_init2(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC2, &adc_conf);
    36e8:	be 01       	movw	r22, r28
    36ea:	6f 5f       	subi	r22, 0xFF	; 255
    36ec:	7f 4f       	sbci	r23, 0xFF	; 255
    36ee:	80 e0       	ldi	r24, 0x00	; 0
    36f0:	92 e0       	ldi	r25, 0x02	; 2
    36f2:	0e 94 50 09 	call	0x12a0	; 0x12a0 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    36f6:	ae 01       	movw	r20, r28
    36f8:	48 5f       	subi	r20, 0xF8	; 248
    36fa:	5f 4f       	sbci	r21, 0xFF	; 255
    36fc:	62 e0       	ldi	r22, 0x02	; 2
    36fe:	80 e0       	ldi	r24, 0x00	; 0
    3700:	92 e0       	ldi	r25, 0x02	; 2
    3702:	0e 94 ac 09 	call	0x1358	; 0x1358 <adcch_read_configuration>
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    3706:	9a 81       	ldd	r25, Y+2	; 0x02
    3708:	8b 81       	ldd	r24, Y+3	; 0x03
    370a:	8f 78       	andi	r24, 0x8F	; 143
    370c:	80 61       	ori	r24, 0x10	; 16
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    370e:	8b 83       	std	Y+3, r24	; 0x03
    3710:	89 2f       	mov	r24, r25
    3712:	81 7e       	andi	r24, 0xE1	; 225
		conf->evctrl = ADC_EVACT_NONE_gc;
    3714:	8a 83       	std	Y+2, r24	; 0x02
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3716:	1c 82       	std	Y+4, r1	; 0x04
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3718:	0d 83       	std	Y+5, r16	; 0x05
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    371a:	18 87       	std	Y+8, r17	; 0x08
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN1, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC2, &adc_conf);
    371c:	f9 86       	std	Y+9, r15	; 0x09
    371e:	be 01       	movw	r22, r28
    3720:	6f 5f       	subi	r22, 0xFF	; 255
    3722:	7f 4f       	sbci	r23, 0xFF	; 255
    3724:	80 e0       	ldi	r24, 0x00	; 0
    3726:	92 e0       	ldi	r25, 0x02	; 2
    3728:	0e 94 00 09 	call	0x1200	; 0x1200 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    372c:	ae 01       	movw	r20, r28
    372e:	48 5f       	subi	r20, 0xF8	; 248
    3730:	5f 4f       	sbci	r21, 0xFF	; 255
    3732:	62 e0       	ldi	r22, 0x02	; 2
    3734:	80 e0       	ldi	r24, 0x00	; 0
    3736:	92 e0       	ldi	r25, 0x02	; 2
    3738:	0e 94 73 09 	call	0x12e6	; 0x12e6 <adcch_write_configuration>
static void adc_init3(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC3, &adc_conf);
    373c:	be 01       	movw	r22, r28
    373e:	6f 5f       	subi	r22, 0xFF	; 255
    3740:	7f 4f       	sbci	r23, 0xFF	; 255
    3742:	80 e0       	ldi	r24, 0x00	; 0
    3744:	92 e0       	ldi	r25, 0x02	; 2
    3746:	0e 94 50 09 	call	0x12a0	; 0x12a0 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    374a:	ae 01       	movw	r20, r28
    374c:	48 5f       	subi	r20, 0xF8	; 248
    374e:	5f 4f       	sbci	r21, 0xFF	; 255
    3750:	64 e0       	ldi	r22, 0x04	; 4
    3752:	80 e0       	ldi	r24, 0x00	; 0
    3754:	92 e0       	ldi	r25, 0x02	; 2
    3756:	0e 94 ac 09 	call	0x1358	; 0x1358 <adcch_read_configuration>
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    375a:	9a 81       	ldd	r25, Y+2	; 0x02
    375c:	8b 81       	ldd	r24, Y+3	; 0x03
    375e:	8f 78       	andi	r24, 0x8F	; 143
    3760:	80 61       	ori	r24, 0x10	; 16
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3762:	8b 83       	std	Y+3, r24	; 0x03
    3764:	89 2f       	mov	r24, r25
    3766:	81 7e       	andi	r24, 0xE1	; 225
		conf->evctrl = ADC_EVACT_NONE_gc;
    3768:	8a 83       	std	Y+2, r24	; 0x02
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    376a:	1c 82       	std	Y+4, r1	; 0x04
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    376c:	0d 83       	std	Y+5, r16	; 0x05
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    376e:	18 87       	std	Y+8, r17	; 0x08
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN2, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC3, &adc_conf);
    3770:	e9 86       	std	Y+9, r14	; 0x09
    3772:	be 01       	movw	r22, r28
    3774:	6f 5f       	subi	r22, 0xFF	; 255
    3776:	7f 4f       	sbci	r23, 0xFF	; 255
    3778:	80 e0       	ldi	r24, 0x00	; 0
    377a:	92 e0       	ldi	r25, 0x02	; 2
    377c:	0e 94 00 09 	call	0x1200	; 0x1200 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    3780:	ae 01       	movw	r20, r28
    3782:	48 5f       	subi	r20, 0xF8	; 248
    3784:	5f 4f       	sbci	r21, 0xFF	; 255
    3786:	64 e0       	ldi	r22, 0x04	; 4
    3788:	80 e0       	ldi	r24, 0x00	; 0
    378a:	92 e0       	ldi	r25, 0x02	; 2
    378c:	0e 94 73 09 	call	0x12e6	; 0x12e6 <adcch_write_configuration>
	//end of usart code

	adc_init();
	adc_init2();
	adc_init3();
	gfx_mono_init();
    3790:	0e 94 0b 05 	call	0xa16	; 0xa16 <gfx_mono_st7565r_init>
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    3794:	0f ef       	ldi	r16, 0xFF	; 255
    3796:	19 e1       	ldi	r17, 0x19	; 25
    3798:	20 e0       	ldi	r18, 0x00	; 0
    379a:	30 e0       	ldi	r19, 0x00	; 0
    379c:	41 e0       	ldi	r20, 0x01	; 1
    379e:	61 e0       	ldi	r22, 0x01	; 1
    37a0:	70 e0       	ldi	r23, 0x00	; 0
    37a2:	84 e3       	ldi	r24, 0x34	; 52
    37a4:	90 e2       	ldi	r25, 0x20	; 32
    37a6:	a6 db       	rcall	.-2228   	; 0x2ef4 <xTimerCreate>
	
	xTaskCreate(testLamp,"",500,NULL,1,NULL);
    37a8:	4c 01       	movw	r8, r24
    37aa:	a1 2c       	mov	r10, r1
    37ac:	b1 2c       	mov	r11, r1
    37ae:	c1 2c       	mov	r12, r1
    37b0:	d1 2c       	mov	r13, r1
    37b2:	e1 2c       	mov	r14, r1
    37b4:	f1 2c       	mov	r15, r1
    37b6:	01 e0       	ldi	r16, 0x01	; 1
    37b8:	20 e0       	ldi	r18, 0x00	; 0
    37ba:	30 e0       	ldi	r19, 0x00	; 0
    37bc:	44 ef       	ldi	r20, 0xF4	; 244
    37be:	51 e0       	ldi	r21, 0x01	; 1
    37c0:	6d e3       	ldi	r22, 0x3D	; 61
    37c2:	70 e2       	ldi	r23, 0x20	; 32
    37c4:	83 e1       	ldi	r24, 0x13	; 19
    37c6:	9a e1       	ldi	r25, 0x1A	; 26
    37c8:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
	xTaskCreate(testLCD,"",500,NULL,1,NULL);
    37cc:	20 e0       	ldi	r18, 0x00	; 0
    37ce:	30 e0       	ldi	r19, 0x00	; 0
    37d0:	44 ef       	ldi	r20, 0xF4	; 244
    37d2:	51 e0       	ldi	r21, 0x01	; 1
    37d4:	6d e3       	ldi	r22, 0x3D	; 61
    37d6:	70 e2       	ldi	r23, 0x20	; 32
    37d8:	81 e9       	ldi	r24, 0x91	; 145
    37da:	9a e1       	ldi	r25, 0x1A	; 26
    37dc:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
	xTaskCreate(receivePing,"",500,NULL,1,NULL);
    37e0:	20 e0       	ldi	r18, 0x00	; 0
    37e2:	30 e0       	ldi	r19, 0x00	; 0
    37e4:	44 ef       	ldi	r20, 0xF4	; 244
    37e6:	51 e0       	ldi	r21, 0x01	; 1
    37e8:	6d e3       	ldi	r22, 0x3D	; 61
    37ea:	70 e2       	ldi	r23, 0x20	; 32
    37ec:	88 e8       	ldi	r24, 0x88	; 136
    37ee:	9a e1       	ldi	r25, 0x1A	; 26
    37f0:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
	xTaskCreate(testLightS,"",500,NULL,1,NULL);
    37f4:	20 e0       	ldi	r18, 0x00	; 0
    37f6:	30 e0       	ldi	r19, 0x00	; 0
    37f8:	44 ef       	ldi	r20, 0xF4	; 244
    37fa:	51 e0       	ldi	r21, 0x01	; 1
    37fc:	6d e3       	ldi	r22, 0x3D	; 61
    37fe:	70 e2       	ldi	r23, 0x20	; 32
    3800:	8f e7       	ldi	r24, 0x7F	; 127
    3802:	9a e1       	ldi	r25, 0x1A	; 26
    3804:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
	xTaskCreate(testTempS,"",500,NULL,1,NULL);
    3808:	20 e0       	ldi	r18, 0x00	; 0
    380a:	30 e0       	ldi	r19, 0x00	; 0
    380c:	44 ef       	ldi	r20, 0xF4	; 244
    380e:	51 e0       	ldi	r21, 0x01	; 1
    3810:	6d e3       	ldi	r22, 0x3D	; 61
    3812:	70 e2       	ldi	r23, 0x20	; 32
    3814:	8a e4       	ldi	r24, 0x4A	; 74
    3816:	9a e1       	ldi	r25, 0x1A	; 26
    3818:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
	xTaskCreate(testServo,"",500,NULL,1,NULL);
    381c:	20 e0       	ldi	r18, 0x00	; 0
    381e:	30 e0       	ldi	r19, 0x00	; 0
    3820:	44 ef       	ldi	r20, 0xF4	; 244
    3822:	51 e0       	ldi	r21, 0x01	; 1
    3824:	6d e3       	ldi	r22, 0x3D	; 61
    3826:	70 e2       	ldi	r23, 0x20	; 32
    3828:	8d ec       	ldi	r24, 0xCD	; 205
    382a:	9a e1       	ldi	r25, 0x1A	; 26
    382c:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
	xTaskCreate(testPot,"",500,NULL,1,NULL);
    3830:	20 e0       	ldi	r18, 0x00	; 0
    3832:	30 e0       	ldi	r19, 0x00	; 0
    3834:	44 ef       	ldi	r20, 0xF4	; 244
    3836:	51 e0       	ldi	r21, 0x01	; 1
    3838:	6d e3       	ldi	r22, 0x3D	; 61
    383a:	70 e2       	ldi	r23, 0x20	; 32
    383c:	8b e2       	ldi	r24, 0x2B	; 43
    383e:	9a e1       	ldi	r25, 0x1A	; 26
	
	xTimerStart(timerPing, 0);
    3840:	0e 94 17 13 	call	0x262e	; 0x262e <xTaskGenericCreate>
    3844:	2e d8       	rcall	.-4004   	; 0x28a2 <xTaskGetTickCount>
    3846:	00 e0       	ldi	r16, 0x00	; 0
    3848:	10 e0       	ldi	r17, 0x00	; 0
    384a:	20 e0       	ldi	r18, 0x00	; 0
    384c:	30 e0       	ldi	r19, 0x00	; 0
    384e:	ac 01       	movw	r20, r24
    3850:	61 e0       	ldi	r22, 0x01	; 1
    3852:	c4 01       	movw	r24, r8
	
	vTaskStartScheduler();
    3854:	85 db       	rcall	.-2294   	; 0x2f60 <xTimerGenericCommand>
    3856:	0e 94 18 14 	call	0x2830	; 0x2830 <vTaskStartScheduler>

	// Insert application code here, after the board has been initialized.
}
    385a:	80 e0       	ldi	r24, 0x00	; 0
    385c:	90 e0       	ldi	r25, 0x00	; 0
    385e:	2b 96       	adiw	r28, 0x0b	; 11
    3860:	cd bf       	out	0x3d, r28	; 61
    3862:	de bf       	out	0x3e, r29	; 62
    3864:	df 91       	pop	r29
    3866:	cf 91       	pop	r28
    3868:	1f 91       	pop	r17
    386a:	0f 91       	pop	r16
    386c:	ff 90       	pop	r15
    386e:	ef 90       	pop	r14
    3870:	df 90       	pop	r13
    3872:	cf 90       	pop	r12
    3874:	bf 90       	pop	r11
    3876:	af 90       	pop	r10
    3878:	9f 90       	pop	r9
    387a:	8f 90       	pop	r8
		result = adc_read();
		vTaskDelay(10/portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(testLightS, p_){
    387c:	08 95       	ret

0000387e <__udivmodsi4>:
    387e:	a1 e2       	ldi	r26, 0x21	; 33
    3880:	1a 2e       	mov	r1, r26
    3882:	aa 1b       	sub	r26, r26
    3884:	bb 1b       	sub	r27, r27
    3886:	fd 01       	movw	r30, r26
    3888:	0d c0       	rjmp	.+26     	; 0x38a4 <__udivmodsi4_ep>

0000388a <__udivmodsi4_loop>:
    388a:	aa 1f       	adc	r26, r26
    388c:	bb 1f       	adc	r27, r27
    388e:	ee 1f       	adc	r30, r30
    3890:	ff 1f       	adc	r31, r31
    3892:	a2 17       	cp	r26, r18
    3894:	b3 07       	cpc	r27, r19
    3896:	e4 07       	cpc	r30, r20
    3898:	f5 07       	cpc	r31, r21
    389a:	20 f0       	brcs	.+8      	; 0x38a4 <__udivmodsi4_ep>
    389c:	a2 1b       	sub	r26, r18
    389e:	b3 0b       	sbc	r27, r19
    38a0:	e4 0b       	sbc	r30, r20
    38a2:	f5 0b       	sbc	r31, r21

000038a4 <__udivmodsi4_ep>:
    38a4:	66 1f       	adc	r22, r22
    38a6:	77 1f       	adc	r23, r23
    38a8:	88 1f       	adc	r24, r24
    38aa:	99 1f       	adc	r25, r25
    38ac:	1a 94       	dec	r1
    38ae:	69 f7       	brne	.-38     	; 0x388a <__udivmodsi4_loop>
    38b0:	60 95       	com	r22
    38b2:	70 95       	com	r23
    38b4:	80 95       	com	r24
    38b6:	90 95       	com	r25
    38b8:	9b 01       	movw	r18, r22
    38ba:	ac 01       	movw	r20, r24
    38bc:	bd 01       	movw	r22, r26
    38be:	cf 01       	movw	r24, r30
    38c0:	08 95       	ret

000038c2 <__tablejump2__>:
    38c2:	ee 0f       	add	r30, r30
    38c4:	ff 1f       	adc	r31, r31
    38c6:	88 1f       	adc	r24, r24
    38c8:	8b bf       	out	0x3b, r24	; 59
    38ca:	07 90       	elpm	r0, Z+
    38cc:	f6 91       	elpm	r31, Z
    38ce:	e0 2d       	mov	r30, r0
    38d0:	19 94       	eijmp

000038d2 <malloc>:
    38d2:	0f 93       	push	r16
    38d4:	1f 93       	push	r17
    38d6:	cf 93       	push	r28
    38d8:	df 93       	push	r29
    38da:	82 30       	cpi	r24, 0x02	; 2
    38dc:	91 05       	cpc	r25, r1
    38de:	10 f4       	brcc	.+4      	; 0x38e4 <malloc+0x12>
    38e0:	82 e0       	ldi	r24, 0x02	; 2
    38e2:	90 e0       	ldi	r25, 0x00	; 0
    38e4:	e0 91 99 23 	lds	r30, 0x2399	; 0x802399 <__flp>
    38e8:	f0 91 9a 23 	lds	r31, 0x239A	; 0x80239a <__flp+0x1>
    38ec:	20 e0       	ldi	r18, 0x00	; 0
    38ee:	30 e0       	ldi	r19, 0x00	; 0
    38f0:	a0 e0       	ldi	r26, 0x00	; 0
    38f2:	b0 e0       	ldi	r27, 0x00	; 0
    38f4:	30 97       	sbiw	r30, 0x00	; 0
    38f6:	19 f1       	breq	.+70     	; 0x393e <malloc+0x6c>
    38f8:	40 81       	ld	r20, Z
    38fa:	51 81       	ldd	r21, Z+1	; 0x01
    38fc:	02 81       	ldd	r16, Z+2	; 0x02
    38fe:	13 81       	ldd	r17, Z+3	; 0x03
    3900:	48 17       	cp	r20, r24
    3902:	59 07       	cpc	r21, r25
    3904:	c8 f0       	brcs	.+50     	; 0x3938 <malloc+0x66>
    3906:	84 17       	cp	r24, r20
    3908:	95 07       	cpc	r25, r21
    390a:	69 f4       	brne	.+26     	; 0x3926 <malloc+0x54>
    390c:	10 97       	sbiw	r26, 0x00	; 0
    390e:	31 f0       	breq	.+12     	; 0x391c <malloc+0x4a>
    3910:	12 96       	adiw	r26, 0x02	; 2
    3912:	0c 93       	st	X, r16
    3914:	12 97       	sbiw	r26, 0x02	; 2
    3916:	13 96       	adiw	r26, 0x03	; 3
    3918:	1c 93       	st	X, r17
    391a:	27 c0       	rjmp	.+78     	; 0x396a <malloc+0x98>
    391c:	00 93 99 23 	sts	0x2399, r16	; 0x802399 <__flp>
    3920:	10 93 9a 23 	sts	0x239A, r17	; 0x80239a <__flp+0x1>
    3924:	22 c0       	rjmp	.+68     	; 0x396a <malloc+0x98>
    3926:	21 15       	cp	r18, r1
    3928:	31 05       	cpc	r19, r1
    392a:	19 f0       	breq	.+6      	; 0x3932 <malloc+0x60>
    392c:	42 17       	cp	r20, r18
    392e:	53 07       	cpc	r21, r19
    3930:	18 f4       	brcc	.+6      	; 0x3938 <malloc+0x66>
    3932:	9a 01       	movw	r18, r20
    3934:	bd 01       	movw	r22, r26
    3936:	ef 01       	movw	r28, r30
    3938:	df 01       	movw	r26, r30
    393a:	f8 01       	movw	r30, r16
    393c:	db cf       	rjmp	.-74     	; 0x38f4 <malloc+0x22>
    393e:	21 15       	cp	r18, r1
    3940:	31 05       	cpc	r19, r1
    3942:	f9 f0       	breq	.+62     	; 0x3982 <malloc+0xb0>
    3944:	28 1b       	sub	r18, r24
    3946:	39 0b       	sbc	r19, r25
    3948:	24 30       	cpi	r18, 0x04	; 4
    394a:	31 05       	cpc	r19, r1
    394c:	80 f4       	brcc	.+32     	; 0x396e <malloc+0x9c>
    394e:	8a 81       	ldd	r24, Y+2	; 0x02
    3950:	9b 81       	ldd	r25, Y+3	; 0x03
    3952:	61 15       	cp	r22, r1
    3954:	71 05       	cpc	r23, r1
    3956:	21 f0       	breq	.+8      	; 0x3960 <malloc+0x8e>
    3958:	fb 01       	movw	r30, r22
    395a:	82 83       	std	Z+2, r24	; 0x02
    395c:	93 83       	std	Z+3, r25	; 0x03
    395e:	04 c0       	rjmp	.+8      	; 0x3968 <malloc+0x96>
    3960:	80 93 99 23 	sts	0x2399, r24	; 0x802399 <__flp>
    3964:	90 93 9a 23 	sts	0x239A, r25	; 0x80239a <__flp+0x1>
    3968:	fe 01       	movw	r30, r28
    396a:	32 96       	adiw	r30, 0x02	; 2
    396c:	44 c0       	rjmp	.+136    	; 0x39f6 <malloc+0x124>
    396e:	fe 01       	movw	r30, r28
    3970:	e2 0f       	add	r30, r18
    3972:	f3 1f       	adc	r31, r19
    3974:	81 93       	st	Z+, r24
    3976:	91 93       	st	Z+, r25
    3978:	22 50       	subi	r18, 0x02	; 2
    397a:	31 09       	sbc	r19, r1
    397c:	28 83       	st	Y, r18
    397e:	39 83       	std	Y+1, r19	; 0x01
    3980:	3a c0       	rjmp	.+116    	; 0x39f6 <malloc+0x124>
    3982:	20 91 97 23 	lds	r18, 0x2397	; 0x802397 <__brkval>
    3986:	30 91 98 23 	lds	r19, 0x2398	; 0x802398 <__brkval+0x1>
    398a:	23 2b       	or	r18, r19
    398c:	41 f4       	brne	.+16     	; 0x399e <malloc+0xcc>
    398e:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3992:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    3996:	20 93 97 23 	sts	0x2397, r18	; 0x802397 <__brkval>
    399a:	30 93 98 23 	sts	0x2398, r19	; 0x802398 <__brkval+0x1>
    399e:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    39a2:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    39a6:	21 15       	cp	r18, r1
    39a8:	31 05       	cpc	r19, r1
    39aa:	41 f4       	brne	.+16     	; 0x39bc <malloc+0xea>
    39ac:	2d b7       	in	r18, 0x3d	; 61
    39ae:	3e b7       	in	r19, 0x3e	; 62
    39b0:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    39b4:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    39b8:	24 1b       	sub	r18, r20
    39ba:	35 0b       	sbc	r19, r21
    39bc:	e0 91 97 23 	lds	r30, 0x2397	; 0x802397 <__brkval>
    39c0:	f0 91 98 23 	lds	r31, 0x2398	; 0x802398 <__brkval+0x1>
    39c4:	e2 17       	cp	r30, r18
    39c6:	f3 07       	cpc	r31, r19
    39c8:	a0 f4       	brcc	.+40     	; 0x39f2 <malloc+0x120>
    39ca:	2e 1b       	sub	r18, r30
    39cc:	3f 0b       	sbc	r19, r31
    39ce:	28 17       	cp	r18, r24
    39d0:	39 07       	cpc	r19, r25
    39d2:	78 f0       	brcs	.+30     	; 0x39f2 <malloc+0x120>
    39d4:	ac 01       	movw	r20, r24
    39d6:	4e 5f       	subi	r20, 0xFE	; 254
    39d8:	5f 4f       	sbci	r21, 0xFF	; 255
    39da:	24 17       	cp	r18, r20
    39dc:	35 07       	cpc	r19, r21
    39de:	48 f0       	brcs	.+18     	; 0x39f2 <malloc+0x120>
    39e0:	4e 0f       	add	r20, r30
    39e2:	5f 1f       	adc	r21, r31
    39e4:	40 93 97 23 	sts	0x2397, r20	; 0x802397 <__brkval>
    39e8:	50 93 98 23 	sts	0x2398, r21	; 0x802398 <__brkval+0x1>
    39ec:	81 93       	st	Z+, r24
    39ee:	91 93       	st	Z+, r25
    39f0:	02 c0       	rjmp	.+4      	; 0x39f6 <malloc+0x124>
    39f2:	e0 e0       	ldi	r30, 0x00	; 0
    39f4:	f0 e0       	ldi	r31, 0x00	; 0
    39f6:	cf 01       	movw	r24, r30
    39f8:	df 91       	pop	r29
    39fa:	cf 91       	pop	r28
    39fc:	1f 91       	pop	r17
    39fe:	0f 91       	pop	r16
    3a00:	08 95       	ret

00003a02 <free>:
    3a02:	cf 93       	push	r28
    3a04:	df 93       	push	r29
    3a06:	00 97       	sbiw	r24, 0x00	; 0
    3a08:	09 f4       	brne	.+2      	; 0x3a0c <free+0xa>
    3a0a:	81 c0       	rjmp	.+258    	; 0x3b0e <free+0x10c>
    3a0c:	fc 01       	movw	r30, r24
    3a0e:	32 97       	sbiw	r30, 0x02	; 2
    3a10:	12 82       	std	Z+2, r1	; 0x02
    3a12:	13 82       	std	Z+3, r1	; 0x03
    3a14:	a0 91 99 23 	lds	r26, 0x2399	; 0x802399 <__flp>
    3a18:	b0 91 9a 23 	lds	r27, 0x239A	; 0x80239a <__flp+0x1>
    3a1c:	10 97       	sbiw	r26, 0x00	; 0
    3a1e:	81 f4       	brne	.+32     	; 0x3a40 <free+0x3e>
    3a20:	20 81       	ld	r18, Z
    3a22:	31 81       	ldd	r19, Z+1	; 0x01
    3a24:	82 0f       	add	r24, r18
    3a26:	93 1f       	adc	r25, r19
    3a28:	20 91 97 23 	lds	r18, 0x2397	; 0x802397 <__brkval>
    3a2c:	30 91 98 23 	lds	r19, 0x2398	; 0x802398 <__brkval+0x1>
    3a30:	28 17       	cp	r18, r24
    3a32:	39 07       	cpc	r19, r25
    3a34:	51 f5       	brne	.+84     	; 0x3a8a <free+0x88>
    3a36:	e0 93 97 23 	sts	0x2397, r30	; 0x802397 <__brkval>
    3a3a:	f0 93 98 23 	sts	0x2398, r31	; 0x802398 <__brkval+0x1>
    3a3e:	67 c0       	rjmp	.+206    	; 0x3b0e <free+0x10c>
    3a40:	ed 01       	movw	r28, r26
    3a42:	20 e0       	ldi	r18, 0x00	; 0
    3a44:	30 e0       	ldi	r19, 0x00	; 0
    3a46:	ce 17       	cp	r28, r30
    3a48:	df 07       	cpc	r29, r31
    3a4a:	40 f4       	brcc	.+16     	; 0x3a5c <free+0x5a>
    3a4c:	4a 81       	ldd	r20, Y+2	; 0x02
    3a4e:	5b 81       	ldd	r21, Y+3	; 0x03
    3a50:	9e 01       	movw	r18, r28
    3a52:	41 15       	cp	r20, r1
    3a54:	51 05       	cpc	r21, r1
    3a56:	f1 f0       	breq	.+60     	; 0x3a94 <free+0x92>
    3a58:	ea 01       	movw	r28, r20
    3a5a:	f5 cf       	rjmp	.-22     	; 0x3a46 <free+0x44>
    3a5c:	c2 83       	std	Z+2, r28	; 0x02
    3a5e:	d3 83       	std	Z+3, r29	; 0x03
    3a60:	40 81       	ld	r20, Z
    3a62:	51 81       	ldd	r21, Z+1	; 0x01
    3a64:	84 0f       	add	r24, r20
    3a66:	95 1f       	adc	r25, r21
    3a68:	c8 17       	cp	r28, r24
    3a6a:	d9 07       	cpc	r29, r25
    3a6c:	59 f4       	brne	.+22     	; 0x3a84 <free+0x82>
    3a6e:	88 81       	ld	r24, Y
    3a70:	99 81       	ldd	r25, Y+1	; 0x01
    3a72:	84 0f       	add	r24, r20
    3a74:	95 1f       	adc	r25, r21
    3a76:	02 96       	adiw	r24, 0x02	; 2
    3a78:	80 83       	st	Z, r24
    3a7a:	91 83       	std	Z+1, r25	; 0x01
    3a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a80:	82 83       	std	Z+2, r24	; 0x02
    3a82:	93 83       	std	Z+3, r25	; 0x03
    3a84:	21 15       	cp	r18, r1
    3a86:	31 05       	cpc	r19, r1
    3a88:	29 f4       	brne	.+10     	; 0x3a94 <free+0x92>
    3a8a:	e0 93 99 23 	sts	0x2399, r30	; 0x802399 <__flp>
    3a8e:	f0 93 9a 23 	sts	0x239A, r31	; 0x80239a <__flp+0x1>
    3a92:	3d c0       	rjmp	.+122    	; 0x3b0e <free+0x10c>
    3a94:	e9 01       	movw	r28, r18
    3a96:	ea 83       	std	Y+2, r30	; 0x02
    3a98:	fb 83       	std	Y+3, r31	; 0x03
    3a9a:	49 91       	ld	r20, Y+
    3a9c:	59 91       	ld	r21, Y+
    3a9e:	c4 0f       	add	r28, r20
    3aa0:	d5 1f       	adc	r29, r21
    3aa2:	ec 17       	cp	r30, r28
    3aa4:	fd 07       	cpc	r31, r29
    3aa6:	61 f4       	brne	.+24     	; 0x3ac0 <free+0xbe>
    3aa8:	80 81       	ld	r24, Z
    3aaa:	91 81       	ldd	r25, Z+1	; 0x01
    3aac:	84 0f       	add	r24, r20
    3aae:	95 1f       	adc	r25, r21
    3ab0:	02 96       	adiw	r24, 0x02	; 2
    3ab2:	e9 01       	movw	r28, r18
    3ab4:	88 83       	st	Y, r24
    3ab6:	99 83       	std	Y+1, r25	; 0x01
    3ab8:	82 81       	ldd	r24, Z+2	; 0x02
    3aba:	93 81       	ldd	r25, Z+3	; 0x03
    3abc:	8a 83       	std	Y+2, r24	; 0x02
    3abe:	9b 83       	std	Y+3, r25	; 0x03
    3ac0:	e0 e0       	ldi	r30, 0x00	; 0
    3ac2:	f0 e0       	ldi	r31, 0x00	; 0
    3ac4:	12 96       	adiw	r26, 0x02	; 2
    3ac6:	8d 91       	ld	r24, X+
    3ac8:	9c 91       	ld	r25, X
    3aca:	13 97       	sbiw	r26, 0x03	; 3
    3acc:	00 97       	sbiw	r24, 0x00	; 0
    3ace:	19 f0       	breq	.+6      	; 0x3ad6 <free+0xd4>
    3ad0:	fd 01       	movw	r30, r26
    3ad2:	dc 01       	movw	r26, r24
    3ad4:	f7 cf       	rjmp	.-18     	; 0x3ac4 <free+0xc2>
    3ad6:	8d 91       	ld	r24, X+
    3ad8:	9c 91       	ld	r25, X
    3ada:	11 97       	sbiw	r26, 0x01	; 1
    3adc:	9d 01       	movw	r18, r26
    3ade:	2e 5f       	subi	r18, 0xFE	; 254
    3ae0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ae2:	82 0f       	add	r24, r18
    3ae4:	93 1f       	adc	r25, r19
    3ae6:	20 91 97 23 	lds	r18, 0x2397	; 0x802397 <__brkval>
    3aea:	30 91 98 23 	lds	r19, 0x2398	; 0x802398 <__brkval+0x1>
    3aee:	28 17       	cp	r18, r24
    3af0:	39 07       	cpc	r19, r25
    3af2:	69 f4       	brne	.+26     	; 0x3b0e <free+0x10c>
    3af4:	30 97       	sbiw	r30, 0x00	; 0
    3af6:	29 f4       	brne	.+10     	; 0x3b02 <free+0x100>
    3af8:	10 92 99 23 	sts	0x2399, r1	; 0x802399 <__flp>
    3afc:	10 92 9a 23 	sts	0x239A, r1	; 0x80239a <__flp+0x1>
    3b00:	02 c0       	rjmp	.+4      	; 0x3b06 <free+0x104>
    3b02:	12 82       	std	Z+2, r1	; 0x02
    3b04:	13 82       	std	Z+3, r1	; 0x03
    3b06:	a0 93 97 23 	sts	0x2397, r26	; 0x802397 <__brkval>
    3b0a:	b0 93 98 23 	sts	0x2398, r27	; 0x802398 <__brkval+0x1>
    3b0e:	df 91       	pop	r29
    3b10:	cf 91       	pop	r28
    3b12:	08 95       	ret

00003b14 <memcpy>:
    3b14:	fb 01       	movw	r30, r22
    3b16:	dc 01       	movw	r26, r24
    3b18:	02 c0       	rjmp	.+4      	; 0x3b1e <memcpy+0xa>
    3b1a:	01 90       	ld	r0, Z+
    3b1c:	0d 92       	st	X+, r0
    3b1e:	41 50       	subi	r20, 0x01	; 1
    3b20:	50 40       	sbci	r21, 0x00	; 0
    3b22:	d8 f7       	brcc	.-10     	; 0x3b1a <memcpy+0x6>
    3b24:	08 95       	ret

00003b26 <snprintf>:
    3b26:	0f 93       	push	r16
    3b28:	1f 93       	push	r17
    3b2a:	cf 93       	push	r28
    3b2c:	df 93       	push	r29
    3b2e:	cd b7       	in	r28, 0x3d	; 61
    3b30:	de b7       	in	r29, 0x3e	; 62
    3b32:	2e 97       	sbiw	r28, 0x0e	; 14
    3b34:	cd bf       	out	0x3d, r28	; 61
    3b36:	de bf       	out	0x3e, r29	; 62
    3b38:	0e 89       	ldd	r16, Y+22	; 0x16
    3b3a:	1f 89       	ldd	r17, Y+23	; 0x17
    3b3c:	88 8d       	ldd	r24, Y+24	; 0x18
    3b3e:	99 8d       	ldd	r25, Y+25	; 0x19
    3b40:	26 e0       	ldi	r18, 0x06	; 6
    3b42:	2c 83       	std	Y+4, r18	; 0x04
    3b44:	09 83       	std	Y+1, r16	; 0x01
    3b46:	1a 83       	std	Y+2, r17	; 0x02
    3b48:	97 ff       	sbrs	r25, 7
    3b4a:	02 c0       	rjmp	.+4      	; 0x3b50 <snprintf+0x2a>
    3b4c:	80 e0       	ldi	r24, 0x00	; 0
    3b4e:	90 e8       	ldi	r25, 0x80	; 128
    3b50:	01 97       	sbiw	r24, 0x01	; 1
    3b52:	8d 83       	std	Y+5, r24	; 0x05
    3b54:	9e 83       	std	Y+6, r25	; 0x06
    3b56:	ae 01       	movw	r20, r28
    3b58:	44 5e       	subi	r20, 0xE4	; 228
    3b5a:	5f 4f       	sbci	r21, 0xFF	; 255
    3b5c:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3b5e:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3b60:	ce 01       	movw	r24, r28
    3b62:	01 96       	adiw	r24, 0x01	; 1
    3b64:	16 d0       	rcall	.+44     	; 0x3b92 <vfprintf>
    3b66:	4d 81       	ldd	r20, Y+5	; 0x05
    3b68:	5e 81       	ldd	r21, Y+6	; 0x06
    3b6a:	57 fd       	sbrc	r21, 7
    3b6c:	0a c0       	rjmp	.+20     	; 0x3b82 <snprintf+0x5c>
    3b6e:	2f 81       	ldd	r18, Y+7	; 0x07
    3b70:	38 85       	ldd	r19, Y+8	; 0x08
    3b72:	42 17       	cp	r20, r18
    3b74:	53 07       	cpc	r21, r19
    3b76:	0c f4       	brge	.+2      	; 0x3b7a <snprintf+0x54>
    3b78:	9a 01       	movw	r18, r20
    3b7a:	f8 01       	movw	r30, r16
    3b7c:	e2 0f       	add	r30, r18
    3b7e:	f3 1f       	adc	r31, r19
    3b80:	10 82       	st	Z, r1
    3b82:	2e 96       	adiw	r28, 0x0e	; 14
    3b84:	cd bf       	out	0x3d, r28	; 61
    3b86:	de bf       	out	0x3e, r29	; 62
    3b88:	df 91       	pop	r29
    3b8a:	cf 91       	pop	r28
    3b8c:	1f 91       	pop	r17
    3b8e:	0f 91       	pop	r16
    3b90:	08 95       	ret

00003b92 <vfprintf>:
    3b92:	2f 92       	push	r2
    3b94:	3f 92       	push	r3
    3b96:	4f 92       	push	r4
    3b98:	5f 92       	push	r5
    3b9a:	6f 92       	push	r6
    3b9c:	7f 92       	push	r7
    3b9e:	8f 92       	push	r8
    3ba0:	9f 92       	push	r9
    3ba2:	af 92       	push	r10
    3ba4:	bf 92       	push	r11
    3ba6:	cf 92       	push	r12
    3ba8:	df 92       	push	r13
    3baa:	ef 92       	push	r14
    3bac:	ff 92       	push	r15
    3bae:	0f 93       	push	r16
    3bb0:	1f 93       	push	r17
    3bb2:	cf 93       	push	r28
    3bb4:	df 93       	push	r29
    3bb6:	cd b7       	in	r28, 0x3d	; 61
    3bb8:	de b7       	in	r29, 0x3e	; 62
    3bba:	2b 97       	sbiw	r28, 0x0b	; 11
    3bbc:	cd bf       	out	0x3d, r28	; 61
    3bbe:	de bf       	out	0x3e, r29	; 62
    3bc0:	6c 01       	movw	r12, r24
    3bc2:	7b 01       	movw	r14, r22
    3bc4:	8a 01       	movw	r16, r20
    3bc6:	fc 01       	movw	r30, r24
    3bc8:	16 82       	std	Z+6, r1	; 0x06
    3bca:	17 82       	std	Z+7, r1	; 0x07
    3bcc:	83 81       	ldd	r24, Z+3	; 0x03
    3bce:	81 ff       	sbrs	r24, 1
    3bd0:	bf c1       	rjmp	.+894    	; 0x3f50 <vfprintf+0x3be>
    3bd2:	ce 01       	movw	r24, r28
    3bd4:	01 96       	adiw	r24, 0x01	; 1
    3bd6:	3c 01       	movw	r6, r24
    3bd8:	f6 01       	movw	r30, r12
    3bda:	93 81       	ldd	r25, Z+3	; 0x03
    3bdc:	f7 01       	movw	r30, r14
    3bde:	93 fd       	sbrc	r25, 3
    3be0:	85 91       	lpm	r24, Z+
    3be2:	93 ff       	sbrs	r25, 3
    3be4:	81 91       	ld	r24, Z+
    3be6:	7f 01       	movw	r14, r30
    3be8:	88 23       	and	r24, r24
    3bea:	09 f4       	brne	.+2      	; 0x3bee <vfprintf+0x5c>
    3bec:	ad c1       	rjmp	.+858    	; 0x3f48 <vfprintf+0x3b6>
    3bee:	85 32       	cpi	r24, 0x25	; 37
    3bf0:	39 f4       	brne	.+14     	; 0x3c00 <vfprintf+0x6e>
    3bf2:	93 fd       	sbrc	r25, 3
    3bf4:	85 91       	lpm	r24, Z+
    3bf6:	93 ff       	sbrs	r25, 3
    3bf8:	81 91       	ld	r24, Z+
    3bfa:	7f 01       	movw	r14, r30
    3bfc:	85 32       	cpi	r24, 0x25	; 37
    3bfe:	21 f4       	brne	.+8      	; 0x3c08 <vfprintf+0x76>
    3c00:	b6 01       	movw	r22, r12
    3c02:	90 e0       	ldi	r25, 0x00	; 0
    3c04:	d3 d1       	rcall	.+934    	; 0x3fac <fputc>
    3c06:	e8 cf       	rjmp	.-48     	; 0x3bd8 <vfprintf+0x46>
    3c08:	91 2c       	mov	r9, r1
    3c0a:	21 2c       	mov	r2, r1
    3c0c:	31 2c       	mov	r3, r1
    3c0e:	ff e1       	ldi	r31, 0x1F	; 31
    3c10:	f3 15       	cp	r31, r3
    3c12:	d8 f0       	brcs	.+54     	; 0x3c4a <vfprintf+0xb8>
    3c14:	8b 32       	cpi	r24, 0x2B	; 43
    3c16:	79 f0       	breq	.+30     	; 0x3c36 <vfprintf+0xa4>
    3c18:	38 f4       	brcc	.+14     	; 0x3c28 <vfprintf+0x96>
    3c1a:	80 32       	cpi	r24, 0x20	; 32
    3c1c:	79 f0       	breq	.+30     	; 0x3c3c <vfprintf+0xaa>
    3c1e:	83 32       	cpi	r24, 0x23	; 35
    3c20:	a1 f4       	brne	.+40     	; 0x3c4a <vfprintf+0xb8>
    3c22:	23 2d       	mov	r18, r3
    3c24:	20 61       	ori	r18, 0x10	; 16
    3c26:	1d c0       	rjmp	.+58     	; 0x3c62 <vfprintf+0xd0>
    3c28:	8d 32       	cpi	r24, 0x2D	; 45
    3c2a:	61 f0       	breq	.+24     	; 0x3c44 <vfprintf+0xb2>
    3c2c:	80 33       	cpi	r24, 0x30	; 48
    3c2e:	69 f4       	brne	.+26     	; 0x3c4a <vfprintf+0xb8>
    3c30:	23 2d       	mov	r18, r3
    3c32:	21 60       	ori	r18, 0x01	; 1
    3c34:	16 c0       	rjmp	.+44     	; 0x3c62 <vfprintf+0xd0>
    3c36:	83 2d       	mov	r24, r3
    3c38:	82 60       	ori	r24, 0x02	; 2
    3c3a:	38 2e       	mov	r3, r24
    3c3c:	e3 2d       	mov	r30, r3
    3c3e:	e4 60       	ori	r30, 0x04	; 4
    3c40:	3e 2e       	mov	r3, r30
    3c42:	2a c0       	rjmp	.+84     	; 0x3c98 <vfprintf+0x106>
    3c44:	f3 2d       	mov	r31, r3
    3c46:	f8 60       	ori	r31, 0x08	; 8
    3c48:	1d c0       	rjmp	.+58     	; 0x3c84 <vfprintf+0xf2>
    3c4a:	37 fc       	sbrc	r3, 7
    3c4c:	2d c0       	rjmp	.+90     	; 0x3ca8 <vfprintf+0x116>
    3c4e:	20 ed       	ldi	r18, 0xD0	; 208
    3c50:	28 0f       	add	r18, r24
    3c52:	2a 30       	cpi	r18, 0x0A	; 10
    3c54:	40 f0       	brcs	.+16     	; 0x3c66 <vfprintf+0xd4>
    3c56:	8e 32       	cpi	r24, 0x2E	; 46
    3c58:	b9 f4       	brne	.+46     	; 0x3c88 <vfprintf+0xf6>
    3c5a:	36 fc       	sbrc	r3, 6
    3c5c:	75 c1       	rjmp	.+746    	; 0x3f48 <vfprintf+0x3b6>
    3c5e:	23 2d       	mov	r18, r3
    3c60:	20 64       	ori	r18, 0x40	; 64
    3c62:	32 2e       	mov	r3, r18
    3c64:	19 c0       	rjmp	.+50     	; 0x3c98 <vfprintf+0x106>
    3c66:	36 fe       	sbrs	r3, 6
    3c68:	06 c0       	rjmp	.+12     	; 0x3c76 <vfprintf+0xe4>
    3c6a:	8a e0       	ldi	r24, 0x0A	; 10
    3c6c:	98 9e       	mul	r9, r24
    3c6e:	20 0d       	add	r18, r0
    3c70:	11 24       	eor	r1, r1
    3c72:	92 2e       	mov	r9, r18
    3c74:	11 c0       	rjmp	.+34     	; 0x3c98 <vfprintf+0x106>
    3c76:	ea e0       	ldi	r30, 0x0A	; 10
    3c78:	2e 9e       	mul	r2, r30
    3c7a:	20 0d       	add	r18, r0
    3c7c:	11 24       	eor	r1, r1
    3c7e:	22 2e       	mov	r2, r18
    3c80:	f3 2d       	mov	r31, r3
    3c82:	f0 62       	ori	r31, 0x20	; 32
    3c84:	3f 2e       	mov	r3, r31
    3c86:	08 c0       	rjmp	.+16     	; 0x3c98 <vfprintf+0x106>
    3c88:	8c 36       	cpi	r24, 0x6C	; 108
    3c8a:	21 f4       	brne	.+8      	; 0x3c94 <vfprintf+0x102>
    3c8c:	83 2d       	mov	r24, r3
    3c8e:	80 68       	ori	r24, 0x80	; 128
    3c90:	38 2e       	mov	r3, r24
    3c92:	02 c0       	rjmp	.+4      	; 0x3c98 <vfprintf+0x106>
    3c94:	88 36       	cpi	r24, 0x68	; 104
    3c96:	41 f4       	brne	.+16     	; 0x3ca8 <vfprintf+0x116>
    3c98:	f7 01       	movw	r30, r14
    3c9a:	93 fd       	sbrc	r25, 3
    3c9c:	85 91       	lpm	r24, Z+
    3c9e:	93 ff       	sbrs	r25, 3
    3ca0:	81 91       	ld	r24, Z+
    3ca2:	7f 01       	movw	r14, r30
    3ca4:	81 11       	cpse	r24, r1
    3ca6:	b3 cf       	rjmp	.-154    	; 0x3c0e <vfprintf+0x7c>
    3ca8:	98 2f       	mov	r25, r24
    3caa:	9f 7d       	andi	r25, 0xDF	; 223
    3cac:	95 54       	subi	r25, 0x45	; 69
    3cae:	93 30       	cpi	r25, 0x03	; 3
    3cb0:	28 f4       	brcc	.+10     	; 0x3cbc <vfprintf+0x12a>
    3cb2:	0c 5f       	subi	r16, 0xFC	; 252
    3cb4:	1f 4f       	sbci	r17, 0xFF	; 255
    3cb6:	9f e3       	ldi	r25, 0x3F	; 63
    3cb8:	99 83       	std	Y+1, r25	; 0x01
    3cba:	0d c0       	rjmp	.+26     	; 0x3cd6 <vfprintf+0x144>
    3cbc:	83 36       	cpi	r24, 0x63	; 99
    3cbe:	31 f0       	breq	.+12     	; 0x3ccc <vfprintf+0x13a>
    3cc0:	83 37       	cpi	r24, 0x73	; 115
    3cc2:	71 f0       	breq	.+28     	; 0x3ce0 <vfprintf+0x14e>
    3cc4:	83 35       	cpi	r24, 0x53	; 83
    3cc6:	09 f0       	breq	.+2      	; 0x3cca <vfprintf+0x138>
    3cc8:	55 c0       	rjmp	.+170    	; 0x3d74 <vfprintf+0x1e2>
    3cca:	20 c0       	rjmp	.+64     	; 0x3d0c <vfprintf+0x17a>
    3ccc:	f8 01       	movw	r30, r16
    3cce:	80 81       	ld	r24, Z
    3cd0:	89 83       	std	Y+1, r24	; 0x01
    3cd2:	0e 5f       	subi	r16, 0xFE	; 254
    3cd4:	1f 4f       	sbci	r17, 0xFF	; 255
    3cd6:	88 24       	eor	r8, r8
    3cd8:	83 94       	inc	r8
    3cda:	91 2c       	mov	r9, r1
    3cdc:	53 01       	movw	r10, r6
    3cde:	12 c0       	rjmp	.+36     	; 0x3d04 <vfprintf+0x172>
    3ce0:	28 01       	movw	r4, r16
    3ce2:	f2 e0       	ldi	r31, 0x02	; 2
    3ce4:	4f 0e       	add	r4, r31
    3ce6:	51 1c       	adc	r5, r1
    3ce8:	f8 01       	movw	r30, r16
    3cea:	a0 80       	ld	r10, Z
    3cec:	b1 80       	ldd	r11, Z+1	; 0x01
    3cee:	36 fe       	sbrs	r3, 6
    3cf0:	03 c0       	rjmp	.+6      	; 0x3cf8 <vfprintf+0x166>
    3cf2:	69 2d       	mov	r22, r9
    3cf4:	70 e0       	ldi	r23, 0x00	; 0
    3cf6:	02 c0       	rjmp	.+4      	; 0x3cfc <vfprintf+0x16a>
    3cf8:	6f ef       	ldi	r22, 0xFF	; 255
    3cfa:	7f ef       	ldi	r23, 0xFF	; 255
    3cfc:	c5 01       	movw	r24, r10
    3cfe:	4b d1       	rcall	.+662    	; 0x3f96 <strnlen>
    3d00:	4c 01       	movw	r8, r24
    3d02:	82 01       	movw	r16, r4
    3d04:	f3 2d       	mov	r31, r3
    3d06:	ff 77       	andi	r31, 0x7F	; 127
    3d08:	3f 2e       	mov	r3, r31
    3d0a:	15 c0       	rjmp	.+42     	; 0x3d36 <vfprintf+0x1a4>
    3d0c:	28 01       	movw	r4, r16
    3d0e:	22 e0       	ldi	r18, 0x02	; 2
    3d10:	42 0e       	add	r4, r18
    3d12:	51 1c       	adc	r5, r1
    3d14:	f8 01       	movw	r30, r16
    3d16:	a0 80       	ld	r10, Z
    3d18:	b1 80       	ldd	r11, Z+1	; 0x01
    3d1a:	36 fe       	sbrs	r3, 6
    3d1c:	03 c0       	rjmp	.+6      	; 0x3d24 <vfprintf+0x192>
    3d1e:	69 2d       	mov	r22, r9
    3d20:	70 e0       	ldi	r23, 0x00	; 0
    3d22:	02 c0       	rjmp	.+4      	; 0x3d28 <vfprintf+0x196>
    3d24:	6f ef       	ldi	r22, 0xFF	; 255
    3d26:	7f ef       	ldi	r23, 0xFF	; 255
    3d28:	c5 01       	movw	r24, r10
    3d2a:	2a d1       	rcall	.+596    	; 0x3f80 <strnlen_P>
    3d2c:	4c 01       	movw	r8, r24
    3d2e:	f3 2d       	mov	r31, r3
    3d30:	f0 68       	ori	r31, 0x80	; 128
    3d32:	3f 2e       	mov	r3, r31
    3d34:	82 01       	movw	r16, r4
    3d36:	33 fc       	sbrc	r3, 3
    3d38:	19 c0       	rjmp	.+50     	; 0x3d6c <vfprintf+0x1da>
    3d3a:	82 2d       	mov	r24, r2
    3d3c:	90 e0       	ldi	r25, 0x00	; 0
    3d3e:	88 16       	cp	r8, r24
    3d40:	99 06       	cpc	r9, r25
    3d42:	a0 f4       	brcc	.+40     	; 0x3d6c <vfprintf+0x1da>
    3d44:	b6 01       	movw	r22, r12
    3d46:	80 e2       	ldi	r24, 0x20	; 32
    3d48:	90 e0       	ldi	r25, 0x00	; 0
    3d4a:	30 d1       	rcall	.+608    	; 0x3fac <fputc>
    3d4c:	2a 94       	dec	r2
    3d4e:	f5 cf       	rjmp	.-22     	; 0x3d3a <vfprintf+0x1a8>
    3d50:	f5 01       	movw	r30, r10
    3d52:	37 fc       	sbrc	r3, 7
    3d54:	85 91       	lpm	r24, Z+
    3d56:	37 fe       	sbrs	r3, 7
    3d58:	81 91       	ld	r24, Z+
    3d5a:	5f 01       	movw	r10, r30
    3d5c:	b6 01       	movw	r22, r12
    3d5e:	90 e0       	ldi	r25, 0x00	; 0
    3d60:	25 d1       	rcall	.+586    	; 0x3fac <fputc>
    3d62:	21 10       	cpse	r2, r1
    3d64:	2a 94       	dec	r2
    3d66:	21 e0       	ldi	r18, 0x01	; 1
    3d68:	82 1a       	sub	r8, r18
    3d6a:	91 08       	sbc	r9, r1
    3d6c:	81 14       	cp	r8, r1
    3d6e:	91 04       	cpc	r9, r1
    3d70:	79 f7       	brne	.-34     	; 0x3d50 <vfprintf+0x1be>
    3d72:	e1 c0       	rjmp	.+450    	; 0x3f36 <vfprintf+0x3a4>
    3d74:	84 36       	cpi	r24, 0x64	; 100
    3d76:	11 f0       	breq	.+4      	; 0x3d7c <vfprintf+0x1ea>
    3d78:	89 36       	cpi	r24, 0x69	; 105
    3d7a:	39 f5       	brne	.+78     	; 0x3dca <vfprintf+0x238>
    3d7c:	f8 01       	movw	r30, r16
    3d7e:	37 fe       	sbrs	r3, 7
    3d80:	07 c0       	rjmp	.+14     	; 0x3d90 <vfprintf+0x1fe>
    3d82:	60 81       	ld	r22, Z
    3d84:	71 81       	ldd	r23, Z+1	; 0x01
    3d86:	82 81       	ldd	r24, Z+2	; 0x02
    3d88:	93 81       	ldd	r25, Z+3	; 0x03
    3d8a:	0c 5f       	subi	r16, 0xFC	; 252
    3d8c:	1f 4f       	sbci	r17, 0xFF	; 255
    3d8e:	08 c0       	rjmp	.+16     	; 0x3da0 <vfprintf+0x20e>
    3d90:	60 81       	ld	r22, Z
    3d92:	71 81       	ldd	r23, Z+1	; 0x01
    3d94:	07 2e       	mov	r0, r23
    3d96:	00 0c       	add	r0, r0
    3d98:	88 0b       	sbc	r24, r24
    3d9a:	99 0b       	sbc	r25, r25
    3d9c:	0e 5f       	subi	r16, 0xFE	; 254
    3d9e:	1f 4f       	sbci	r17, 0xFF	; 255
    3da0:	f3 2d       	mov	r31, r3
    3da2:	ff 76       	andi	r31, 0x6F	; 111
    3da4:	3f 2e       	mov	r3, r31
    3da6:	97 ff       	sbrs	r25, 7
    3da8:	09 c0       	rjmp	.+18     	; 0x3dbc <vfprintf+0x22a>
    3daa:	90 95       	com	r25
    3dac:	80 95       	com	r24
    3dae:	70 95       	com	r23
    3db0:	61 95       	neg	r22
    3db2:	7f 4f       	sbci	r23, 0xFF	; 255
    3db4:	8f 4f       	sbci	r24, 0xFF	; 255
    3db6:	9f 4f       	sbci	r25, 0xFF	; 255
    3db8:	f0 68       	ori	r31, 0x80	; 128
    3dba:	3f 2e       	mov	r3, r31
    3dbc:	2a e0       	ldi	r18, 0x0A	; 10
    3dbe:	30 e0       	ldi	r19, 0x00	; 0
    3dc0:	a3 01       	movw	r20, r6
    3dc2:	30 d1       	rcall	.+608    	; 0x4024 <__ultoa_invert>
    3dc4:	88 2e       	mov	r8, r24
    3dc6:	86 18       	sub	r8, r6
    3dc8:	44 c0       	rjmp	.+136    	; 0x3e52 <vfprintf+0x2c0>
    3dca:	85 37       	cpi	r24, 0x75	; 117
    3dcc:	31 f4       	brne	.+12     	; 0x3dda <vfprintf+0x248>
    3dce:	23 2d       	mov	r18, r3
    3dd0:	2f 7e       	andi	r18, 0xEF	; 239
    3dd2:	b2 2e       	mov	r11, r18
    3dd4:	2a e0       	ldi	r18, 0x0A	; 10
    3dd6:	30 e0       	ldi	r19, 0x00	; 0
    3dd8:	25 c0       	rjmp	.+74     	; 0x3e24 <vfprintf+0x292>
    3dda:	93 2d       	mov	r25, r3
    3ddc:	99 7f       	andi	r25, 0xF9	; 249
    3dde:	b9 2e       	mov	r11, r25
    3de0:	8f 36       	cpi	r24, 0x6F	; 111
    3de2:	c1 f0       	breq	.+48     	; 0x3e14 <vfprintf+0x282>
    3de4:	18 f4       	brcc	.+6      	; 0x3dec <vfprintf+0x25a>
    3de6:	88 35       	cpi	r24, 0x58	; 88
    3de8:	79 f0       	breq	.+30     	; 0x3e08 <vfprintf+0x276>
    3dea:	ae c0       	rjmp	.+348    	; 0x3f48 <vfprintf+0x3b6>
    3dec:	80 37       	cpi	r24, 0x70	; 112
    3dee:	19 f0       	breq	.+6      	; 0x3df6 <vfprintf+0x264>
    3df0:	88 37       	cpi	r24, 0x78	; 120
    3df2:	21 f0       	breq	.+8      	; 0x3dfc <vfprintf+0x26a>
    3df4:	a9 c0       	rjmp	.+338    	; 0x3f48 <vfprintf+0x3b6>
    3df6:	e9 2f       	mov	r30, r25
    3df8:	e0 61       	ori	r30, 0x10	; 16
    3dfa:	be 2e       	mov	r11, r30
    3dfc:	b4 fe       	sbrs	r11, 4
    3dfe:	0d c0       	rjmp	.+26     	; 0x3e1a <vfprintf+0x288>
    3e00:	fb 2d       	mov	r31, r11
    3e02:	f4 60       	ori	r31, 0x04	; 4
    3e04:	bf 2e       	mov	r11, r31
    3e06:	09 c0       	rjmp	.+18     	; 0x3e1a <vfprintf+0x288>
    3e08:	34 fe       	sbrs	r3, 4
    3e0a:	0a c0       	rjmp	.+20     	; 0x3e20 <vfprintf+0x28e>
    3e0c:	29 2f       	mov	r18, r25
    3e0e:	26 60       	ori	r18, 0x06	; 6
    3e10:	b2 2e       	mov	r11, r18
    3e12:	06 c0       	rjmp	.+12     	; 0x3e20 <vfprintf+0x28e>
    3e14:	28 e0       	ldi	r18, 0x08	; 8
    3e16:	30 e0       	ldi	r19, 0x00	; 0
    3e18:	05 c0       	rjmp	.+10     	; 0x3e24 <vfprintf+0x292>
    3e1a:	20 e1       	ldi	r18, 0x10	; 16
    3e1c:	30 e0       	ldi	r19, 0x00	; 0
    3e1e:	02 c0       	rjmp	.+4      	; 0x3e24 <vfprintf+0x292>
    3e20:	20 e1       	ldi	r18, 0x10	; 16
    3e22:	32 e0       	ldi	r19, 0x02	; 2
    3e24:	f8 01       	movw	r30, r16
    3e26:	b7 fe       	sbrs	r11, 7
    3e28:	07 c0       	rjmp	.+14     	; 0x3e38 <vfprintf+0x2a6>
    3e2a:	60 81       	ld	r22, Z
    3e2c:	71 81       	ldd	r23, Z+1	; 0x01
    3e2e:	82 81       	ldd	r24, Z+2	; 0x02
    3e30:	93 81       	ldd	r25, Z+3	; 0x03
    3e32:	0c 5f       	subi	r16, 0xFC	; 252
    3e34:	1f 4f       	sbci	r17, 0xFF	; 255
    3e36:	06 c0       	rjmp	.+12     	; 0x3e44 <vfprintf+0x2b2>
    3e38:	60 81       	ld	r22, Z
    3e3a:	71 81       	ldd	r23, Z+1	; 0x01
    3e3c:	80 e0       	ldi	r24, 0x00	; 0
    3e3e:	90 e0       	ldi	r25, 0x00	; 0
    3e40:	0e 5f       	subi	r16, 0xFE	; 254
    3e42:	1f 4f       	sbci	r17, 0xFF	; 255
    3e44:	a3 01       	movw	r20, r6
    3e46:	ee d0       	rcall	.+476    	; 0x4024 <__ultoa_invert>
    3e48:	88 2e       	mov	r8, r24
    3e4a:	86 18       	sub	r8, r6
    3e4c:	fb 2d       	mov	r31, r11
    3e4e:	ff 77       	andi	r31, 0x7F	; 127
    3e50:	3f 2e       	mov	r3, r31
    3e52:	36 fe       	sbrs	r3, 6
    3e54:	0d c0       	rjmp	.+26     	; 0x3e70 <vfprintf+0x2de>
    3e56:	23 2d       	mov	r18, r3
    3e58:	2e 7f       	andi	r18, 0xFE	; 254
    3e5a:	a2 2e       	mov	r10, r18
    3e5c:	89 14       	cp	r8, r9
    3e5e:	58 f4       	brcc	.+22     	; 0x3e76 <vfprintf+0x2e4>
    3e60:	34 fe       	sbrs	r3, 4
    3e62:	0b c0       	rjmp	.+22     	; 0x3e7a <vfprintf+0x2e8>
    3e64:	32 fc       	sbrc	r3, 2
    3e66:	09 c0       	rjmp	.+18     	; 0x3e7a <vfprintf+0x2e8>
    3e68:	83 2d       	mov	r24, r3
    3e6a:	8e 7e       	andi	r24, 0xEE	; 238
    3e6c:	a8 2e       	mov	r10, r24
    3e6e:	05 c0       	rjmp	.+10     	; 0x3e7a <vfprintf+0x2e8>
    3e70:	b8 2c       	mov	r11, r8
    3e72:	a3 2c       	mov	r10, r3
    3e74:	03 c0       	rjmp	.+6      	; 0x3e7c <vfprintf+0x2ea>
    3e76:	b8 2c       	mov	r11, r8
    3e78:	01 c0       	rjmp	.+2      	; 0x3e7c <vfprintf+0x2ea>
    3e7a:	b9 2c       	mov	r11, r9
    3e7c:	a4 fe       	sbrs	r10, 4
    3e7e:	0f c0       	rjmp	.+30     	; 0x3e9e <vfprintf+0x30c>
    3e80:	fe 01       	movw	r30, r28
    3e82:	e8 0d       	add	r30, r8
    3e84:	f1 1d       	adc	r31, r1
    3e86:	80 81       	ld	r24, Z
    3e88:	80 33       	cpi	r24, 0x30	; 48
    3e8a:	21 f4       	brne	.+8      	; 0x3e94 <vfprintf+0x302>
    3e8c:	9a 2d       	mov	r25, r10
    3e8e:	99 7e       	andi	r25, 0xE9	; 233
    3e90:	a9 2e       	mov	r10, r25
    3e92:	09 c0       	rjmp	.+18     	; 0x3ea6 <vfprintf+0x314>
    3e94:	a2 fe       	sbrs	r10, 2
    3e96:	06 c0       	rjmp	.+12     	; 0x3ea4 <vfprintf+0x312>
    3e98:	b3 94       	inc	r11
    3e9a:	b3 94       	inc	r11
    3e9c:	04 c0       	rjmp	.+8      	; 0x3ea6 <vfprintf+0x314>
    3e9e:	8a 2d       	mov	r24, r10
    3ea0:	86 78       	andi	r24, 0x86	; 134
    3ea2:	09 f0       	breq	.+2      	; 0x3ea6 <vfprintf+0x314>
    3ea4:	b3 94       	inc	r11
    3ea6:	a3 fc       	sbrc	r10, 3
    3ea8:	10 c0       	rjmp	.+32     	; 0x3eca <vfprintf+0x338>
    3eaa:	a0 fe       	sbrs	r10, 0
    3eac:	06 c0       	rjmp	.+12     	; 0x3eba <vfprintf+0x328>
    3eae:	b2 14       	cp	r11, r2
    3eb0:	80 f4       	brcc	.+32     	; 0x3ed2 <vfprintf+0x340>
    3eb2:	28 0c       	add	r2, r8
    3eb4:	92 2c       	mov	r9, r2
    3eb6:	9b 18       	sub	r9, r11
    3eb8:	0d c0       	rjmp	.+26     	; 0x3ed4 <vfprintf+0x342>
    3eba:	b2 14       	cp	r11, r2
    3ebc:	58 f4       	brcc	.+22     	; 0x3ed4 <vfprintf+0x342>
    3ebe:	b6 01       	movw	r22, r12
    3ec0:	80 e2       	ldi	r24, 0x20	; 32
    3ec2:	90 e0       	ldi	r25, 0x00	; 0
    3ec4:	73 d0       	rcall	.+230    	; 0x3fac <fputc>
    3ec6:	b3 94       	inc	r11
    3ec8:	f8 cf       	rjmp	.-16     	; 0x3eba <vfprintf+0x328>
    3eca:	b2 14       	cp	r11, r2
    3ecc:	18 f4       	brcc	.+6      	; 0x3ed4 <vfprintf+0x342>
    3ece:	2b 18       	sub	r2, r11
    3ed0:	02 c0       	rjmp	.+4      	; 0x3ed6 <vfprintf+0x344>
    3ed2:	98 2c       	mov	r9, r8
    3ed4:	21 2c       	mov	r2, r1
    3ed6:	a4 fe       	sbrs	r10, 4
    3ed8:	0f c0       	rjmp	.+30     	; 0x3ef8 <vfprintf+0x366>
    3eda:	b6 01       	movw	r22, r12
    3edc:	80 e3       	ldi	r24, 0x30	; 48
    3ede:	90 e0       	ldi	r25, 0x00	; 0
    3ee0:	65 d0       	rcall	.+202    	; 0x3fac <fputc>
    3ee2:	a2 fe       	sbrs	r10, 2
    3ee4:	16 c0       	rjmp	.+44     	; 0x3f12 <vfprintf+0x380>
    3ee6:	a1 fc       	sbrc	r10, 1
    3ee8:	03 c0       	rjmp	.+6      	; 0x3ef0 <vfprintf+0x35e>
    3eea:	88 e7       	ldi	r24, 0x78	; 120
    3eec:	90 e0       	ldi	r25, 0x00	; 0
    3eee:	02 c0       	rjmp	.+4      	; 0x3ef4 <vfprintf+0x362>
    3ef0:	88 e5       	ldi	r24, 0x58	; 88
    3ef2:	90 e0       	ldi	r25, 0x00	; 0
    3ef4:	b6 01       	movw	r22, r12
    3ef6:	0c c0       	rjmp	.+24     	; 0x3f10 <vfprintf+0x37e>
    3ef8:	8a 2d       	mov	r24, r10
    3efa:	86 78       	andi	r24, 0x86	; 134
    3efc:	51 f0       	breq	.+20     	; 0x3f12 <vfprintf+0x380>
    3efe:	a1 fe       	sbrs	r10, 1
    3f00:	02 c0       	rjmp	.+4      	; 0x3f06 <vfprintf+0x374>
    3f02:	8b e2       	ldi	r24, 0x2B	; 43
    3f04:	01 c0       	rjmp	.+2      	; 0x3f08 <vfprintf+0x376>
    3f06:	80 e2       	ldi	r24, 0x20	; 32
    3f08:	a7 fc       	sbrc	r10, 7
    3f0a:	8d e2       	ldi	r24, 0x2D	; 45
    3f0c:	b6 01       	movw	r22, r12
    3f0e:	90 e0       	ldi	r25, 0x00	; 0
    3f10:	4d d0       	rcall	.+154    	; 0x3fac <fputc>
    3f12:	89 14       	cp	r8, r9
    3f14:	30 f4       	brcc	.+12     	; 0x3f22 <vfprintf+0x390>
    3f16:	b6 01       	movw	r22, r12
    3f18:	80 e3       	ldi	r24, 0x30	; 48
    3f1a:	90 e0       	ldi	r25, 0x00	; 0
    3f1c:	47 d0       	rcall	.+142    	; 0x3fac <fputc>
    3f1e:	9a 94       	dec	r9
    3f20:	f8 cf       	rjmp	.-16     	; 0x3f12 <vfprintf+0x380>
    3f22:	8a 94       	dec	r8
    3f24:	f3 01       	movw	r30, r6
    3f26:	e8 0d       	add	r30, r8
    3f28:	f1 1d       	adc	r31, r1
    3f2a:	80 81       	ld	r24, Z
    3f2c:	b6 01       	movw	r22, r12
    3f2e:	90 e0       	ldi	r25, 0x00	; 0
    3f30:	3d d0       	rcall	.+122    	; 0x3fac <fputc>
    3f32:	81 10       	cpse	r8, r1
    3f34:	f6 cf       	rjmp	.-20     	; 0x3f22 <vfprintf+0x390>
    3f36:	22 20       	and	r2, r2
    3f38:	09 f4       	brne	.+2      	; 0x3f3c <vfprintf+0x3aa>
    3f3a:	4e ce       	rjmp	.-868    	; 0x3bd8 <vfprintf+0x46>
    3f3c:	b6 01       	movw	r22, r12
    3f3e:	80 e2       	ldi	r24, 0x20	; 32
    3f40:	90 e0       	ldi	r25, 0x00	; 0
    3f42:	34 d0       	rcall	.+104    	; 0x3fac <fputc>
    3f44:	2a 94       	dec	r2
    3f46:	f7 cf       	rjmp	.-18     	; 0x3f36 <vfprintf+0x3a4>
    3f48:	f6 01       	movw	r30, r12
    3f4a:	86 81       	ldd	r24, Z+6	; 0x06
    3f4c:	97 81       	ldd	r25, Z+7	; 0x07
    3f4e:	02 c0       	rjmp	.+4      	; 0x3f54 <vfprintf+0x3c2>
    3f50:	8f ef       	ldi	r24, 0xFF	; 255
    3f52:	9f ef       	ldi	r25, 0xFF	; 255
    3f54:	2b 96       	adiw	r28, 0x0b	; 11
    3f56:	cd bf       	out	0x3d, r28	; 61
    3f58:	de bf       	out	0x3e, r29	; 62
    3f5a:	df 91       	pop	r29
    3f5c:	cf 91       	pop	r28
    3f5e:	1f 91       	pop	r17
    3f60:	0f 91       	pop	r16
    3f62:	ff 90       	pop	r15
    3f64:	ef 90       	pop	r14
    3f66:	df 90       	pop	r13
    3f68:	cf 90       	pop	r12
    3f6a:	bf 90       	pop	r11
    3f6c:	af 90       	pop	r10
    3f6e:	9f 90       	pop	r9
    3f70:	8f 90       	pop	r8
    3f72:	7f 90       	pop	r7
    3f74:	6f 90       	pop	r6
    3f76:	5f 90       	pop	r5
    3f78:	4f 90       	pop	r4
    3f7a:	3f 90       	pop	r3
    3f7c:	2f 90       	pop	r2
    3f7e:	08 95       	ret

00003f80 <strnlen_P>:
    3f80:	fc 01       	movw	r30, r24
    3f82:	05 90       	lpm	r0, Z+
    3f84:	61 50       	subi	r22, 0x01	; 1
    3f86:	70 40       	sbci	r23, 0x00	; 0
    3f88:	01 10       	cpse	r0, r1
    3f8a:	d8 f7       	brcc	.-10     	; 0x3f82 <strnlen_P+0x2>
    3f8c:	80 95       	com	r24
    3f8e:	90 95       	com	r25
    3f90:	8e 0f       	add	r24, r30
    3f92:	9f 1f       	adc	r25, r31
    3f94:	08 95       	ret

00003f96 <strnlen>:
    3f96:	fc 01       	movw	r30, r24
    3f98:	61 50       	subi	r22, 0x01	; 1
    3f9a:	70 40       	sbci	r23, 0x00	; 0
    3f9c:	01 90       	ld	r0, Z+
    3f9e:	01 10       	cpse	r0, r1
    3fa0:	d8 f7       	brcc	.-10     	; 0x3f98 <strnlen+0x2>
    3fa2:	80 95       	com	r24
    3fa4:	90 95       	com	r25
    3fa6:	8e 0f       	add	r24, r30
    3fa8:	9f 1f       	adc	r25, r31
    3faa:	08 95       	ret

00003fac <fputc>:
    3fac:	0f 93       	push	r16
    3fae:	1f 93       	push	r17
    3fb0:	cf 93       	push	r28
    3fb2:	df 93       	push	r29
    3fb4:	fb 01       	movw	r30, r22
    3fb6:	23 81       	ldd	r18, Z+3	; 0x03
    3fb8:	21 fd       	sbrc	r18, 1
    3fba:	03 c0       	rjmp	.+6      	; 0x3fc2 <fputc+0x16>
    3fbc:	8f ef       	ldi	r24, 0xFF	; 255
    3fbe:	9f ef       	ldi	r25, 0xFF	; 255
    3fc0:	2c c0       	rjmp	.+88     	; 0x401a <fputc+0x6e>
    3fc2:	22 ff       	sbrs	r18, 2
    3fc4:	16 c0       	rjmp	.+44     	; 0x3ff2 <fputc+0x46>
    3fc6:	46 81       	ldd	r20, Z+6	; 0x06
    3fc8:	57 81       	ldd	r21, Z+7	; 0x07
    3fca:	24 81       	ldd	r18, Z+4	; 0x04
    3fcc:	35 81       	ldd	r19, Z+5	; 0x05
    3fce:	42 17       	cp	r20, r18
    3fd0:	53 07       	cpc	r21, r19
    3fd2:	44 f4       	brge	.+16     	; 0x3fe4 <fputc+0x38>
    3fd4:	a0 81       	ld	r26, Z
    3fd6:	b1 81       	ldd	r27, Z+1	; 0x01
    3fd8:	9d 01       	movw	r18, r26
    3fda:	2f 5f       	subi	r18, 0xFF	; 255
    3fdc:	3f 4f       	sbci	r19, 0xFF	; 255
    3fde:	20 83       	st	Z, r18
    3fe0:	31 83       	std	Z+1, r19	; 0x01
    3fe2:	8c 93       	st	X, r24
    3fe4:	26 81       	ldd	r18, Z+6	; 0x06
    3fe6:	37 81       	ldd	r19, Z+7	; 0x07
    3fe8:	2f 5f       	subi	r18, 0xFF	; 255
    3fea:	3f 4f       	sbci	r19, 0xFF	; 255
    3fec:	26 83       	std	Z+6, r18	; 0x06
    3fee:	37 83       	std	Z+7, r19	; 0x07
    3ff0:	14 c0       	rjmp	.+40     	; 0x401a <fputc+0x6e>
    3ff2:	8b 01       	movw	r16, r22
    3ff4:	ec 01       	movw	r28, r24
    3ff6:	fb 01       	movw	r30, r22
    3ff8:	00 84       	ldd	r0, Z+8	; 0x08
    3ffa:	f1 85       	ldd	r31, Z+9	; 0x09
    3ffc:	e0 2d       	mov	r30, r0
    3ffe:	19 95       	eicall
    4000:	89 2b       	or	r24, r25
    4002:	e1 f6       	brne	.-72     	; 0x3fbc <fputc+0x10>
    4004:	d8 01       	movw	r26, r16
    4006:	16 96       	adiw	r26, 0x06	; 6
    4008:	8d 91       	ld	r24, X+
    400a:	9c 91       	ld	r25, X
    400c:	17 97       	sbiw	r26, 0x07	; 7
    400e:	01 96       	adiw	r24, 0x01	; 1
    4010:	16 96       	adiw	r26, 0x06	; 6
    4012:	8d 93       	st	X+, r24
    4014:	9c 93       	st	X, r25
    4016:	17 97       	sbiw	r26, 0x07	; 7
    4018:	ce 01       	movw	r24, r28
    401a:	df 91       	pop	r29
    401c:	cf 91       	pop	r28
    401e:	1f 91       	pop	r17
    4020:	0f 91       	pop	r16
    4022:	08 95       	ret

00004024 <__ultoa_invert>:
    4024:	fa 01       	movw	r30, r20
    4026:	aa 27       	eor	r26, r26
    4028:	28 30       	cpi	r18, 0x08	; 8
    402a:	51 f1       	breq	.+84     	; 0x4080 <__ultoa_invert+0x5c>
    402c:	20 31       	cpi	r18, 0x10	; 16
    402e:	81 f1       	breq	.+96     	; 0x4090 <__ultoa_invert+0x6c>
    4030:	e8 94       	clt
    4032:	6f 93       	push	r22
    4034:	6e 7f       	andi	r22, 0xFE	; 254
    4036:	6e 5f       	subi	r22, 0xFE	; 254
    4038:	7f 4f       	sbci	r23, 0xFF	; 255
    403a:	8f 4f       	sbci	r24, 0xFF	; 255
    403c:	9f 4f       	sbci	r25, 0xFF	; 255
    403e:	af 4f       	sbci	r26, 0xFF	; 255
    4040:	b1 e0       	ldi	r27, 0x01	; 1
    4042:	3e d0       	rcall	.+124    	; 0x40c0 <__ultoa_invert+0x9c>
    4044:	b4 e0       	ldi	r27, 0x04	; 4
    4046:	3c d0       	rcall	.+120    	; 0x40c0 <__ultoa_invert+0x9c>
    4048:	67 0f       	add	r22, r23
    404a:	78 1f       	adc	r23, r24
    404c:	89 1f       	adc	r24, r25
    404e:	9a 1f       	adc	r25, r26
    4050:	a1 1d       	adc	r26, r1
    4052:	68 0f       	add	r22, r24
    4054:	79 1f       	adc	r23, r25
    4056:	8a 1f       	adc	r24, r26
    4058:	91 1d       	adc	r25, r1
    405a:	a1 1d       	adc	r26, r1
    405c:	6a 0f       	add	r22, r26
    405e:	71 1d       	adc	r23, r1
    4060:	81 1d       	adc	r24, r1
    4062:	91 1d       	adc	r25, r1
    4064:	a1 1d       	adc	r26, r1
    4066:	20 d0       	rcall	.+64     	; 0x40a8 <__ultoa_invert+0x84>
    4068:	09 f4       	brne	.+2      	; 0x406c <__ultoa_invert+0x48>
    406a:	68 94       	set
    406c:	3f 91       	pop	r19
    406e:	2a e0       	ldi	r18, 0x0A	; 10
    4070:	26 9f       	mul	r18, r22
    4072:	11 24       	eor	r1, r1
    4074:	30 19       	sub	r19, r0
    4076:	30 5d       	subi	r19, 0xD0	; 208
    4078:	31 93       	st	Z+, r19
    407a:	de f6       	brtc	.-74     	; 0x4032 <__ultoa_invert+0xe>
    407c:	cf 01       	movw	r24, r30
    407e:	08 95       	ret
    4080:	46 2f       	mov	r20, r22
    4082:	47 70       	andi	r20, 0x07	; 7
    4084:	40 5d       	subi	r20, 0xD0	; 208
    4086:	41 93       	st	Z+, r20
    4088:	b3 e0       	ldi	r27, 0x03	; 3
    408a:	0f d0       	rcall	.+30     	; 0x40aa <__ultoa_invert+0x86>
    408c:	c9 f7       	brne	.-14     	; 0x4080 <__ultoa_invert+0x5c>
    408e:	f6 cf       	rjmp	.-20     	; 0x407c <__ultoa_invert+0x58>
    4090:	46 2f       	mov	r20, r22
    4092:	4f 70       	andi	r20, 0x0F	; 15
    4094:	40 5d       	subi	r20, 0xD0	; 208
    4096:	4a 33       	cpi	r20, 0x3A	; 58
    4098:	18 f0       	brcs	.+6      	; 0x40a0 <__ultoa_invert+0x7c>
    409a:	49 5d       	subi	r20, 0xD9	; 217
    409c:	31 fd       	sbrc	r19, 1
    409e:	40 52       	subi	r20, 0x20	; 32
    40a0:	41 93       	st	Z+, r20
    40a2:	02 d0       	rcall	.+4      	; 0x40a8 <__ultoa_invert+0x84>
    40a4:	a9 f7       	brne	.-22     	; 0x4090 <__ultoa_invert+0x6c>
    40a6:	ea cf       	rjmp	.-44     	; 0x407c <__ultoa_invert+0x58>
    40a8:	b4 e0       	ldi	r27, 0x04	; 4
    40aa:	a6 95       	lsr	r26
    40ac:	97 95       	ror	r25
    40ae:	87 95       	ror	r24
    40b0:	77 95       	ror	r23
    40b2:	67 95       	ror	r22
    40b4:	ba 95       	dec	r27
    40b6:	c9 f7       	brne	.-14     	; 0x40aa <__ultoa_invert+0x86>
    40b8:	00 97       	sbiw	r24, 0x00	; 0
    40ba:	61 05       	cpc	r22, r1
    40bc:	71 05       	cpc	r23, r1
    40be:	08 95       	ret
    40c0:	9b 01       	movw	r18, r22
    40c2:	ac 01       	movw	r20, r24
    40c4:	0a 2e       	mov	r0, r26
    40c6:	06 94       	lsr	r0
    40c8:	57 95       	ror	r21
    40ca:	47 95       	ror	r20
    40cc:	37 95       	ror	r19
    40ce:	27 95       	ror	r18
    40d0:	ba 95       	dec	r27
    40d2:	c9 f7       	brne	.-14     	; 0x40c6 <__ultoa_invert+0xa2>
    40d4:	62 0f       	add	r22, r18
    40d6:	73 1f       	adc	r23, r19
    40d8:	84 1f       	adc	r24, r20
    40da:	95 1f       	adc	r25, r21
    40dc:	a0 1d       	adc	r26, r0
    40de:	08 95       	ret

000040e0 <_exit>:
    40e0:	f8 94       	cli

000040e2 <__stop_program>:
    40e2:	ff cf       	rjmp	.-2      	; 0x40e2 <__stop_program>
