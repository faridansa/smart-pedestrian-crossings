
Praktikum_5_Template_6_2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003920  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000040  00802000  00003920  000039b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002e8  00802040  00802040  000039f4  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000039f4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00003a24  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006b8  00000000  00000000  00003a68  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001524e  00000000  00000000  00004120  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005e62  00000000  00000000  0001936e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b253  00000000  00000000  0001f1d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001680  00000000  00000000  0002a424  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00038a1b  00000000  00000000  0002baa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000a8e7  00000000  00000000  000644bf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000830  00000000  00000000  0006eda8  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000caad  00000000  00000000  0006f5d8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 93 0f 	jmp	0x1f26	; 0x1f26 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d2 c7       	rjmp	.+4004   	; 0x1042 <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__vector_40>
      a4:	0c 94 85 08 	jmp	0x110a	; 0x110a <__vector_41>
      a8:	0c 94 b7 08 	jmp	0x116e	; 0x116e <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	ca c6       	rjmp	.+3476   	; 0xeb2 <__vector_71>
     11e:	00 00       	nop
     120:	fa c6       	rjmp	.+3572   	; 0xf16 <__vector_72>
     122:	00 00       	nop
     124:	2a c7       	rjmp	.+3668   	; 0xf7a <__vector_73>
     126:	00 00       	nop
     128:	5a c7       	rjmp	.+3764   	; 0xfde <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	96 18       	sub	r9, r6
     1fe:	96 18       	sub	r9, r6
     200:	96 18       	sub	r9, r6
     202:	cc 18       	sub	r12, r12
     204:	bc 18       	sub	r11, r12
     206:	c9 18       	sub	r12, r9
     208:	96 18       	sub	r9, r6
     20a:	96 18       	sub	r9, r6
     20c:	cc 18       	sub	r12, r12
     20e:	bc 18       	sub	r11, r12

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1d78>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x6560>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x6538>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x5560>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1d38>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e0 e2       	ldi	r30, 0x20	; 32
     4ba:	f9 e3       	ldi	r31, 0x39	; 57
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a0 34       	cpi	r26, 0x40	; 64
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a0 e4       	ldi	r26, 0x40	; 64
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a8 32       	cpi	r26, 0x28	; 40
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 46 1a 	call	0x348c	; 0x348c <main>
     4e0:	0c 94 8e 1c 	jmp	0x391c	; 0x391c <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	do { barrier(); } while (--n);
     4e6:	61 50       	subi	r22, 0x01	; 1
     4e8:	71 09       	sbc	r23, r1
     4ea:	81 09       	sbc	r24, r1
     4ec:	91 09       	sbc	r25, r1
     4ee:	d9 f7       	brne	.-10     	; 0x4e6 <__portable_avr_delay_cycles>
}
     4f0:	08 95       	ret

000004f2 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4f2:	bf 92       	push	r11
     4f4:	cf 92       	push	r12
     4f6:	df 92       	push	r13
     4f8:	ef 92       	push	r14
     4fa:	ff 92       	push	r15
     4fc:	0f 93       	push	r16
     4fe:	1f 93       	push	r17
     500:	cf 93       	push	r28
     502:	df 93       	push	r29
     504:	1f 92       	push	r1
     506:	cd b7       	in	r28, 0x3d	; 61
     508:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     50a:	00 e0       	ldi	r16, 0x00	; 0
     50c:	16 e0       	ldi	r17, 0x06	; 6
     50e:	68 94       	set
     510:	ff 24       	eor	r15, r15
     512:	f3 f8       	bld	r15, 3
     514:	f8 01       	movw	r30, r16
     516:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     518:	63 e0       	ldi	r22, 0x03	; 3
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	90 e0       	ldi	r25, 0x00	; 0
     520:	e2 df       	rcall	.-60     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     522:	f8 01       	movw	r30, r16
     524:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     526:	63 e0       	ldi	r22, 0x03	; 3
     528:	70 e0       	ldi	r23, 0x00	; 0
     52a:	80 e0       	ldi	r24, 0x00	; 0
     52c:	90 e0       	ldi	r25, 0x00	; 0
     52e:	db df       	rcall	.-74     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     530:	0f 2e       	mov	r0, r31
     532:	fb e2       	ldi	r31, 0x2B	; 43
     534:	bf 2e       	mov	r11, r31
     536:	f0 2d       	mov	r31, r0
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     538:	b9 82       	std	Y+1, r11	; 0x01
     53a:	80 ea       	ldi	r24, 0xA0	; 160
     53c:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     53e:	08 d4       	rcall	.+2064   	; 0xd50 <usart_spi_init>
     540:	c1 2c       	mov	r12, r1
     542:	d1 2c       	mov	r13, r1
     544:	76 01       	movw	r14, r12
     546:	00 e4       	ldi	r16, 0x40	; 64
     548:	12 e4       	ldi	r17, 0x42	; 66
     54a:	2f e0       	ldi	r18, 0x0F	; 15
     54c:	30 e0       	ldi	r19, 0x00	; 0
     54e:	43 e0       	ldi	r20, 0x03	; 3
     550:	be 01       	movw	r22, r28
     552:	6f 5f       	subi	r22, 0xFF	; 255
     554:	7f 4f       	sbci	r23, 0xFF	; 255
     556:	80 ea       	ldi	r24, 0xA0	; 160
     558:	99 e0       	ldi	r25, 0x09	; 9
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     55a:	29 d4       	rcall	.+2130   	; 0xdae <usart_spi_setup_device>
     55c:	00 e6       	ldi	r16, 0x60	; 96
     55e:	16 e0       	ldi	r17, 0x06	; 6
     560:	ff 24       	eor	r15, r15
     562:	f3 94       	inc	r15
     564:	f8 01       	movw	r30, r16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     566:	f6 82       	std	Z+6, r15	; 0x06
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     568:	b9 82       	std	Y+1, r11	; 0x01
     56a:	be 01       	movw	r22, r28
     56c:	6f 5f       	subi	r22, 0xFF	; 255
     56e:	7f 4f       	sbci	r23, 0xFF	; 255
     570:	80 ea       	ldi	r24, 0xA0	; 160
     572:	99 e0       	ldi	r25, 0x09	; 9
     574:	36 d4       	rcall	.+2156   	; 0xde2 <usart_spi_select_device>
     576:	f8 01       	movw	r30, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     578:	f6 82       	std	Z+6, r15	; 0x06
     57a:	e0 ea       	ldi	r30, 0xA0	; 160
     57c:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     57e:	81 81       	ldd	r24, Z+1	; 0x01
     580:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     582:	fd cf       	rjmp	.-6      	; 0x57e <st7565r_init+0x8c>
     584:	80 ea       	ldi	r24, 0xA0	; 160
     586:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     58a:	e0 ea       	ldi	r30, 0xA0	; 160
     58c:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     58e:	81 81       	ldd	r24, Z+1	; 0x01
     590:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     592:	fd cf       	rjmp	.-6      	; 0x58e <st7565r_init+0x9c>
     594:	e0 ea       	ldi	r30, 0xA0	; 160
     596:	f9 e0       	ldi	r31, 0x09	; 9
     598:	80 e4       	ldi	r24, 0x40	; 64
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     59a:	81 83       	std	Z+1, r24	; 0x01
     59c:	80 81       	ld	r24, Z
     59e:	be 01       	movw	r22, r28
     5a0:	6f 5f       	subi	r22, 0xFF	; 255
     5a2:	7f 4f       	sbci	r23, 0xFF	; 255
     5a4:	80 ea       	ldi	r24, 0xA0	; 160
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5a6:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5a8:	32 d4       	rcall	.+2148   	; 0xe0e <usart_spi_deselect_device>
     5aa:	8b e2       	ldi	r24, 0x2B	; 43
     5ac:	89 83       	std	Y+1, r24	; 0x01
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5f       	subi	r22, 0xFF	; 255
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	80 ea       	ldi	r24, 0xA0	; 160
     5b6:	99 e0       	ldi	r25, 0x09	; 9
     5b8:	14 d4       	rcall	.+2088   	; 0xde2 <usart_spi_select_device>
     5ba:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5bc:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     5c0:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5c2:	f9 e0       	ldi	r31, 0x09	; 9
     5c4:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5c6:	85 ff       	sbrs	r24, 5
     5c8:	fd cf       	rjmp	.-6      	; 0x5c4 <st7565r_init+0xd2>
     5ca:	86 ea       	ldi	r24, 0xA6	; 166
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5cc:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     5d0:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5d2:	f9 e0       	ldi	r31, 0x09	; 9
     5d4:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5d6:	86 ff       	sbrs	r24, 6
     5d8:	fd cf       	rjmp	.-6      	; 0x5d4 <st7565r_init+0xe2>
     5da:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5dc:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5de:	80 e4       	ldi	r24, 0x40	; 64
     5e0:	81 83       	std	Z+1, r24	; 0x01
     5e2:	80 81       	ld	r24, Z
     5e4:	be 01       	movw	r22, r28
     5e6:	6f 5f       	subi	r22, 0xFF	; 255
     5e8:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5ea:	80 ea       	ldi	r24, 0xA0	; 160
     5ec:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5ee:	0f d4       	rcall	.+2078   	; 0xe0e <usart_spi_deselect_device>
     5f0:	8b e2       	ldi	r24, 0x2B	; 43
     5f2:	89 83       	std	Y+1, r24	; 0x01
     5f4:	be 01       	movw	r22, r28
     5f6:	6f 5f       	subi	r22, 0xFF	; 255
     5f8:	7f 4f       	sbci	r23, 0xFF	; 255
     5fa:	80 ea       	ldi	r24, 0xA0	; 160
     5fc:	99 e0       	ldi	r25, 0x09	; 9
     5fe:	f1 d3       	rcall	.+2018   	; 0xde2 <usart_spi_select_device>
     600:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     602:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     606:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     608:	f9 e0       	ldi	r31, 0x09	; 9
     60a:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     60c:	85 ff       	sbrs	r24, 5
     60e:	fd cf       	rjmp	.-6      	; 0x60a <st7565r_init+0x118>
     610:	88 ec       	ldi	r24, 0xC8	; 200
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     612:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     616:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     618:	f9 e0       	ldi	r31, 0x09	; 9
     61a:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     61c:	86 ff       	sbrs	r24, 6
     61e:	fd cf       	rjmp	.-6      	; 0x61a <st7565r_init+0x128>
     620:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     622:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     624:	80 e4       	ldi	r24, 0x40	; 64
     626:	81 83       	std	Z+1, r24	; 0x01
     628:	80 81       	ld	r24, Z
     62a:	be 01       	movw	r22, r28
     62c:	6f 5f       	subi	r22, 0xFF	; 255
     62e:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     630:	80 ea       	ldi	r24, 0xA0	; 160
     632:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     634:	ec d3       	rcall	.+2008   	; 0xe0e <usart_spi_deselect_device>
     636:	8b e2       	ldi	r24, 0x2B	; 43
     638:	89 83       	std	Y+1, r24	; 0x01
     63a:	be 01       	movw	r22, r28
     63c:	6f 5f       	subi	r22, 0xFF	; 255
     63e:	7f 4f       	sbci	r23, 0xFF	; 255
     640:	80 ea       	ldi	r24, 0xA0	; 160
     642:	99 e0       	ldi	r25, 0x09	; 9
     644:	ce d3       	rcall	.+1948   	; 0xde2 <usart_spi_select_device>
     646:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     648:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     64c:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     64e:	f9 e0       	ldi	r31, 0x09	; 9
     650:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     652:	85 ff       	sbrs	r24, 5
     654:	fd cf       	rjmp	.-6      	; 0x650 <st7565r_init+0x15e>
     656:	82 ea       	ldi	r24, 0xA2	; 162
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     658:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     65c:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     65e:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     660:	81 81       	ldd	r24, Z+1	; 0x01
     662:	86 ff       	sbrs	r24, 6
     664:	fd cf       	rjmp	.-6      	; 0x660 <st7565r_init+0x16e>
     666:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     668:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     66a:	80 e4       	ldi	r24, 0x40	; 64
     66c:	81 83       	std	Z+1, r24	; 0x01
     66e:	80 81       	ld	r24, Z
     670:	be 01       	movw	r22, r28
     672:	6f 5f       	subi	r22, 0xFF	; 255
     674:	7f 4f       	sbci	r23, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     676:	80 ea       	ldi	r24, 0xA0	; 160
     678:	99 e0       	ldi	r25, 0x09	; 9
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     67a:	c9 d3       	rcall	.+1938   	; 0xe0e <usart_spi_deselect_device>
     67c:	8b e2       	ldi	r24, 0x2B	; 43
     67e:	89 83       	std	Y+1, r24	; 0x01
     680:	be 01       	movw	r22, r28
     682:	6f 5f       	subi	r22, 0xFF	; 255
     684:	7f 4f       	sbci	r23, 0xFF	; 255
     686:	80 ea       	ldi	r24, 0xA0	; 160
     688:	99 e0       	ldi	r25, 0x09	; 9
     68a:	ab d3       	rcall	.+1878   	; 0xde2 <usart_spi_select_device>
     68c:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     68e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     692:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     694:	f9 e0       	ldi	r31, 0x09	; 9
     696:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     698:	85 ff       	sbrs	r24, 5
     69a:	fd cf       	rjmp	.-6      	; 0x696 <st7565r_init+0x1a4>
     69c:	8f e2       	ldi	r24, 0x2F	; 47
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     69e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6a2:	e0 ea       	ldi	r30, 0xA0	; 160
     6a4:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6a6:	81 81       	ldd	r24, Z+1	; 0x01
     6a8:	86 ff       	sbrs	r24, 6
     6aa:	fd cf       	rjmp	.-6      	; 0x6a6 <st7565r_init+0x1b4>
     6ac:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6ae:	f9 e0       	ldi	r31, 0x09	; 9
     6b0:	80 e4       	ldi	r24, 0x40	; 64
     6b2:	81 83       	std	Z+1, r24	; 0x01
     6b4:	80 81       	ld	r24, Z
     6b6:	be 01       	movw	r22, r28
     6b8:	6f 5f       	subi	r22, 0xFF	; 255
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6ba:	7f 4f       	sbci	r23, 0xFF	; 255
     6bc:	80 ea       	ldi	r24, 0xA0	; 160
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6be:	99 e0       	ldi	r25, 0x09	; 9
     6c0:	a6 d3       	rcall	.+1868   	; 0xe0e <usart_spi_deselect_device>
     6c2:	8b e2       	ldi	r24, 0x2B	; 43
     6c4:	89 83       	std	Y+1, r24	; 0x01
     6c6:	be 01       	movw	r22, r28
     6c8:	6f 5f       	subi	r22, 0xFF	; 255
     6ca:	7f 4f       	sbci	r23, 0xFF	; 255
     6cc:	80 ea       	ldi	r24, 0xA0	; 160
     6ce:	99 e0       	ldi	r25, 0x09	; 9
     6d0:	88 d3       	rcall	.+1808   	; 0xde2 <usart_spi_select_device>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6d2:	81 e0       	ldi	r24, 0x01	; 1
     6d4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6d8:	e0 ea       	ldi	r30, 0xA0	; 160
     6da:	f9 e0       	ldi	r31, 0x09	; 9
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6dc:	81 81       	ldd	r24, Z+1	; 0x01
     6de:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6e0:	fd cf       	rjmp	.-6      	; 0x6dc <st7565r_init+0x1ea>
     6e2:	88 ef       	ldi	r24, 0xF8	; 248
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6e4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6e8:	e0 ea       	ldi	r30, 0xA0	; 160
     6ea:	f9 e0       	ldi	r31, 0x09	; 9
     6ec:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6ee:	86 ff       	sbrs	r24, 6
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6f0:	fd cf       	rjmp	.-6      	; 0x6ec <st7565r_init+0x1fa>
     6f2:	e0 ea       	ldi	r30, 0xA0	; 160
     6f4:	f9 e0       	ldi	r31, 0x09	; 9
     6f6:	80 e4       	ldi	r24, 0x40	; 64
     6f8:	81 83       	std	Z+1, r24	; 0x01
     6fa:	80 81       	ld	r24, Z
     6fc:	be 01       	movw	r22, r28
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6fe:	6f 5f       	subi	r22, 0xFF	; 255
     700:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     702:	80 ea       	ldi	r24, 0xA0	; 160
     704:	99 e0       	ldi	r25, 0x09	; 9
     706:	83 d3       	rcall	.+1798   	; 0xe0e <usart_spi_deselect_device>
     708:	8b e2       	ldi	r24, 0x2B	; 43
     70a:	89 83       	std	Y+1, r24	; 0x01
     70c:	be 01       	movw	r22, r28
     70e:	6f 5f       	subi	r22, 0xFF	; 255
     710:	7f 4f       	sbci	r23, 0xFF	; 255
     712:	80 ea       	ldi	r24, 0xA0	; 160
     714:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     716:	65 d3       	rcall	.+1738   	; 0xde2 <usart_spi_select_device>
     718:	81 e0       	ldi	r24, 0x01	; 1
     71a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     71e:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     720:	f9 e0       	ldi	r31, 0x09	; 9
     722:	81 81       	ldd	r24, Z+1	; 0x01
     724:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     726:	fd cf       	rjmp	.-6      	; 0x722 <st7565r_init+0x230>
     728:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     72c:	e0 ea       	ldi	r30, 0xA0	; 160
     72e:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     730:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     732:	86 ff       	sbrs	r24, 6
     734:	fd cf       	rjmp	.-6      	; 0x730 <st7565r_init+0x23e>
     736:	e0 ea       	ldi	r30, 0xA0	; 160
     738:	f9 e0       	ldi	r31, 0x09	; 9
     73a:	80 e4       	ldi	r24, 0x40	; 64
     73c:	81 83       	std	Z+1, r24	; 0x01
     73e:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     740:	be 01       	movw	r22, r28
     742:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     744:	7f 4f       	sbci	r23, 0xFF	; 255
     746:	80 ea       	ldi	r24, 0xA0	; 160
     748:	99 e0       	ldi	r25, 0x09	; 9
     74a:	61 d3       	rcall	.+1730   	; 0xe0e <usart_spi_deselect_device>
     74c:	8b e2       	ldi	r24, 0x2B	; 43
     74e:	89 83       	std	Y+1, r24	; 0x01
     750:	be 01       	movw	r22, r28
     752:	6f 5f       	subi	r22, 0xFF	; 255
     754:	7f 4f       	sbci	r23, 0xFF	; 255
     756:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     758:	99 e0       	ldi	r25, 0x09	; 9
     75a:	43 d3       	rcall	.+1670   	; 0xde2 <usart_spi_select_device>
     75c:	81 e0       	ldi	r24, 0x01	; 1
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     75e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     762:	e0 ea       	ldi	r30, 0xA0	; 160
     764:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     766:	81 81       	ldd	r24, Z+1	; 0x01
     768:	85 ff       	sbrs	r24, 5
     76a:	fd cf       	rjmp	.-6      	; 0x766 <st7565r_init+0x274>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     76c:	81 e2       	ldi	r24, 0x21	; 33
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     76e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     772:	e0 ea       	ldi	r30, 0xA0	; 160
     774:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     776:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     778:	86 ff       	sbrs	r24, 6
     77a:	fd cf       	rjmp	.-6      	; 0x776 <st7565r_init+0x284>
     77c:	e0 ea       	ldi	r30, 0xA0	; 160
     77e:	f9 e0       	ldi	r31, 0x09	; 9
     780:	80 e4       	ldi	r24, 0x40	; 64
     782:	81 83       	std	Z+1, r24	; 0x01
     784:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     786:	be 01       	movw	r22, r28
     788:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     78a:	7f 4f       	sbci	r23, 0xFF	; 255
     78c:	80 ea       	ldi	r24, 0xA0	; 160
     78e:	99 e0       	ldi	r25, 0x09	; 9
     790:	3e d3       	rcall	.+1660   	; 0xe0e <usart_spi_deselect_device>
     792:	8b e2       	ldi	r24, 0x2B	; 43
     794:	89 83       	std	Y+1, r24	; 0x01
     796:	be 01       	movw	r22, r28
     798:	6f 5f       	subi	r22, 0xFF	; 255
     79a:	7f 4f       	sbci	r23, 0xFF	; 255
     79c:	80 ea       	ldi	r24, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     79e:	99 e0       	ldi	r25, 0x09	; 9
     7a0:	20 d3       	rcall	.+1600   	; 0xde2 <usart_spi_select_device>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7a8:	e0 ea       	ldi	r30, 0xA0	; 160
     7aa:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7ac:	81 81       	ldd	r24, Z+1	; 0x01
     7ae:	85 ff       	sbrs	r24, 5
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7b0:	fd cf       	rjmp	.-6      	; 0x7ac <st7565r_init+0x2ba>
     7b2:	81 e8       	ldi	r24, 0x81	; 129
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7b4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     7b8:	e0 ea       	ldi	r30, 0xA0	; 160
     7ba:	f9 e0       	ldi	r31, 0x09	; 9
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7bc:	81 81       	ldd	r24, Z+1	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7be:	86 ff       	sbrs	r24, 6
     7c0:	fd cf       	rjmp	.-6      	; 0x7bc <st7565r_init+0x2ca>
     7c2:	e0 ea       	ldi	r30, 0xA0	; 160
     7c4:	f9 e0       	ldi	r31, 0x09	; 9
     7c6:	80 e4       	ldi	r24, 0x40	; 64
     7c8:	81 83       	std	Z+1, r24	; 0x01
     7ca:	80 81       	ld	r24, Z
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7cc:	be 01       	movw	r22, r28
     7ce:	6f 5f       	subi	r22, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7d0:	7f 4f       	sbci	r23, 0xFF	; 255
     7d2:	80 ea       	ldi	r24, 0xA0	; 160
     7d4:	99 e0       	ldi	r25, 0x09	; 9
     7d6:	1b d3       	rcall	.+1590   	; 0xe0e <usart_spi_deselect_device>
     7d8:	8b e2       	ldi	r24, 0x2B	; 43
     7da:	89 83       	std	Y+1, r24	; 0x01
     7dc:	be 01       	movw	r22, r28
     7de:	6f 5f       	subi	r22, 0xFF	; 255
     7e0:	7f 4f       	sbci	r23, 0xFF	; 255
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7e2:	80 ea       	ldi	r24, 0xA0	; 160
     7e4:	99 e0       	ldi	r25, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7e6:	fd d2       	rcall	.+1530   	; 0xde2 <usart_spi_select_device>
     7e8:	81 e0       	ldi	r24, 0x01	; 1
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7ea:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7ee:	e0 ea       	ldi	r30, 0xA0	; 160
     7f0:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7f2:	81 81       	ldd	r24, Z+1	; 0x01
     7f4:	85 ff       	sbrs	r24, 5
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7f6:	fd cf       	rjmp	.-6      	; 0x7f2 <st7565r_init+0x300>
     7f8:	81 e2       	ldi	r24, 0x21	; 33
     7fa:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7fe:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     800:	f9 e0       	ldi	r31, 0x09	; 9
     802:	81 81       	ldd	r24, Z+1	; 0x01
     804:	86 ff       	sbrs	r24, 6
     806:	fd cf       	rjmp	.-6      	; 0x802 <st7565r_init+0x310>
     808:	e0 ea       	ldi	r30, 0xA0	; 160
     80a:	f9 e0       	ldi	r31, 0x09	; 9
     80c:	80 e4       	ldi	r24, 0x40	; 64
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     80e:	81 83       	std	Z+1, r24	; 0x01
     810:	80 81       	ld	r24, Z
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     812:	be 01       	movw	r22, r28
     814:	6f 5f       	subi	r22, 0xFF	; 255
     816:	7f 4f       	sbci	r23, 0xFF	; 255
     818:	80 ea       	ldi	r24, 0xA0	; 160
     81a:	99 e0       	ldi	r25, 0x09	; 9
     81c:	f8 d2       	rcall	.+1520   	; 0xe0e <usart_spi_deselect_device>
     81e:	8b e2       	ldi	r24, 0x2B	; 43
     820:	89 83       	std	Y+1, r24	; 0x01
     822:	be 01       	movw	r22, r28
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     824:	6f 5f       	subi	r22, 0xFF	; 255
     826:	7f 4f       	sbci	r23, 0xFF	; 255
     828:	80 ea       	ldi	r24, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     82a:	99 e0       	ldi	r25, 0x09	; 9
     82c:	da d2       	rcall	.+1460   	; 0xde2 <usart_spi_select_device>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     82e:	81 e0       	ldi	r24, 0x01	; 1
     830:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     834:	e0 ea       	ldi	r30, 0xA0	; 160
     836:	f9 e0       	ldi	r31, 0x09	; 9
     838:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     83a:	85 ff       	sbrs	r24, 5
     83c:	fd cf       	rjmp	.-6      	; 0x838 <st7565r_init+0x346>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     83e:	8f ea       	ldi	r24, 0xAF	; 175
     840:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     844:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     846:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     848:	81 81       	ldd	r24, Z+1	; 0x01
     84a:	86 ff       	sbrs	r24, 6
     84c:	fd cf       	rjmp	.-6      	; 0x848 <st7565r_init+0x356>
     84e:	e0 ea       	ldi	r30, 0xA0	; 160
     850:	f9 e0       	ldi	r31, 0x09	; 9
     852:	80 e4       	ldi	r24, 0x40	; 64
     854:	81 83       	std	Z+1, r24	; 0x01
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     856:	80 81       	ld	r24, Z
     858:	be 01       	movw	r22, r28
     85a:	6f 5f       	subi	r22, 0xFF	; 255
     85c:	7f 4f       	sbci	r23, 0xFF	; 255
     85e:	80 ea       	ldi	r24, 0xA0	; 160
     860:	99 e0       	ldi	r25, 0x09	; 9
     862:	d5 d2       	rcall	.+1450   	; 0xe0e <usart_spi_deselect_device>
     864:	0f 90       	pop	r0
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	1f 91       	pop	r17
     86c:	0f 91       	pop	r16
     86e:	ff 90       	pop	r15
     870:	ef 90       	pop	r14
     872:	df 90       	pop	r13
     874:	cf 90       	pop	r12
     876:	bf 90       	pop	r11
     878:	08 95       	ret

0000087a <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
     87a:	8f ef       	ldi	r24, 0xFF	; 255
     87c:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
     880:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
     884:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
     888:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
     88c:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
     890:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
     894:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
     898:	08 95       	ret

0000089a <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     89a:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     89c:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     89e:	e8 2f       	mov	r30, r24
     8a0:	f0 e0       	ldi	r31, 0x00	; 0
     8a2:	e0 59       	subi	r30, 0x90	; 144
     8a4:	ff 4f       	sbci	r31, 0xFF	; 255
     8a6:	60 95       	com	r22
     8a8:	80 81       	ld	r24, Z
     8aa:	68 23       	and	r22, r24
     8ac:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8ae:	9f bf       	out	0x3f, r25	; 63
     8b0:	08 95       	ret

000008b2 <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     8b2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     8b4:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     8b6:	e8 2f       	mov	r30, r24
     8b8:	f0 e0       	ldi	r31, 0x00	; 0
     8ba:	e0 59       	subi	r30, 0x90	; 144
     8bc:	ff 4f       	sbci	r31, 0xFF	; 255
     8be:	80 81       	ld	r24, Z
     8c0:	68 2b       	or	r22, r24
     8c2:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     8c4:	9f bf       	out	0x3f, r25	; 63
     8c6:	08 95       	ret

000008c8 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8c8:	ff 92       	push	r15
     8ca:	0f 93       	push	r16
     8cc:	1f 93       	push	r17
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	1f 92       	push	r1
     8d4:	cd b7       	in	r28, 0x3d	; 61
     8d6:	de b7       	in	r29, 0x3e	; 62
     8d8:	08 2f       	mov	r16, r24
     8da:	f6 2e       	mov	r15, r22
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8dc:	14 2f       	mov	r17, r20
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8de:	1a d1       	rcall	.+564    	; 0xb14 <gfx_mono_framebuffer_put_byte>
     8e0:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8e2:	00 6b       	ori	r16, 0xB0	; 176
     8e4:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8e6:	89 83       	std	Y+1, r24	; 0x01
     8e8:	be 01       	movw	r22, r28
     8ea:	6f 5f       	subi	r22, 0xFF	; 255
     8ec:	7f 4f       	sbci	r23, 0xFF	; 255
     8ee:	80 ea       	ldi	r24, 0xA0	; 160
     8f0:	99 e0       	ldi	r25, 0x09	; 9
     8f2:	77 d2       	rcall	.+1262   	; 0xde2 <usart_spi_select_device>
     8f4:	81 e0       	ldi	r24, 0x01	; 1
     8f6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8fa:	e0 ea       	ldi	r30, 0xA0	; 160
     8fc:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8fe:	91 81       	ldd	r25, Z+1	; 0x01
     900:	95 ff       	sbrs	r25, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     902:	fd cf       	rjmp	.-6      	; 0x8fe <gfx_mono_st7565r_put_byte+0x36>
     904:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     908:	e0 ea       	ldi	r30, 0xA0	; 160
     90a:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     90c:	81 81       	ldd	r24, Z+1	; 0x01
     90e:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     910:	fd cf       	rjmp	.-6      	; 0x90c <gfx_mono_st7565r_put_byte+0x44>
     912:	e0 ea       	ldi	r30, 0xA0	; 160
     914:	f9 e0       	ldi	r31, 0x09	; 9
     916:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     918:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     91a:	80 81       	ld	r24, Z
     91c:	be 01       	movw	r22, r28
     91e:	6f 5f       	subi	r22, 0xFF	; 255
     920:	7f 4f       	sbci	r23, 0xFF	; 255
     922:	80 ea       	ldi	r24, 0xA0	; 160
     924:	99 e0       	ldi	r25, 0x09	; 9
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     926:	73 d2       	rcall	.+1254   	; 0xe0e <usart_spi_deselect_device>
     928:	0f 2d       	mov	r16, r15
     92a:	0f 77       	andi	r16, 0x7F	; 127
     92c:	02 95       	swap	r16
     92e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     930:	00 61       	ori	r16, 0x10	; 16
     932:	8b e2       	ldi	r24, 0x2B	; 43
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     934:	89 83       	std	Y+1, r24	; 0x01
     936:	be 01       	movw	r22, r28
     938:	6f 5f       	subi	r22, 0xFF	; 255
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	80 ea       	ldi	r24, 0xA0	; 160
     93e:	99 e0       	ldi	r25, 0x09	; 9
     940:	50 d2       	rcall	.+1184   	; 0xde2 <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94c:	81 81       	ldd	r24, Z+1	; 0x01
     94e:	85 ff       	sbrs	r24, 5
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0x84>
     952:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95a:	81 81       	ldd	r24, Z+1	; 0x01
     95c:	86 ff       	sbrs	r24, 6
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0x92>
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     966:	81 83       	std	Z+1, r24	; 0x01
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     968:	80 81       	ld	r24, Z
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     974:	4c d2       	rcall	.+1176   	; 0xe0e <usart_spi_deselect_device>
     976:	0f 2d       	mov	r16, r15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     978:	0f 70       	andi	r16, 0x0F	; 15
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     97a:	8b e2       	ldi	r24, 0x2B	; 43
     97c:	89 83       	std	Y+1, r24	; 0x01
     97e:	be 01       	movw	r22, r28
     980:	6f 5f       	subi	r22, 0xFF	; 255
     982:	7f 4f       	sbci	r23, 0xFF	; 255
     984:	80 ea       	ldi	r24, 0xA0	; 160
     986:	99 e0       	ldi	r25, 0x09	; 9
     988:	2c d2       	rcall	.+1112   	; 0xde2 <usart_spi_select_device>
     98a:	81 e0       	ldi	r24, 0x01	; 1
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     98c:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     990:	e0 ea       	ldi	r30, 0xA0	; 160
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     992:	f9 e0       	ldi	r31, 0x09	; 9
     994:	81 81       	ldd	r24, Z+1	; 0x01
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     996:	85 ff       	sbrs	r24, 5
     998:	fd cf       	rjmp	.-6      	; 0x994 <gfx_mono_st7565r_put_byte+0xcc>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     99a:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
     99e:	e0 ea       	ldi	r30, 0xA0	; 160
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a0:	f9 e0       	ldi	r31, 0x09	; 9
     9a2:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a4:	86 ff       	sbrs	r24, 6
     9a6:	fd cf       	rjmp	.-6      	; 0x9a2 <gfx_mono_st7565r_put_byte+0xda>
     9a8:	e0 ea       	ldi	r30, 0xA0	; 160
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9aa:	f9 e0       	ldi	r31, 0x09	; 9
     9ac:	80 e4       	ldi	r24, 0x40	; 64
     9ae:	81 83       	std	Z+1, r24	; 0x01
     9b0:	80 81       	ld	r24, Z
     9b2:	be 01       	movw	r22, r28
     9b4:	6f 5f       	subi	r22, 0xFF	; 255
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9b6:	7f 4f       	sbci	r23, 0xFF	; 255
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9b8:	80 ea       	ldi	r24, 0xA0	; 160
     9ba:	99 e0       	ldi	r25, 0x09	; 9
     9bc:	28 d2       	rcall	.+1104   	; 0xe0e <usart_spi_deselect_device>
     9be:	8b e2       	ldi	r24, 0x2B	; 43
     9c0:	89 83       	std	Y+1, r24	; 0x01
     9c2:	be 01       	movw	r22, r28
     9c4:	6f 5f       	subi	r22, 0xFF	; 255
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9c6:	7f 4f       	sbci	r23, 0xFF	; 255
     9c8:	80 ea       	ldi	r24, 0xA0	; 160
     9ca:	99 e0       	ldi	r25, 0x09	; 9
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9cc:	0a d2       	rcall	.+1044   	; 0xde2 <usart_spi_select_device>
     9ce:	81 e0       	ldi	r24, 0x01	; 1
     9d0:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9d4:	e0 ea       	ldi	r30, 0xA0	; 160
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9d6:	f9 e0       	ldi	r31, 0x09	; 9
     9d8:	81 81       	ldd	r24, Z+1	; 0x01
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9da:	85 ff       	sbrs	r24, 5
     9dc:	fd cf       	rjmp	.-6      	; 0x9d8 <gfx_mono_st7565r_put_byte+0x110>
     9de:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9e2:	e0 ea       	ldi	r30, 0xA0	; 160
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9e4:	f9 e0       	ldi	r31, 0x09	; 9
     9e6:	81 81       	ldd	r24, Z+1	; 0x01
     9e8:	86 ff       	sbrs	r24, 6
     9ea:	fd cf       	rjmp	.-6      	; 0x9e6 <gfx_mono_st7565r_put_byte+0x11e>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ec:	e0 ea       	ldi	r30, 0xA0	; 160
     9ee:	f9 e0       	ldi	r31, 0x09	; 9
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9f0:	80 e4       	ldi	r24, 0x40	; 64
     9f2:	81 83       	std	Z+1, r24	; 0x01
     9f4:	80 81       	ld	r24, Z
     9f6:	81 e0       	ldi	r24, 0x01	; 1
     9f8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
     9fc:	be 01       	movw	r22, r28

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9fe:	6f 5f       	subi	r22, 0xFF	; 255
     a00:	7f 4f       	sbci	r23, 0xFF	; 255
     a02:	80 ea       	ldi	r24, 0xA0	; 160
     a04:	99 e0       	ldi	r25, 0x09	; 9
     a06:	03 d2       	rcall	.+1030   	; 0xe0e <usart_spi_deselect_device>
     a08:	0f 90       	pop	r0
     a0a:	df 91       	pop	r29
     a0c:	cf 91       	pop	r28
     a0e:	1f 91       	pop	r17
     a10:	0f 91       	pop	r16
     a12:	ff 90       	pop	r15
     a14:	08 95       	ret

00000a16 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a16:	0f 93       	push	r16
     a18:	1f 93       	push	r17
     a1a:	cf 93       	push	r28
     a1c:	df 93       	push	r29
     a1e:	1f 92       	push	r1
     a20:	cd b7       	in	r28, 0x3d	; 61
     a22:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a24:	80 e4       	ldi	r24, 0x40	; 64
     a26:	90 e2       	ldi	r25, 0x20	; 32
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a28:	70 d0       	rcall	.+224    	; 0xb0a <gfx_mono_set_framebuffer>
     a2a:	63 dd       	rcall	.-1338   	; 0x4f2 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a2c:	8b e2       	ldi	r24, 0x2B	; 43
     a2e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a30:	be 01       	movw	r22, r28
     a32:	6f 5f       	subi	r22, 0xFF	; 255
     a34:	7f 4f       	sbci	r23, 0xFF	; 255
     a36:	80 ea       	ldi	r24, 0xA0	; 160
     a38:	99 e0       	ldi	r25, 0x09	; 9
     a3a:	d3 d1       	rcall	.+934    	; 0xde2 <usart_spi_select_device>
     a3c:	81 e0       	ldi	r24, 0x01	; 1
     a3e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a42:	e0 ea       	ldi	r30, 0xA0	; 160
     a44:	f9 e0       	ldi	r31, 0x09	; 9
     a46:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a48:	85 ff       	sbrs	r24, 5
     a4a:	fd cf       	rjmp	.-6      	; 0xa46 <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a4c:	80 e4       	ldi	r24, 0x40	; 64
     a4e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a52:	e0 ea       	ldi	r30, 0xA0	; 160
     a54:	f9 e0       	ldi	r31, 0x09	; 9
     a56:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a58:	86 ff       	sbrs	r24, 6
     a5a:	fd cf       	rjmp	.-6      	; 0xa56 <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a5c:	e0 ea       	ldi	r30, 0xA0	; 160
     a5e:	f9 e0       	ldi	r31, 0x09	; 9
     a60:	80 e4       	ldi	r24, 0x40	; 64
     a62:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a64:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a66:	be 01       	movw	r22, r28
     a68:	6f 5f       	subi	r22, 0xFF	; 255
     a6a:	7f 4f       	sbci	r23, 0xFF	; 255
     a6c:	80 ea       	ldi	r24, 0xA0	; 160
     a6e:	99 e0       	ldi	r25, 0x09	; 9
     a70:	ce d1       	rcall	.+924    	; 0xe0e <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a72:	00 e0       	ldi	r16, 0x00	; 0
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a74:	0a c0       	rjmp	.+20     	; 0xa8a <gfx_mono_st7565r_init+0x74>
     a76:	40 e0       	ldi	r20, 0x00	; 0
     a78:	61 2f       	mov	r22, r17
     a7a:	80 2f       	mov	r24, r16
     a7c:	25 df       	rcall	.-438    	; 0x8c8 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a7e:	1f 5f       	subi	r17, 0xFF	; 255
     a80:	10 38       	cpi	r17, 0x80	; 128
     a82:	c9 f7       	brne	.-14     	; 0xa76 <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a84:	0f 5f       	subi	r16, 0xFF	; 255
     a86:	04 30       	cpi	r16, 0x04	; 4
     a88:	11 f0       	breq	.+4      	; 0xa8e <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a8a:	10 e0       	ldi	r17, 0x00	; 0
     a8c:	f4 cf       	rjmp	.-24     	; 0xa76 <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a8e:	0f 90       	pop	r0
     a90:	df 91       	pop	r29
     a92:	cf 91       	pop	r28
     a94:	1f 91       	pop	r17
     a96:	0f 91       	pop	r16
     a98:	08 95       	ret

00000a9a <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a9a:	ff 92       	push	r15
     a9c:	0f 93       	push	r16
     a9e:	1f 93       	push	r17
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     aa4:	88 23       	and	r24, r24
     aa6:	4c f1       	brlt	.+82     	; 0xafa <gfx_mono_st7565r_draw_pixel+0x60>
     aa8:	60 32       	cpi	r22, 0x20	; 32
     aaa:	38 f5       	brcc	.+78     	; 0xafa <gfx_mono_st7565r_draw_pixel+0x60>
     aac:	d4 2f       	mov	r29, r20
     aae:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ab0:	f6 2e       	mov	r15, r22
     ab2:	f6 94       	lsr	r15
     ab4:	f6 94       	lsr	r15
     ab6:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     ab8:	70 e0       	ldi	r23, 0x00	; 0
     aba:	88 e0       	ldi	r24, 0x08	; 8
     abc:	f8 9e       	mul	r15, r24
     abe:	60 19       	sub	r22, r0
     ac0:	71 09       	sbc	r23, r1
     ac2:	11 24       	eor	r1, r1
     ac4:	81 e0       	ldi	r24, 0x01	; 1
     ac6:	90 e0       	ldi	r25, 0x00	; 0
     ac8:	8c 01       	movw	r16, r24
     aca:	02 c0       	rjmp	.+4      	; 0xad0 <gfx_mono_st7565r_draw_pixel+0x36>
     acc:	00 0f       	add	r16, r16
     ace:	11 1f       	adc	r17, r17
     ad0:	6a 95       	dec	r22
     ad2:	e2 f7       	brpl	.-8      	; 0xacc <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ad4:	6c 2f       	mov	r22, r28
     ad6:	8f 2d       	mov	r24, r15
     ad8:	2b d0       	rcall	.+86     	; 0xb30 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ada:	d1 30       	cpi	r29, 0x01	; 1
     adc:	21 f0       	breq	.+8      	; 0xae6 <gfx_mono_st7565r_draw_pixel+0x4c>
     ade:	28 f0       	brcs	.+10     	; 0xaea <gfx_mono_st7565r_draw_pixel+0x50>
     ae0:	d2 30       	cpi	r29, 0x02	; 2
     ae2:	31 f0       	breq	.+12     	; 0xaf0 <gfx_mono_st7565r_draw_pixel+0x56>
     ae4:	06 c0       	rjmp	.+12     	; 0xaf2 <gfx_mono_st7565r_draw_pixel+0x58>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     ae6:	80 2b       	or	r24, r16
		break;
     ae8:	04 c0       	rjmp	.+8      	; 0xaf2 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     aea:	00 95       	com	r16
     aec:	80 23       	and	r24, r16
		break;
     aee:	01 c0       	rjmp	.+2      	; 0xaf2 <gfx_mono_st7565r_draw_pixel+0x58>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     af0:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     af2:	48 2f       	mov	r20, r24
     af4:	6c 2f       	mov	r22, r28
     af6:	8f 2d       	mov	r24, r15
     af8:	e7 de       	rcall	.-562    	; 0x8c8 <gfx_mono_st7565r_put_byte>
}
     afa:	df 91       	pop	r29
     afc:	cf 91       	pop	r28
     afe:	1f 91       	pop	r17
     b00:	0f 91       	pop	r16
     b02:	ff 90       	pop	r15
     b04:	08 95       	ret

00000b06 <gfx_mono_st7565r_get_byte>:
 * \code
	data = gfx_mono_st7565r_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
     b06:	14 c0       	rjmp	.+40     	; 0xb30 <gfx_mono_framebuffer_get_byte>
     b08:	08 95       	ret

00000b0a <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     b0a:	80 93 40 22 	sts	0x2240, r24	; 0x802240 <fbpointer>
     b0e:	90 93 41 22 	sts	0x2241, r25	; 0x802241 <fbpointer+0x1>
     b12:	08 95       	ret

00000b14 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     b14:	20 91 40 22 	lds	r18, 0x2240	; 0x802240 <fbpointer>
     b18:	30 91 41 22 	lds	r19, 0x2241	; 0x802241 <fbpointer+0x1>
     b1c:	90 e8       	ldi	r25, 0x80	; 128
     b1e:	89 9f       	mul	r24, r25
     b20:	20 0d       	add	r18, r0
     b22:	31 1d       	adc	r19, r1
     b24:	11 24       	eor	r1, r1
     b26:	f9 01       	movw	r30, r18
     b28:	e6 0f       	add	r30, r22
     b2a:	f1 1d       	adc	r31, r1
     b2c:	40 83       	st	Z, r20
     b2e:	08 95       	ret

00000b30 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     b30:	20 91 40 22 	lds	r18, 0x2240	; 0x802240 <fbpointer>
     b34:	30 91 41 22 	lds	r19, 0x2241	; 0x802241 <fbpointer+0x1>
     b38:	90 e8       	ldi	r25, 0x80	; 128
     b3a:	89 9f       	mul	r24, r25
     b3c:	20 0d       	add	r18, r0
     b3e:	31 1d       	adc	r19, r1
     b40:	11 24       	eor	r1, r1
     b42:	f9 01       	movw	r30, r18
     b44:	e6 0f       	add	r30, r22
     b46:	f1 1d       	adc	r31, r1
}
     b48:	80 81       	ld	r24, Z
     b4a:	08 95       	ret

00000b4c <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b4c:	ff 92       	push	r15
     b4e:	0f 93       	push	r16
     b50:	1f 93       	push	r17
     b52:	cf 93       	push	r28
     b54:	df 93       	push	r29
     b56:	e4 2f       	mov	r30, r20
     b58:	f0 e0       	ldi	r31, 0x00	; 0
     b5a:	e8 0f       	add	r30, r24
     b5c:	f1 1d       	adc	r31, r1
     b5e:	e1 38       	cpi	r30, 0x81	; 129
     b60:	f1 05       	cpc	r31, r1
     b62:	1c f0       	brlt	.+6      	; 0xb6a <gfx_mono_generic_draw_horizontal_line+0x1e>
     b64:	c0 e8       	ldi	r28, 0x80	; 128
     b66:	4c 2f       	mov	r20, r28
     b68:	48 1b       	sub	r20, r24
     b6a:	44 23       	and	r20, r20
     b6c:	09 f4       	brne	.+2      	; 0xb70 <gfx_mono_generic_draw_horizontal_line+0x24>
     b6e:	4a c0       	rjmp	.+148    	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     b70:	d6 2f       	mov	r29, r22
     b72:	d6 95       	lsr	r29
     b74:	d6 95       	lsr	r29
     b76:	d6 95       	lsr	r29
     b78:	70 e0       	ldi	r23, 0x00	; 0
     b7a:	98 e0       	ldi	r25, 0x08	; 8
     b7c:	d9 9f       	mul	r29, r25
     b7e:	60 19       	sub	r22, r0
     b80:	71 09       	sbc	r23, r1
     b82:	11 24       	eor	r1, r1
     b84:	e1 e0       	ldi	r30, 0x01	; 1
     b86:	f0 e0       	ldi	r31, 0x00	; 0
     b88:	df 01       	movw	r26, r30
     b8a:	02 c0       	rjmp	.+4      	; 0xb90 <gfx_mono_generic_draw_horizontal_line+0x44>
     b8c:	aa 0f       	add	r26, r26
     b8e:	bb 1f       	adc	r27, r27
     b90:	6a 95       	dec	r22
     b92:	e2 f7       	brpl	.-8      	; 0xb8c <gfx_mono_generic_draw_horizontal_line+0x40>
     b94:	fa 2e       	mov	r15, r26
     b96:	21 30       	cpi	r18, 0x01	; 1
     b98:	21 f0       	breq	.+8      	; 0xba2 <gfx_mono_generic_draw_horizontal_line+0x56>
     b9a:	98 f0       	brcs	.+38     	; 0xbc2 <gfx_mono_generic_draw_horizontal_line+0x76>
     b9c:	22 30       	cpi	r18, 0x02	; 2
     b9e:	19 f1       	breq	.+70     	; 0xbe6 <gfx_mono_generic_draw_horizontal_line+0x9a>
     ba0:	31 c0       	rjmp	.+98     	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     ba2:	c4 2f       	mov	r28, r20
     ba4:	1f ef       	ldi	r17, 0xFF	; 255
     ba6:	18 0f       	add	r17, r24
     ba8:	01 2f       	mov	r16, r17
     baa:	0c 0f       	add	r16, r28
     bac:	60 2f       	mov	r22, r16
     bae:	8d 2f       	mov	r24, r29
     bb0:	aa df       	rcall	.-172    	; 0xb06 <gfx_mono_st7565r_get_byte>
     bb2:	4f 2d       	mov	r20, r15
     bb4:	48 2b       	or	r20, r24
     bb6:	60 2f       	mov	r22, r16
     bb8:	8d 2f       	mov	r24, r29
     bba:	86 de       	rcall	.-756    	; 0x8c8 <gfx_mono_st7565r_put_byte>
     bbc:	c1 50       	subi	r28, 0x01	; 1
     bbe:	a1 f7       	brne	.-24     	; 0xba8 <gfx_mono_generic_draw_horizontal_line+0x5c>
     bc0:	21 c0       	rjmp	.+66     	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     bc2:	c4 2f       	mov	r28, r20
     bc4:	1f ef       	ldi	r17, 0xFF	; 255
     bc6:	18 0f       	add	r17, r24
     bc8:	fa 2e       	mov	r15, r26
     bca:	f0 94       	com	r15
     bcc:	01 2f       	mov	r16, r17
     bce:	0c 0f       	add	r16, r28
     bd0:	60 2f       	mov	r22, r16
     bd2:	8d 2f       	mov	r24, r29
     bd4:	98 df       	rcall	.-208    	; 0xb06 <gfx_mono_st7565r_get_byte>
     bd6:	4f 2d       	mov	r20, r15
     bd8:	48 23       	and	r20, r24
     bda:	60 2f       	mov	r22, r16
     bdc:	8d 2f       	mov	r24, r29
     bde:	74 de       	rcall	.-792    	; 0x8c8 <gfx_mono_st7565r_put_byte>
     be0:	c1 50       	subi	r28, 0x01	; 1
     be2:	a1 f7       	brne	.-24     	; 0xbcc <gfx_mono_generic_draw_horizontal_line+0x80>
     be4:	0f c0       	rjmp	.+30     	; 0xc04 <gfx_mono_generic_draw_horizontal_line+0xb8>
     be6:	c4 2f       	mov	r28, r20
     be8:	1f ef       	ldi	r17, 0xFF	; 255
     bea:	18 0f       	add	r17, r24
     bec:	01 2f       	mov	r16, r17
     bee:	0c 0f       	add	r16, r28
     bf0:	60 2f       	mov	r22, r16
     bf2:	8d 2f       	mov	r24, r29
     bf4:	88 df       	rcall	.-240    	; 0xb06 <gfx_mono_st7565r_get_byte>
     bf6:	4f 2d       	mov	r20, r15
     bf8:	48 27       	eor	r20, r24
     bfa:	60 2f       	mov	r22, r16
     bfc:	8d 2f       	mov	r24, r29
     bfe:	64 de       	rcall	.-824    	; 0x8c8 <gfx_mono_st7565r_put_byte>
     c00:	c1 50       	subi	r28, 0x01	; 1
     c02:	a1 f7       	brne	.-24     	; 0xbec <gfx_mono_generic_draw_horizontal_line+0xa0>
     c04:	df 91       	pop	r29
     c06:	cf 91       	pop	r28
     c08:	1f 91       	pop	r17
     c0a:	0f 91       	pop	r16
     c0c:	ff 90       	pop	r15
     c0e:	08 95       	ret

00000c10 <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     c10:	ff 92       	push	r15
     c12:	0f 93       	push	r16
     c14:	1f 93       	push	r17
     c16:	cf 93       	push	r28
     c18:	df 93       	push	r29
	if (height == 0) {
     c1a:	22 23       	and	r18, r18
     c1c:	69 f0       	breq	.+26     	; 0xc38 <gfx_mono_generic_draw_filled_rect+0x28>
     c1e:	f4 2e       	mov	r15, r20
     c20:	18 2f       	mov	r17, r24
     c22:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c24:	df ef       	ldi	r29, 0xFF	; 255
     c26:	d6 0f       	add	r29, r22
     c28:	6d 2f       	mov	r22, r29
     c2a:	6c 0f       	add	r22, r28
     c2c:	20 2f       	mov	r18, r16
     c2e:	4f 2d       	mov	r20, r15
     c30:	81 2f       	mov	r24, r17
     c32:	8c df       	rcall	.-232    	; 0xb4c <gfx_mono_generic_draw_horizontal_line>
     c34:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c36:	c1 f7       	brne	.-16     	; 0xc28 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c38:	df 91       	pop	r29
     c3a:	cf 91       	pop	r28
     c3c:	1f 91       	pop	r17
     c3e:	0f 91       	pop	r16
     c40:	ff 90       	pop	r15
     c42:	08 95       	ret

00000c44 <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c44:	af 92       	push	r10
     c46:	bf 92       	push	r11
     c48:	cf 92       	push	r12
     c4a:	df 92       	push	r13
     c4c:	ef 92       	push	r14
     c4e:	ff 92       	push	r15
     c50:	0f 93       	push	r16
     c52:	1f 93       	push	r17
     c54:	cf 93       	push	r28
     c56:	df 93       	push	r29
     c58:	c8 2f       	mov	r28, r24
     c5a:	e6 2e       	mov	r14, r22
     c5c:	b4 2e       	mov	r11, r20
     c5e:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c60:	00 e0       	ldi	r16, 0x00	; 0
     c62:	f9 01       	movw	r30, r18
     c64:	24 81       	ldd	r18, Z+4	; 0x04
     c66:	43 81       	ldd	r20, Z+3	; 0x03
     c68:	6b 2d       	mov	r22, r11
     c6a:	8e 2d       	mov	r24, r14
     c6c:	d1 df       	rcall	.-94     	; 0xc10 <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c6e:	f6 01       	movw	r30, r12
     c70:	80 81       	ld	r24, Z
     c72:	81 11       	cpse	r24, r1
     c74:	39 c0       	rjmp	.+114    	; 0xce8 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c76:	83 81       	ldd	r24, Z+3	; 0x03
     c78:	28 2f       	mov	r18, r24
     c7a:	26 95       	lsr	r18
     c7c:	26 95       	lsr	r18
     c7e:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c80:	87 70       	andi	r24, 0x07	; 7
     c82:	09 f0       	breq	.+2      	; 0xc86 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c84:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c86:	f6 01       	movw	r30, r12
     c88:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c8a:	8c 2f       	mov	r24, r28
     c8c:	90 e0       	ldi	r25, 0x00	; 0
     c8e:	35 81       	ldd	r19, Z+5	; 0x05
     c90:	83 1b       	sub	r24, r19
     c92:	91 09       	sbc	r25, r1
     c94:	2a 9d       	mul	r18, r10
     c96:	90 01       	movw	r18, r0
     c98:	11 24       	eor	r1, r1
     c9a:	82 9f       	mul	r24, r18
     c9c:	a0 01       	movw	r20, r0
     c9e:	83 9f       	mul	r24, r19
     ca0:	50 0d       	add	r21, r0
     ca2:	92 9f       	mul	r25, r18
     ca4:	50 0d       	add	r21, r0
     ca6:	11 24       	eor	r1, r1
     ca8:	01 81       	ldd	r16, Z+1	; 0x01
     caa:	12 81       	ldd	r17, Z+2	; 0x02
     cac:	04 0f       	add	r16, r20
     cae:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     cb0:	f6 01       	movw	r30, r12
     cb2:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     cb4:	ff 20       	and	r15, r15
     cb6:	a1 f0       	breq	.+40     	; 0xce0 <gfx_mono_draw_char+0x9c>
     cb8:	d0 e0       	ldi	r29, 0x00	; 0
     cba:	c0 e0       	ldi	r28, 0x00	; 0
     cbc:	8e 2d       	mov	r24, r14
     cbe:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     cc0:	9c 2f       	mov	r25, r28
     cc2:	97 70       	andi	r25, 0x07	; 7
     cc4:	21 f4       	brne	.+8      	; 0xcce <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     cc6:	f8 01       	movw	r30, r16
     cc8:	d4 91       	lpm	r29, Z
				glyph_data++;
     cca:	0f 5f       	subi	r16, 0xFF	; 255
     ccc:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     cce:	dd 23       	and	r29, r29
     cd0:	1c f4       	brge	.+6      	; 0xcd8 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cd2:	41 e0       	ldi	r20, 0x01	; 1
     cd4:	6b 2d       	mov	r22, r11
     cd6:	e1 de       	rcall	.-574    	; 0xa9a <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cd8:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cda:	cf 5f       	subi	r28, 0xFF	; 255
     cdc:	fc 12       	cpse	r15, r28
     cde:	ee cf       	rjmp	.-36     	; 0xcbc <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     ce0:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     ce2:	aa 94       	dec	r10
	} while (rows_left > 0);
     ce4:	a1 10       	cpse	r10, r1
     ce6:	e4 cf       	rjmp	.-56     	; 0xcb0 <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     ce8:	df 91       	pop	r29
     cea:	cf 91       	pop	r28
     cec:	1f 91       	pop	r17
     cee:	0f 91       	pop	r16
     cf0:	ff 90       	pop	r15
     cf2:	ef 90       	pop	r14
     cf4:	df 90       	pop	r13
     cf6:	cf 90       	pop	r12
     cf8:	bf 90       	pop	r11
     cfa:	af 90       	pop	r10
     cfc:	08 95       	ret

00000cfe <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cfe:	df 92       	push	r13
     d00:	ef 92       	push	r14
     d02:	ff 92       	push	r15
     d04:	0f 93       	push	r16
     d06:	1f 93       	push	r17
     d08:	cf 93       	push	r28
     d0a:	df 93       	push	r29
     d0c:	d6 2e       	mov	r13, r22
     d0e:	04 2f       	mov	r16, r20
     d10:	79 01       	movw	r14, r18
     d12:	ec 01       	movw	r28, r24
     d14:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     d16:	89 91       	ld	r24, Y+
     d18:	8a 30       	cpi	r24, 0x0A	; 10
     d1a:	31 f4       	brne	.+12     	; 0xd28 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
     d1c:	f7 01       	movw	r30, r14
     d1e:	84 81       	ldd	r24, Z+4	; 0x04
     d20:	8f 5f       	subi	r24, 0xFF	; 255
     d22:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     d24:	1d 2d       	mov	r17, r13
     d26:	09 c0       	rjmp	.+18     	; 0xd3a <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d28:	8d 30       	cpi	r24, 0x0D	; 13
     d2a:	39 f0       	breq	.+14     	; 0xd3a <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d2c:	97 01       	movw	r18, r14
     d2e:	40 2f       	mov	r20, r16
     d30:	61 2f       	mov	r22, r17
     d32:	88 df       	rcall	.-240    	; 0xc44 <gfx_mono_draw_char>
			x += font->width;
     d34:	f7 01       	movw	r30, r14
     d36:	83 81       	ldd	r24, Z+3	; 0x03
     d38:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d3a:	88 81       	ld	r24, Y
     d3c:	81 11       	cpse	r24, r1
     d3e:	eb cf       	rjmp	.-42     	; 0xd16 <gfx_mono_draw_string+0x18>
}
     d40:	df 91       	pop	r29
     d42:	cf 91       	pop	r28
     d44:	1f 91       	pop	r17
     d46:	0f 91       	pop	r16
     d48:	ff 90       	pop	r15
     d4a:	ef 90       	pop	r14
     d4c:	df 90       	pop	r13
     d4e:	08 95       	ret

00000d50 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d50:	80 3a       	cpi	r24, 0xA0	; 160
     d52:	28 e0       	ldi	r18, 0x08	; 8
     d54:	92 07       	cpc	r25, r18
     d56:	21 f4       	brne	.+8      	; 0xd60 <usart_spi_init+0x10>
     d58:	60 e1       	ldi	r22, 0x10	; 16
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	9e cd       	rjmp	.-1220   	; 0x89a <sysclk_enable_module>
     d5e:	08 95       	ret
     d60:	80 3b       	cpi	r24, 0xB0	; 176
     d62:	28 e0       	ldi	r18, 0x08	; 8
     d64:	92 07       	cpc	r25, r18
     d66:	21 f4       	brne	.+8      	; 0xd70 <usart_spi_init+0x20>
     d68:	60 e2       	ldi	r22, 0x20	; 32
     d6a:	83 e0       	ldi	r24, 0x03	; 3
     d6c:	96 cd       	rjmp	.-1236   	; 0x89a <sysclk_enable_module>
     d6e:	08 95       	ret
     d70:	80 3a       	cpi	r24, 0xA0	; 160
     d72:	29 e0       	ldi	r18, 0x09	; 9
     d74:	92 07       	cpc	r25, r18
     d76:	21 f4       	brne	.+8      	; 0xd80 <usart_spi_init+0x30>
     d78:	60 e1       	ldi	r22, 0x10	; 16
     d7a:	84 e0       	ldi	r24, 0x04	; 4
     d7c:	8e cd       	rjmp	.-1252   	; 0x89a <sysclk_enable_module>
     d7e:	08 95       	ret
     d80:	80 3b       	cpi	r24, 0xB0	; 176
     d82:	29 e0       	ldi	r18, 0x09	; 9
     d84:	92 07       	cpc	r25, r18
     d86:	21 f4       	brne	.+8      	; 0xd90 <usart_spi_init+0x40>
     d88:	60 e2       	ldi	r22, 0x20	; 32
     d8a:	84 e0       	ldi	r24, 0x04	; 4
     d8c:	86 cd       	rjmp	.-1268   	; 0x89a <sysclk_enable_module>
     d8e:	08 95       	ret
     d90:	80 3a       	cpi	r24, 0xA0	; 160
     d92:	2a e0       	ldi	r18, 0x0A	; 10
     d94:	92 07       	cpc	r25, r18
     d96:	21 f4       	brne	.+8      	; 0xda0 <usart_spi_init+0x50>
     d98:	60 e1       	ldi	r22, 0x10	; 16
     d9a:	85 e0       	ldi	r24, 0x05	; 5
     d9c:	7e cd       	rjmp	.-1284   	; 0x89a <sysclk_enable_module>
     d9e:	08 95       	ret
     da0:	80 3a       	cpi	r24, 0xA0	; 160
     da2:	9b 40       	sbci	r25, 0x0B	; 11
     da4:	19 f4       	brne	.+6      	; 0xdac <usart_spi_init+0x5c>
     da6:	60 e1       	ldi	r22, 0x10	; 16
     da8:	86 e0       	ldi	r24, 0x06	; 6
     daa:	77 cd       	rjmp	.-1298   	; 0x89a <sysclk_enable_module>
     dac:	08 95       	ret

00000dae <usart_spi_setup_device>:
     dae:	0f 93       	push	r16
     db0:	1f 93       	push	r17
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	00 d0       	rcall	.+0      	; 0xdb8 <usart_spi_setup_device+0xa>
     db8:	00 d0       	rcall	.+0      	; 0xdba <usart_spi_setup_device+0xc>
     dba:	cd b7       	in	r28, 0x3d	; 61
     dbc:	de b7       	in	r29, 0x3e	; 62
     dbe:	09 83       	std	Y+1, r16	; 0x01
     dc0:	1a 83       	std	Y+2, r17	; 0x02
     dc2:	2b 83       	std	Y+3, r18	; 0x03
     dc4:	3c 83       	std	Y+4, r19	; 0x04
     dc6:	4d 83       	std	Y+5, r20	; 0x05
     dc8:	1e 82       	std	Y+6, r1	; 0x06
     dca:	be 01       	movw	r22, r28
     dcc:	6f 5f       	subi	r22, 0xFF	; 255
     dce:	7f 4f       	sbci	r23, 0xFF	; 255
     dd0:	53 d5       	rcall	.+2726   	; 0x1878 <usart_init_spi>
     dd2:	26 96       	adiw	r28, 0x06	; 6
     dd4:	cd bf       	out	0x3d, r28	; 61
     dd6:	de bf       	out	0x3e, r29	; 62
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	1f 91       	pop	r17
     dde:	0f 91       	pop	r16
     de0:	08 95       	ret

00000de2 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     de2:	fb 01       	movw	r30, r22
     de4:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     de6:	e8 2f       	mov	r30, r24
     de8:	e6 95       	lsr	r30
     dea:	e6 95       	lsr	r30
     dec:	e6 95       	lsr	r30
     dee:	40 e2       	ldi	r20, 0x20	; 32
     df0:	e4 9f       	mul	r30, r20
     df2:	f0 01       	movw	r30, r0
     df4:	11 24       	eor	r1, r1
     df6:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     df8:	87 70       	andi	r24, 0x07	; 7
     dfa:	21 e0       	ldi	r18, 0x01	; 1
     dfc:	30 e0       	ldi	r19, 0x00	; 0
     dfe:	a9 01       	movw	r20, r18
     e00:	02 c0       	rjmp	.+4      	; 0xe06 <usart_spi_select_device+0x24>
     e02:	44 0f       	add	r20, r20
     e04:	55 1f       	adc	r21, r21
     e06:	8a 95       	dec	r24
     e08:	e2 f7       	brpl	.-8      	; 0xe02 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     e0a:	46 83       	std	Z+6, r20	; 0x06
     e0c:	08 95       	ret

00000e0e <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     e0e:	fb 01       	movw	r30, r22
     e10:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e12:	e8 2f       	mov	r30, r24
     e14:	e6 95       	lsr	r30
     e16:	e6 95       	lsr	r30
     e18:	e6 95       	lsr	r30
     e1a:	40 e2       	ldi	r20, 0x20	; 32
     e1c:	e4 9f       	mul	r30, r20
     e1e:	f0 01       	movw	r30, r0
     e20:	11 24       	eor	r1, r1
     e22:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e24:	87 70       	andi	r24, 0x07	; 7
     e26:	21 e0       	ldi	r18, 0x01	; 1
     e28:	30 e0       	ldi	r19, 0x00	; 0
     e2a:	a9 01       	movw	r20, r18
     e2c:	02 c0       	rjmp	.+4      	; 0xe32 <usart_spi_deselect_device+0x24>
     e2e:	44 0f       	add	r20, r20
     e30:	55 1f       	adc	r21, r21
     e32:	8a 95       	dec	r24
     e34:	e2 f7       	brpl	.-8      	; 0xe2e <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e36:	45 83       	std	Z+5, r20	; 0x05
     e38:	08 95       	ret

00000e3a <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e3a:	81 15       	cp	r24, r1
     e3c:	22 e0       	ldi	r18, 0x02	; 2
     e3e:	92 07       	cpc	r25, r18
     e40:	61 f4       	brne	.+24     	; 0xe5a <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e42:	80 91 43 22 	lds	r24, 0x2243	; 0x802243 <adca_enable_count>
     e46:	91 e0       	ldi	r25, 0x01	; 1
     e48:	98 0f       	add	r25, r24
     e4a:	90 93 43 22 	sts	0x2243, r25	; 0x802243 <adca_enable_count>
     e4e:	81 11       	cpse	r24, r1
     e50:	12 c0       	rjmp	.+36     	; 0xe76 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e52:	62 e0       	ldi	r22, 0x02	; 2
     e54:	81 e0       	ldi	r24, 0x01	; 1
     e56:	21 cd       	rjmp	.-1470   	; 0x89a <sysclk_enable_module>
     e58:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e5a:	80 34       	cpi	r24, 0x40	; 64
     e5c:	92 40       	sbci	r25, 0x02	; 2
     e5e:	59 f4       	brne	.+22     	; 0xe76 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e60:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <adcb_enable_count>
     e64:	91 e0       	ldi	r25, 0x01	; 1
     e66:	98 0f       	add	r25, r24
     e68:	90 93 42 22 	sts	0x2242, r25	; 0x802242 <adcb_enable_count>
     e6c:	81 11       	cpse	r24, r1
     e6e:	03 c0       	rjmp	.+6      	; 0xe76 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e70:	62 e0       	ldi	r22, 0x02	; 2
     e72:	82 e0       	ldi	r24, 0x02	; 2
     e74:	12 cd       	rjmp	.-1500   	; 0x89a <sysclk_enable_module>
     e76:	08 95       	ret

00000e78 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e78:	81 15       	cp	r24, r1
     e7a:	22 e0       	ldi	r18, 0x02	; 2
     e7c:	92 07       	cpc	r25, r18
     e7e:	59 f4       	brne	.+22     	; 0xe96 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e80:	80 91 43 22 	lds	r24, 0x2243	; 0x802243 <adca_enable_count>
     e84:	81 50       	subi	r24, 0x01	; 1
     e86:	80 93 43 22 	sts	0x2243, r24	; 0x802243 <adca_enable_count>
     e8a:	81 11       	cpse	r24, r1
     e8c:	11 c0       	rjmp	.+34     	; 0xeb0 <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e8e:	62 e0       	ldi	r22, 0x02	; 2
     e90:	81 e0       	ldi	r24, 0x01	; 1
     e92:	0f cd       	rjmp	.-1506   	; 0x8b2 <sysclk_disable_module>
     e94:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e96:	80 34       	cpi	r24, 0x40	; 64
     e98:	92 40       	sbci	r25, 0x02	; 2
     e9a:	51 f4       	brne	.+20     	; 0xeb0 <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     e9c:	80 91 42 22 	lds	r24, 0x2242	; 0x802242 <adcb_enable_count>
     ea0:	81 50       	subi	r24, 0x01	; 1
     ea2:	80 93 42 22 	sts	0x2242, r24	; 0x802242 <adcb_enable_count>
     ea6:	81 11       	cpse	r24, r1
     ea8:	03 c0       	rjmp	.+6      	; 0xeb0 <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     eaa:	62 e0       	ldi	r22, 0x02	; 2
     eac:	82 e0       	ldi	r24, 0x02	; 2
     eae:	01 cd       	rjmp	.-1534   	; 0x8b2 <sysclk_disable_module>
     eb0:	08 95       	ret

00000eb2 <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     eb2:	1f 92       	push	r1
     eb4:	0f 92       	push	r0
     eb6:	0f b6       	in	r0, 0x3f	; 63
     eb8:	0f 92       	push	r0
     eba:	11 24       	eor	r1, r1
     ebc:	0b b6       	in	r0, 0x3b	; 59
     ebe:	0f 92       	push	r0
     ec0:	2f 93       	push	r18
     ec2:	3f 93       	push	r19
     ec4:	4f 93       	push	r20
     ec6:	5f 93       	push	r21
     ec8:	6f 93       	push	r22
     eca:	7f 93       	push	r23
     ecc:	8f 93       	push	r24
     ece:	9f 93       	push	r25
     ed0:	af 93       	push	r26
     ed2:	bf 93       	push	r27
     ed4:	ef 93       	push	r30
     ed6:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     ed8:	40 91 24 02 	lds	r20, 0x0224	; 0x800224 <__TEXT_REGION_LENGTH__+0x700224>
     edc:	50 91 25 02 	lds	r21, 0x0225	; 0x800225 <__TEXT_REGION_LENGTH__+0x700225>
     ee0:	e0 91 22 23 	lds	r30, 0x2322	; 0x802322 <adca_callback>
     ee4:	f0 91 23 23 	lds	r31, 0x2323	; 0x802323 <adca_callback+0x1>
     ee8:	61 e0       	ldi	r22, 0x01	; 1
     eea:	80 e0       	ldi	r24, 0x00	; 0
     eec:	92 e0       	ldi	r25, 0x02	; 2
     eee:	19 95       	eicall
}
     ef0:	ff 91       	pop	r31
     ef2:	ef 91       	pop	r30
     ef4:	bf 91       	pop	r27
     ef6:	af 91       	pop	r26
     ef8:	9f 91       	pop	r25
     efa:	8f 91       	pop	r24
     efc:	7f 91       	pop	r23
     efe:	6f 91       	pop	r22
     f00:	5f 91       	pop	r21
     f02:	4f 91       	pop	r20
     f04:	3f 91       	pop	r19
     f06:	2f 91       	pop	r18
     f08:	0f 90       	pop	r0
     f0a:	0b be       	out	0x3b, r0	; 59
     f0c:	0f 90       	pop	r0
     f0e:	0f be       	out	0x3f, r0	; 63
     f10:	0f 90       	pop	r0
     f12:	1f 90       	pop	r1
     f14:	18 95       	reti

00000f16 <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f16:	1f 92       	push	r1
     f18:	0f 92       	push	r0
     f1a:	0f b6       	in	r0, 0x3f	; 63
     f1c:	0f 92       	push	r0
     f1e:	11 24       	eor	r1, r1
     f20:	0b b6       	in	r0, 0x3b	; 59
     f22:	0f 92       	push	r0
     f24:	2f 93       	push	r18
     f26:	3f 93       	push	r19
     f28:	4f 93       	push	r20
     f2a:	5f 93       	push	r21
     f2c:	6f 93       	push	r22
     f2e:	7f 93       	push	r23
     f30:	8f 93       	push	r24
     f32:	9f 93       	push	r25
     f34:	af 93       	push	r26
     f36:	bf 93       	push	r27
     f38:	ef 93       	push	r30
     f3a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f3c:	40 91 2c 02 	lds	r20, 0x022C	; 0x80022c <__TEXT_REGION_LENGTH__+0x70022c>
     f40:	50 91 2d 02 	lds	r21, 0x022D	; 0x80022d <__TEXT_REGION_LENGTH__+0x70022d>
     f44:	e0 91 22 23 	lds	r30, 0x2322	; 0x802322 <adca_callback>
     f48:	f0 91 23 23 	lds	r31, 0x2323	; 0x802323 <adca_callback+0x1>
     f4c:	62 e0       	ldi	r22, 0x02	; 2
     f4e:	80 e0       	ldi	r24, 0x00	; 0
     f50:	92 e0       	ldi	r25, 0x02	; 2
     f52:	19 95       	eicall
}
     f54:	ff 91       	pop	r31
     f56:	ef 91       	pop	r30
     f58:	bf 91       	pop	r27
     f5a:	af 91       	pop	r26
     f5c:	9f 91       	pop	r25
     f5e:	8f 91       	pop	r24
     f60:	7f 91       	pop	r23
     f62:	6f 91       	pop	r22
     f64:	5f 91       	pop	r21
     f66:	4f 91       	pop	r20
     f68:	3f 91       	pop	r19
     f6a:	2f 91       	pop	r18
     f6c:	0f 90       	pop	r0
     f6e:	0b be       	out	0x3b, r0	; 59
     f70:	0f 90       	pop	r0
     f72:	0f be       	out	0x3f, r0	; 63
     f74:	0f 90       	pop	r0
     f76:	1f 90       	pop	r1
     f78:	18 95       	reti

00000f7a <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     f7a:	1f 92       	push	r1
     f7c:	0f 92       	push	r0
     f7e:	0f b6       	in	r0, 0x3f	; 63
     f80:	0f 92       	push	r0
     f82:	11 24       	eor	r1, r1
     f84:	0b b6       	in	r0, 0x3b	; 59
     f86:	0f 92       	push	r0
     f88:	2f 93       	push	r18
     f8a:	3f 93       	push	r19
     f8c:	4f 93       	push	r20
     f8e:	5f 93       	push	r21
     f90:	6f 93       	push	r22
     f92:	7f 93       	push	r23
     f94:	8f 93       	push	r24
     f96:	9f 93       	push	r25
     f98:	af 93       	push	r26
     f9a:	bf 93       	push	r27
     f9c:	ef 93       	push	r30
     f9e:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fa0:	40 91 34 02 	lds	r20, 0x0234	; 0x800234 <__TEXT_REGION_LENGTH__+0x700234>
     fa4:	50 91 35 02 	lds	r21, 0x0235	; 0x800235 <__TEXT_REGION_LENGTH__+0x700235>
     fa8:	e0 91 22 23 	lds	r30, 0x2322	; 0x802322 <adca_callback>
     fac:	f0 91 23 23 	lds	r31, 0x2323	; 0x802323 <adca_callback+0x1>
     fb0:	64 e0       	ldi	r22, 0x04	; 4
     fb2:	80 e0       	ldi	r24, 0x00	; 0
     fb4:	92 e0       	ldi	r25, 0x02	; 2
     fb6:	19 95       	eicall
}
     fb8:	ff 91       	pop	r31
     fba:	ef 91       	pop	r30
     fbc:	bf 91       	pop	r27
     fbe:	af 91       	pop	r26
     fc0:	9f 91       	pop	r25
     fc2:	8f 91       	pop	r24
     fc4:	7f 91       	pop	r23
     fc6:	6f 91       	pop	r22
     fc8:	5f 91       	pop	r21
     fca:	4f 91       	pop	r20
     fcc:	3f 91       	pop	r19
     fce:	2f 91       	pop	r18
     fd0:	0f 90       	pop	r0
     fd2:	0b be       	out	0x3b, r0	; 59
     fd4:	0f 90       	pop	r0
     fd6:	0f be       	out	0x3f, r0	; 63
     fd8:	0f 90       	pop	r0
     fda:	1f 90       	pop	r1
     fdc:	18 95       	reti

00000fde <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     fde:	1f 92       	push	r1
     fe0:	0f 92       	push	r0
     fe2:	0f b6       	in	r0, 0x3f	; 63
     fe4:	0f 92       	push	r0
     fe6:	11 24       	eor	r1, r1
     fe8:	0b b6       	in	r0, 0x3b	; 59
     fea:	0f 92       	push	r0
     fec:	2f 93       	push	r18
     fee:	3f 93       	push	r19
     ff0:	4f 93       	push	r20
     ff2:	5f 93       	push	r21
     ff4:	6f 93       	push	r22
     ff6:	7f 93       	push	r23
     ff8:	8f 93       	push	r24
     ffa:	9f 93       	push	r25
     ffc:	af 93       	push	r26
     ffe:	bf 93       	push	r27
    1000:	ef 93       	push	r30
    1002:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    1004:	40 91 3c 02 	lds	r20, 0x023C	; 0x80023c <__TEXT_REGION_LENGTH__+0x70023c>
    1008:	50 91 3d 02 	lds	r21, 0x023D	; 0x80023d <__TEXT_REGION_LENGTH__+0x70023d>
    100c:	e0 91 22 23 	lds	r30, 0x2322	; 0x802322 <adca_callback>
    1010:	f0 91 23 23 	lds	r31, 0x2323	; 0x802323 <adca_callback+0x1>
    1014:	68 e0       	ldi	r22, 0x08	; 8
    1016:	80 e0       	ldi	r24, 0x00	; 0
    1018:	92 e0       	ldi	r25, 0x02	; 2
    101a:	19 95       	eicall
}
    101c:	ff 91       	pop	r31
    101e:	ef 91       	pop	r30
    1020:	bf 91       	pop	r27
    1022:	af 91       	pop	r26
    1024:	9f 91       	pop	r25
    1026:	8f 91       	pop	r24
    1028:	7f 91       	pop	r23
    102a:	6f 91       	pop	r22
    102c:	5f 91       	pop	r21
    102e:	4f 91       	pop	r20
    1030:	3f 91       	pop	r19
    1032:	2f 91       	pop	r18
    1034:	0f 90       	pop	r0
    1036:	0b be       	out	0x3b, r0	; 59
    1038:	0f 90       	pop	r0
    103a:	0f be       	out	0x3f, r0	; 63
    103c:	0f 90       	pop	r0
    103e:	1f 90       	pop	r1
    1040:	18 95       	reti

00001042 <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    1042:	1f 92       	push	r1
    1044:	0f 92       	push	r0
    1046:	0f b6       	in	r0, 0x3f	; 63
    1048:	0f 92       	push	r0
    104a:	11 24       	eor	r1, r1
    104c:	0b b6       	in	r0, 0x3b	; 59
    104e:	0f 92       	push	r0
    1050:	2f 93       	push	r18
    1052:	3f 93       	push	r19
    1054:	4f 93       	push	r20
    1056:	5f 93       	push	r21
    1058:	6f 93       	push	r22
    105a:	7f 93       	push	r23
    105c:	8f 93       	push	r24
    105e:	9f 93       	push	r25
    1060:	af 93       	push	r26
    1062:	bf 93       	push	r27
    1064:	ef 93       	push	r30
    1066:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1068:	40 91 64 02 	lds	r20, 0x0264	; 0x800264 <__TEXT_REGION_LENGTH__+0x700264>
    106c:	50 91 65 02 	lds	r21, 0x0265	; 0x800265 <__TEXT_REGION_LENGTH__+0x700265>
    1070:	e0 91 20 23 	lds	r30, 0x2320	; 0x802320 <adcb_callback>
    1074:	f0 91 21 23 	lds	r31, 0x2321	; 0x802321 <adcb_callback+0x1>
    1078:	61 e0       	ldi	r22, 0x01	; 1
    107a:	80 e4       	ldi	r24, 0x40	; 64
    107c:	92 e0       	ldi	r25, 0x02	; 2
    107e:	19 95       	eicall
}
    1080:	ff 91       	pop	r31
    1082:	ef 91       	pop	r30
    1084:	bf 91       	pop	r27
    1086:	af 91       	pop	r26
    1088:	9f 91       	pop	r25
    108a:	8f 91       	pop	r24
    108c:	7f 91       	pop	r23
    108e:	6f 91       	pop	r22
    1090:	5f 91       	pop	r21
    1092:	4f 91       	pop	r20
    1094:	3f 91       	pop	r19
    1096:	2f 91       	pop	r18
    1098:	0f 90       	pop	r0
    109a:	0b be       	out	0x3b, r0	; 59
    109c:	0f 90       	pop	r0
    109e:	0f be       	out	0x3f, r0	; 63
    10a0:	0f 90       	pop	r0
    10a2:	1f 90       	pop	r1
    10a4:	18 95       	reti

000010a6 <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10a6:	1f 92       	push	r1
    10a8:	0f 92       	push	r0
    10aa:	0f b6       	in	r0, 0x3f	; 63
    10ac:	0f 92       	push	r0
    10ae:	11 24       	eor	r1, r1
    10b0:	0b b6       	in	r0, 0x3b	; 59
    10b2:	0f 92       	push	r0
    10b4:	2f 93       	push	r18
    10b6:	3f 93       	push	r19
    10b8:	4f 93       	push	r20
    10ba:	5f 93       	push	r21
    10bc:	6f 93       	push	r22
    10be:	7f 93       	push	r23
    10c0:	8f 93       	push	r24
    10c2:	9f 93       	push	r25
    10c4:	af 93       	push	r26
    10c6:	bf 93       	push	r27
    10c8:	ef 93       	push	r30
    10ca:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    10cc:	40 91 6c 02 	lds	r20, 0x026C	; 0x80026c <__TEXT_REGION_LENGTH__+0x70026c>
    10d0:	50 91 6d 02 	lds	r21, 0x026D	; 0x80026d <__TEXT_REGION_LENGTH__+0x70026d>
    10d4:	e0 91 20 23 	lds	r30, 0x2320	; 0x802320 <adcb_callback>
    10d8:	f0 91 21 23 	lds	r31, 0x2321	; 0x802321 <adcb_callback+0x1>
    10dc:	62 e0       	ldi	r22, 0x02	; 2
    10de:	80 e4       	ldi	r24, 0x40	; 64
    10e0:	92 e0       	ldi	r25, 0x02	; 2
    10e2:	19 95       	eicall
}
    10e4:	ff 91       	pop	r31
    10e6:	ef 91       	pop	r30
    10e8:	bf 91       	pop	r27
    10ea:	af 91       	pop	r26
    10ec:	9f 91       	pop	r25
    10ee:	8f 91       	pop	r24
    10f0:	7f 91       	pop	r23
    10f2:	6f 91       	pop	r22
    10f4:	5f 91       	pop	r21
    10f6:	4f 91       	pop	r20
    10f8:	3f 91       	pop	r19
    10fa:	2f 91       	pop	r18
    10fc:	0f 90       	pop	r0
    10fe:	0b be       	out	0x3b, r0	; 59
    1100:	0f 90       	pop	r0
    1102:	0f be       	out	0x3f, r0	; 63
    1104:	0f 90       	pop	r0
    1106:	1f 90       	pop	r1
    1108:	18 95       	reti

0000110a <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    110a:	1f 92       	push	r1
    110c:	0f 92       	push	r0
    110e:	0f b6       	in	r0, 0x3f	; 63
    1110:	0f 92       	push	r0
    1112:	11 24       	eor	r1, r1
    1114:	0b b6       	in	r0, 0x3b	; 59
    1116:	0f 92       	push	r0
    1118:	2f 93       	push	r18
    111a:	3f 93       	push	r19
    111c:	4f 93       	push	r20
    111e:	5f 93       	push	r21
    1120:	6f 93       	push	r22
    1122:	7f 93       	push	r23
    1124:	8f 93       	push	r24
    1126:	9f 93       	push	r25
    1128:	af 93       	push	r26
    112a:	bf 93       	push	r27
    112c:	ef 93       	push	r30
    112e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1130:	40 91 74 02 	lds	r20, 0x0274	; 0x800274 <__TEXT_REGION_LENGTH__+0x700274>
    1134:	50 91 75 02 	lds	r21, 0x0275	; 0x800275 <__TEXT_REGION_LENGTH__+0x700275>
    1138:	e0 91 20 23 	lds	r30, 0x2320	; 0x802320 <adcb_callback>
    113c:	f0 91 21 23 	lds	r31, 0x2321	; 0x802321 <adcb_callback+0x1>
    1140:	64 e0       	ldi	r22, 0x04	; 4
    1142:	80 e4       	ldi	r24, 0x40	; 64
    1144:	92 e0       	ldi	r25, 0x02	; 2
    1146:	19 95       	eicall
}
    1148:	ff 91       	pop	r31
    114a:	ef 91       	pop	r30
    114c:	bf 91       	pop	r27
    114e:	af 91       	pop	r26
    1150:	9f 91       	pop	r25
    1152:	8f 91       	pop	r24
    1154:	7f 91       	pop	r23
    1156:	6f 91       	pop	r22
    1158:	5f 91       	pop	r21
    115a:	4f 91       	pop	r20
    115c:	3f 91       	pop	r19
    115e:	2f 91       	pop	r18
    1160:	0f 90       	pop	r0
    1162:	0b be       	out	0x3b, r0	; 59
    1164:	0f 90       	pop	r0
    1166:	0f be       	out	0x3f, r0	; 63
    1168:	0f 90       	pop	r0
    116a:	1f 90       	pop	r1
    116c:	18 95       	reti

0000116e <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    116e:	1f 92       	push	r1
    1170:	0f 92       	push	r0
    1172:	0f b6       	in	r0, 0x3f	; 63
    1174:	0f 92       	push	r0
    1176:	11 24       	eor	r1, r1
    1178:	0b b6       	in	r0, 0x3b	; 59
    117a:	0f 92       	push	r0
    117c:	2f 93       	push	r18
    117e:	3f 93       	push	r19
    1180:	4f 93       	push	r20
    1182:	5f 93       	push	r21
    1184:	6f 93       	push	r22
    1186:	7f 93       	push	r23
    1188:	8f 93       	push	r24
    118a:	9f 93       	push	r25
    118c:	af 93       	push	r26
    118e:	bf 93       	push	r27
    1190:	ef 93       	push	r30
    1192:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    1194:	40 91 7c 02 	lds	r20, 0x027C	; 0x80027c <__TEXT_REGION_LENGTH__+0x70027c>
    1198:	50 91 7d 02 	lds	r21, 0x027D	; 0x80027d <__TEXT_REGION_LENGTH__+0x70027d>
    119c:	e0 91 20 23 	lds	r30, 0x2320	; 0x802320 <adcb_callback>
    11a0:	f0 91 21 23 	lds	r31, 0x2321	; 0x802321 <adcb_callback+0x1>
    11a4:	68 e0       	ldi	r22, 0x08	; 8
    11a6:	80 e4       	ldi	r24, 0x40	; 64
    11a8:	92 e0       	ldi	r25, 0x02	; 2
    11aa:	19 95       	eicall
}
    11ac:	ff 91       	pop	r31
    11ae:	ef 91       	pop	r30
    11b0:	bf 91       	pop	r27
    11b2:	af 91       	pop	r26
    11b4:	9f 91       	pop	r25
    11b6:	8f 91       	pop	r24
    11b8:	7f 91       	pop	r23
    11ba:	6f 91       	pop	r22
    11bc:	5f 91       	pop	r21
    11be:	4f 91       	pop	r20
    11c0:	3f 91       	pop	r19
    11c2:	2f 91       	pop	r18
    11c4:	0f 90       	pop	r0
    11c6:	0b be       	out	0x3b, r0	; 59
    11c8:	0f 90       	pop	r0
    11ca:	0f be       	out	0x3f, r0	; 63
    11cc:	0f 90       	pop	r0
    11ce:	1f 90       	pop	r1
    11d0:	18 95       	reti

000011d2 <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    11d2:	df 92       	push	r13
    11d4:	ef 92       	push	r14
    11d6:	ff 92       	push	r15
    11d8:	0f 93       	push	r16
    11da:	1f 93       	push	r17
    11dc:	cf 93       	push	r28
    11de:	df 93       	push	r29
    11e0:	ec 01       	movw	r28, r24
    11e2:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    11e4:	81 15       	cp	r24, r1
    11e6:	22 e0       	ldi	r18, 0x02	; 2
    11e8:	92 07       	cpc	r25, r18
    11ea:	71 f4       	brne	.+28     	; 0x1208 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    11ec:	61 e2       	ldi	r22, 0x21	; 33
    11ee:	70 e0       	ldi	r23, 0x00	; 0
    11f0:	82 e0       	ldi	r24, 0x02	; 2
    11f2:	d4 d0       	rcall	.+424    	; 0x139c <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    11f4:	e8 2e       	mov	r14, r24
    11f6:	f1 2c       	mov	r15, r1
    11f8:	60 e2       	ldi	r22, 0x20	; 32
    11fa:	70 e0       	ldi	r23, 0x00	; 0
    11fc:	82 e0       	ldi	r24, 0x02	; 2
    11fe:	ce d0       	rcall	.+412    	; 0x139c <nvm_read_byte>
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCACAL0);
    1200:	fe 2c       	mov	r15, r14
    1202:	ee 24       	eor	r14, r14
    1204:	e8 2a       	or	r14, r24
    1206:	10 c0       	rjmp	.+32     	; 0x1228 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1208:	80 34       	cpi	r24, 0x40	; 64
    120a:	92 40       	sbci	r25, 0x02	; 2
    120c:	51 f5       	brne	.+84     	; 0x1262 <adc_write_configuration+0x90>
    120e:	65 e2       	ldi	r22, 0x25	; 37
    1210:	70 e0       	ldi	r23, 0x00	; 0
    1212:	82 e0       	ldi	r24, 0x02	; 2
    1214:	c3 d0       	rcall	.+390    	; 0x139c <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    1216:	e8 2e       	mov	r14, r24
    1218:	f1 2c       	mov	r15, r1
    121a:	64 e2       	ldi	r22, 0x24	; 36
    121c:	70 e0       	ldi	r23, 0x00	; 0
    121e:	82 e0       	ldi	r24, 0x02	; 2
		data <<= 8;
		data |= nvm_read_production_signature_row(ADCBCAL0);
    1220:	bd d0       	rcall	.+378    	; 0x139c <nvm_read_byte>
    1222:	fe 2c       	mov	r15, r14

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1224:	ee 24       	eor	r14, r14
	cpu_irq_disable();
    1226:	e8 2a       	or	r14, r24
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1228:	df b6       	in	r13, 0x3f	; 63
    122a:	f8 94       	cli
    122c:	ce 01       	movw	r24, r28
	enable = adc->CTRLA & ADC_ENABLE_bm;
    122e:	05 de       	rcall	.-1014   	; 0xe3a <adc_enable_clock>

	adc->CTRLA = ADC_FLUSH_bm;
    1230:	88 81       	ld	r24, Y
    1232:	92 e0       	ldi	r25, 0x02	; 2
	adc->CAL = cal;
    1234:	98 83       	st	Y, r25
    1236:	ec 86       	std	Y+12, r14	; 0x0c
	adc->CMP = conf->cmp;
    1238:	fd 86       	std	Y+13, r15	; 0x0d
    123a:	f8 01       	movw	r30, r16
    123c:	25 81       	ldd	r18, Z+5	; 0x05
    123e:	36 81       	ldd	r19, Z+6	; 0x06
    1240:	28 8f       	std	Y+24, r18	; 0x18
	adc->REFCTRL = conf->refctrl;
    1242:	39 8f       	std	Y+25, r19	; 0x19
    1244:	92 81       	ldd	r25, Z+2	; 0x02
	adc->PRESCALER = conf->prescaler;
    1246:	9a 83       	std	Y+2, r25	; 0x02
    1248:	94 81       	ldd	r25, Z+4	; 0x04
	adc->EVCTRL = conf->evctrl;
    124a:	9c 83       	std	Y+4, r25	; 0x04
    124c:	93 81       	ldd	r25, Z+3	; 0x03
	adc->CTRLB = conf->ctrlb;
    124e:	9b 83       	std	Y+3, r25	; 0x03

	adc->CTRLA = enable | conf->ctrla;
    1250:	91 81       	ldd	r25, Z+1	; 0x01
    1252:	99 83       	std	Y+1, r25	; 0x01
    1254:	81 70       	andi	r24, 0x01	; 1

	adc_disable_clock(adc);
    1256:	90 81       	ld	r25, Z
    1258:	89 2b       	or	r24, r25
    125a:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    125c:	ce 01       	movw	r24, r28

	cpu_irq_restore(flags);
}
    125e:	0c de       	rcall	.-1000   	; 0xe78 <adc_disable_clock>
    1260:	df be       	out	0x3f, r13	; 63
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	1f 91       	pop	r17
    1268:	0f 91       	pop	r16
    126a:	ff 90       	pop	r15
    126c:	ef 90       	pop	r14
    126e:	df 90       	pop	r13
    1270:	08 95       	ret

00001272 <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    1272:	ff 92       	push	r15
    1274:	0f 93       	push	r16
    1276:	1f 93       	push	r17
    1278:	cf 93       	push	r28
    127a:	df 93       	push	r29
    127c:	ec 01       	movw	r28, r24
    127e:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1280:	ff b6       	in	r15, 0x3f	; 63
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    1282:	f8 94       	cli

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    1284:	da dd       	rcall	.-1100   	; 0xe3a <adc_enable_clock>
    1286:	88 81       	ld	r24, Y
    1288:	80 7c       	andi	r24, 0xC0	; 192
    128a:	f8 01       	movw	r30, r16

	conf->cmp = adc->CMP;
    128c:	80 83       	st	Z, r24
    128e:	88 8d       	ldd	r24, Y+24	; 0x18
    1290:	99 8d       	ldd	r25, Y+25	; 0x19
    1292:	85 83       	std	Z+5, r24	; 0x05
	conf->refctrl = adc->REFCTRL;
    1294:	96 83       	std	Z+6, r25	; 0x06
    1296:	8a 81       	ldd	r24, Y+2	; 0x02
	conf->prescaler = adc->PRESCALER;
    1298:	82 83       	std	Z+2, r24	; 0x02
    129a:	8c 81       	ldd	r24, Y+4	; 0x04
	conf->evctrl = adc->EVCTRL;
    129c:	84 83       	std	Z+4, r24	; 0x04
    129e:	8b 81       	ldd	r24, Y+3	; 0x03
	conf->ctrlb = adc->CTRLB;
    12a0:	83 83       	std	Z+3, r24	; 0x03

	adc_disable_clock(adc);
    12a2:	89 81       	ldd	r24, Y+1	; 0x01
    12a4:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12a6:	ce 01       	movw	r24, r28

	cpu_irq_restore(flags);
}
    12a8:	e7 dd       	rcall	.-1074   	; 0xe78 <adc_disable_clock>
    12aa:	ff be       	out	0x3f, r15	; 63
    12ac:	df 91       	pop	r29
    12ae:	cf 91       	pop	r28
    12b0:	1f 91       	pop	r17
    12b2:	0f 91       	pop	r16
    12b4:	ff 90       	pop	r15
    12b6:	08 95       	ret

000012b8 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12b8:	cf 92       	push	r12
    12ba:	df 92       	push	r13
    12bc:	ef 92       	push	r14
    12be:	ff 92       	push	r15
    12c0:	0f 93       	push	r16
    12c2:	1f 93       	push	r17
    12c4:	cf 93       	push	r28
    12c6:	df 93       	push	r29
    12c8:	7c 01       	movw	r14, r24
    12ca:	d6 2e       	mov	r13, r22
    12cc:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12ce:	86 2f       	mov	r24, r22
    12d0:	83 70       	andi	r24, 0x03	; 3
    12d2:	29 f4       	brne	.+10     	; 0x12de <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    12d4:	96 2f       	mov	r25, r22
    12d6:	96 95       	lsr	r25
    12d8:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    12da:	82 e0       	ldi	r24, 0x02	; 2
    12dc:	02 c0       	rjmp	.+4      	; 0x12e2 <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12de:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    12e0:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    12e2:	90 ff       	sbrs	r25, 0
		index++;
    12e4:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    12e6:	e7 01       	movw	r28, r14
    12e8:	a0 96       	adiw	r28, 0x20	; 32
    12ea:	98 e0       	ldi	r25, 0x08	; 8
    12ec:	89 9f       	mul	r24, r25
    12ee:	c0 0d       	add	r28, r0
    12f0:	d1 1d       	adc	r29, r1
    12f2:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12f4:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    12f6:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    12f8:	c7 01       	movw	r24, r14
    12fa:	9f dd       	rcall	.-1218   	; 0xe3a <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    12fc:	f8 01       	movw	r30, r16
    12fe:	80 81       	ld	r24, Z
    1300:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    1302:	82 81       	ldd	r24, Z+2	; 0x02
    1304:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    1306:	81 81       	ldd	r24, Z+1	; 0x01
    1308:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    130a:	d0 fe       	sbrs	r13, 0
    130c:	02 c0       	rjmp	.+4      	; 0x1312 <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    130e:	83 81       	ldd	r24, Z+3	; 0x03
	}
	adc_disable_clock(adc);
    1310:	8e 83       	std	Y+6, r24	; 0x06
    1312:	c7 01       	movw	r24, r14
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1314:	b1 dd       	rcall	.-1182   	; 0xe78 <adc_disable_clock>

	cpu_irq_restore(flags);
}
    1316:	cf be       	out	0x3f, r12	; 63
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	ff 90       	pop	r15
    1322:	ef 90       	pop	r14
    1324:	df 90       	pop	r13
    1326:	cf 90       	pop	r12
    1328:	08 95       	ret

0000132a <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    132a:	cf 92       	push	r12
    132c:	df 92       	push	r13
    132e:	ef 92       	push	r14
    1330:	ff 92       	push	r15
    1332:	0f 93       	push	r16
    1334:	1f 93       	push	r17
    1336:	cf 93       	push	r28
    1338:	df 93       	push	r29
    133a:	7c 01       	movw	r14, r24
    133c:	d6 2e       	mov	r13, r22
    133e:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1340:	86 2f       	mov	r24, r22
    1342:	83 70       	andi	r24, 0x03	; 3
    1344:	29 f4       	brne	.+10     	; 0x1350 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    1346:	96 2f       	mov	r25, r22
    1348:	96 95       	lsr	r25
    134a:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    134c:	82 e0       	ldi	r24, 0x02	; 2
    134e:	02 c0       	rjmp	.+4      	; 0x1354 <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1350:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    1352:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    1354:	90 ff       	sbrs	r25, 0
		index++;
    1356:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1358:	e7 01       	movw	r28, r14
    135a:	a0 96       	adiw	r28, 0x20	; 32
    135c:	98 e0       	ldi	r25, 0x08	; 8
    135e:	89 9f       	mul	r24, r25
    1360:	c0 0d       	add	r28, r0
    1362:	d1 1d       	adc	r29, r1
    1364:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1366:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1368:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    136a:	c7 01       	movw	r24, r14
    136c:	66 dd       	rcall	.-1332   	; 0xe3a <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    136e:	88 81       	ld	r24, Y
    1370:	f8 01       	movw	r30, r16
    1372:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    1374:	8a 81       	ldd	r24, Y+2	; 0x02
    1376:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1378:	89 81       	ldd	r24, Y+1	; 0x01
    137a:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    137c:	d0 fe       	sbrs	r13, 0
    137e:	02 c0       	rjmp	.+4      	; 0x1384 <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1380:	8e 81       	ldd	r24, Y+6	; 0x06
	}
	adc_disable_clock(adc);
    1382:	83 83       	std	Z+3, r24	; 0x03
    1384:	c7 01       	movw	r24, r14
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1386:	78 dd       	rcall	.-1296   	; 0xe78 <adc_disable_clock>

	cpu_irq_restore(flags);
}
    1388:	cf be       	out	0x3f, r12	; 63
    138a:	df 91       	pop	r29
    138c:	cf 91       	pop	r28
    138e:	1f 91       	pop	r17
    1390:	0f 91       	pop	r16
    1392:	ff 90       	pop	r15
    1394:	ef 90       	pop	r14
    1396:	df 90       	pop	r13
    1398:	cf 90       	pop	r12
    139a:	08 95       	ret

0000139c <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    139c:	40 91 ca 01 	lds	r20, 0x01CA	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	mov ZL, r22               ; Load byte index into low byte of Z.
    13a0:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13a2:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13a4:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	lpm r24, Z                ; Perform an LPM to read out byte
    13a8:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13aa:	40 93 ca 01 	sts	0x01CA, r20	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7001ca>
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13ae:	08 95       	ret

000013b0 <usart_putchar>:

	if (baud_offset != USART_BAUD_UNDEFINED) {
		(usart)->BAUDCTRLB = (uint8_t)((uint16_t)baudctrl);
		(usart)->BAUDCTRLA = (uint8_t)((uint16_t)baudctrl >> 8);
	}
}
    13b0:	fc 01       	movw	r30, r24
    13b2:	91 81       	ldd	r25, Z+1	; 0x01
    13b4:	95 ff       	sbrs	r25, 5
    13b6:	fd cf       	rjmp	.-6      	; 0x13b2 <usart_putchar+0x2>
    13b8:	60 83       	st	Z, r22
    13ba:	80 e0       	ldi	r24, 0x00	; 0
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	08 95       	ret

000013c0 <usart_getchar>:
    13c0:	fc 01       	movw	r30, r24
    13c2:	91 81       	ldd	r25, Z+1	; 0x01
    13c4:	99 23       	and	r25, r25
    13c6:	ec f7       	brge	.-6      	; 0x13c2 <usart_getchar+0x2>
    13c8:	80 81       	ld	r24, Z
    13ca:	08 95       	ret

000013cc <usart_set_baudrate>:
 * \retval true if the hardware supports the baud rate
 * \retval false if the hardware does not support the baud rate (i.e. it's
 *               either too high or too low.)
 */
bool usart_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    13cc:	4f 92       	push	r4
    13ce:	5f 92       	push	r5
    13d0:	6f 92       	push	r6
    13d2:	7f 92       	push	r7
    13d4:	8f 92       	push	r8
    13d6:	9f 92       	push	r9
    13d8:	af 92       	push	r10
    13da:	bf 92       	push	r11
    13dc:	ef 92       	push	r14
    13de:	ff 92       	push	r15
    13e0:	0f 93       	push	r16
    13e2:	1f 93       	push	r17
    13e4:	cf 93       	push	r28
    13e6:	7c 01       	movw	r14, r24
    13e8:	4a 01       	movw	r8, r20
    13ea:	5b 01       	movw	r10, r22
    13ec:	28 01       	movw	r4, r16
    13ee:	39 01       	movw	r6, r18
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    13f0:	fc 01       	movw	r30, r24
    13f2:	84 81       	ldd	r24, Z+4	; 0x04
    13f4:	82 ff       	sbrs	r24, 2
    13f6:	16 c0       	rjmp	.+44     	; 0x1424 <usart_set_baudrate+0x58>

	/*
	 * Check if the hardware supports the given baud rate
	 */
	/* 8 = (2^0) * 8 * (2^0) = (2^BSCALE_MIN) * 8 * (BSEL_MIN) */
	max_rate = cpu_hz / 8;
    13f8:	d9 01       	movw	r26, r18
    13fa:	c8 01       	movw	r24, r16
    13fc:	68 94       	set
    13fe:	12 f8       	bld	r1, 2
    1400:	b6 95       	lsr	r27
    1402:	a7 95       	ror	r26
    1404:	97 95       	ror	r25
    1406:	87 95       	ror	r24
    1408:	16 94       	lsr	r1
    140a:	d1 f7       	brne	.-12     	; 0x1400 <usart_set_baudrate+0x34>
	/* 4194304 = (2^7) * 8 * (2^12) = (2^BSCALE_MAX) * 8 * (BSEL_MAX+1) */
	min_rate = cpu_hz / 4194304;
    140c:	b9 01       	movw	r22, r18
    140e:	a8 01       	movw	r20, r16
    1410:	03 2e       	mov	r0, r19
    1412:	36 e1       	ldi	r19, 0x16	; 22
    1414:	76 95       	lsr	r23
    1416:	67 95       	ror	r22
    1418:	57 95       	ror	r21
    141a:	47 95       	ror	r20
    141c:	3a 95       	dec	r19
    141e:	d1 f7       	brne	.-12     	; 0x1414 <usart_set_baudrate+0x48>
    1420:	30 2d       	mov	r19, r0
    1422:	15 c0       	rjmp	.+42     	; 0x144e <usart_set_baudrate+0x82>

	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
		max_rate /= 2;
    1424:	d9 01       	movw	r26, r18
    1426:	c8 01       	movw	r24, r16
    1428:	68 94       	set
    142a:	13 f8       	bld	r1, 3
    142c:	b6 95       	lsr	r27
    142e:	a7 95       	ror	r26
    1430:	97 95       	ror	r25
    1432:	87 95       	ror	r24
    1434:	16 94       	lsr	r1
    1436:	d1 f7       	brne	.-12     	; 0x142c <usart_set_baudrate+0x60>
		min_rate /= 2;
    1438:	b9 01       	movw	r22, r18
    143a:	a8 01       	movw	r20, r16
    143c:	03 2e       	mov	r0, r19
    143e:	37 e1       	ldi	r19, 0x17	; 23
    1440:	76 95       	lsr	r23
    1442:	67 95       	ror	r22
    1444:	57 95       	ror	r21
    1446:	47 95       	ror	r20
    1448:	3a 95       	dec	r19
    144a:	d1 f7       	brne	.-12     	; 0x1440 <usart_set_baudrate+0x74>
    144c:	30 2d       	mov	r19, r0
	}

	if ((baud > max_rate) || (baud < min_rate)) {
    144e:	88 15       	cp	r24, r8
    1450:	99 05       	cpc	r25, r9
    1452:	aa 05       	cpc	r26, r10
    1454:	bb 05       	cpc	r27, r11
    1456:	08 f4       	brcc	.+2      	; 0x145a <usart_set_baudrate+0x8e>
    1458:	a6 c0       	rjmp	.+332    	; 0x15a6 <usart_set_baudrate+0x1da>
    145a:	84 16       	cp	r8, r20
    145c:	95 06       	cpc	r9, r21
    145e:	a6 06       	cpc	r10, r22
    1460:	b7 06       	cpc	r11, r23
    1462:	08 f4       	brcc	.+2      	; 0x1466 <usart_set_baudrate+0x9a>
    1464:	a2 c0       	rjmp	.+324    	; 0x15aa <usart_set_baudrate+0x1de>
		return false;
	}

	/* Check if double speed is enabled. */
	if (!((usart)->CTRLB & USART_CLK2X_bm)) {
    1466:	f7 01       	movw	r30, r14
    1468:	84 81       	ldd	r24, Z+4	; 0x04
    146a:	82 fd       	sbrc	r24, 2
    146c:	04 c0       	rjmp	.+8      	; 0x1476 <usart_set_baudrate+0xaa>
		baud *= 2;
    146e:	88 0c       	add	r8, r8
    1470:	99 1c       	adc	r9, r9
    1472:	aa 1c       	adc	r10, r10
    1474:	bb 1c       	adc	r11, r11
	}

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;
    1476:	c3 01       	movw	r24, r6
    1478:	b2 01       	movw	r22, r4
    147a:	a5 01       	movw	r20, r10
    147c:	94 01       	movw	r18, r8
    147e:	0e 94 31 1b 	call	0x3662	; 0x3662 <__udivmodsi4>

	for (exp = -7; exp < 7; exp++) {
		if (ratio < limit) {
    1482:	2f 3f       	cpi	r18, 0xFF	; 255
    1484:	31 05       	cpc	r19, r1
    1486:	41 05       	cpc	r20, r1
    1488:	51 05       	cpc	r21, r1
    148a:	08 f4       	brcc	.+2      	; 0x148e <usart_set_baudrate+0xc2>
    148c:	90 c0       	rjmp	.+288    	; 0x15ae <usart_set_baudrate+0x1e2>
    148e:	8f ef       	ldi	r24, 0xFF	; 255
    1490:	90 e0       	ldi	r25, 0x00	; 0
    1492:	a0 e0       	ldi	r26, 0x00	; 0
    1494:	b0 e0       	ldi	r27, 0x00	; 0
    1496:	c9 ef       	ldi	r28, 0xF9	; 249
    1498:	05 c0       	rjmp	.+10     	; 0x14a4 <usart_set_baudrate+0xd8>
    149a:	28 17       	cp	r18, r24
    149c:	39 07       	cpc	r19, r25
    149e:	4a 07       	cpc	r20, r26
    14a0:	5b 07       	cpc	r21, r27
    14a2:	58 f0       	brcs	.+22     	; 0x14ba <usart_set_baudrate+0xee>
			break;
		}

		limit <<= 1;
    14a4:	88 0f       	add	r24, r24
    14a6:	99 1f       	adc	r25, r25
    14a8:	aa 1f       	adc	r26, r26
    14aa:	bb 1f       	adc	r27, r27

		if (exp < -3) {
    14ac:	cd 3f       	cpi	r28, 0xFD	; 253
    14ae:	0c f4       	brge	.+2      	; 0x14b2 <usart_set_baudrate+0xe6>
			limit |= 1;
    14b0:	81 60       	ori	r24, 0x01	; 1
    14b2:	cf 5f       	subi	r28, 0xFF	; 255

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    14b4:	c7 30       	cpi	r28, 0x07	; 7
    14b6:	89 f7       	brne	.-30     	; 0x149a <usart_set_baudrate+0xce>
    14b8:	4f c0       	rjmp	.+158    	; 0x1558 <usart_set_baudrate+0x18c>
	 * point.
	 *
	 * The formula for calculating BSEL is slightly different when exp is
	 * negative than it is when exp is positive.
	 */
	if (exp < 0) {
    14ba:	cc 23       	and	r28, r28
    14bc:	0c f0       	brlt	.+2      	; 0x14c0 <usart_set_baudrate+0xf4>
    14be:	4c c0       	rjmp	.+152    	; 0x1558 <usart_set_baudrate+0x18c>
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    14c0:	d5 01       	movw	r26, r10
    14c2:	c4 01       	movw	r24, r8
    14c4:	88 0f       	add	r24, r24
    14c6:	99 1f       	adc	r25, r25
    14c8:	aa 1f       	adc	r26, r26
    14ca:	bb 1f       	adc	r27, r27
    14cc:	88 0f       	add	r24, r24
    14ce:	99 1f       	adc	r25, r25
    14d0:	aa 1f       	adc	r26, r26
    14d2:	bb 1f       	adc	r27, r27
    14d4:	88 0f       	add	r24, r24
    14d6:	99 1f       	adc	r25, r25
    14d8:	aa 1f       	adc	r26, r26
    14da:	bb 1f       	adc	r27, r27
    14dc:	48 1a       	sub	r4, r24
    14de:	59 0a       	sbc	r5, r25
    14e0:	6a 0a       	sbc	r6, r26
    14e2:	7b 0a       	sbc	r7, r27
		/* If we end up with a left-shift after taking the final
		 * divide-by-8 into account, do the shift before the divide.
		 * Otherwise, left-shift the denominator instead (effectively
		 * resulting in an overall right shift.)
		 */
		if (exp <= -3) {
    14e4:	ce 3f       	cpi	r28, 0xFE	; 254
    14e6:	f4 f4       	brge	.+60     	; 0x1524 <usart_set_baudrate+0x158>
			div = ((cpu_hz << (-exp - 3)) + baud / 2) / baud;
    14e8:	8d ef       	ldi	r24, 0xFD	; 253
    14ea:	9f ef       	ldi	r25, 0xFF	; 255
    14ec:	8c 1b       	sub	r24, r28
    14ee:	91 09       	sbc	r25, r1
    14f0:	c7 fd       	sbrc	r28, 7
    14f2:	93 95       	inc	r25
    14f4:	04 c0       	rjmp	.+8      	; 0x14fe <usart_set_baudrate+0x132>
    14f6:	44 0c       	add	r4, r4
    14f8:	55 1c       	adc	r5, r5
    14fa:	66 1c       	adc	r6, r6
    14fc:	77 1c       	adc	r7, r7
    14fe:	8a 95       	dec	r24
    1500:	d2 f7       	brpl	.-12     	; 0x14f6 <usart_set_baudrate+0x12a>
    1502:	d5 01       	movw	r26, r10
    1504:	c4 01       	movw	r24, r8
    1506:	b6 95       	lsr	r27
    1508:	a7 95       	ror	r26
    150a:	97 95       	ror	r25
    150c:	87 95       	ror	r24
    150e:	bc 01       	movw	r22, r24
    1510:	cd 01       	movw	r24, r26
    1512:	64 0d       	add	r22, r4
    1514:	75 1d       	adc	r23, r5
    1516:	86 1d       	adc	r24, r6
    1518:	97 1d       	adc	r25, r7
    151a:	a5 01       	movw	r20, r10
    151c:	94 01       	movw	r18, r8
    151e:	0e 94 31 1b 	call	0x3662	; 0x3662 <__udivmodsi4>
    1522:	37 c0       	rjmp	.+110    	; 0x1592 <usart_set_baudrate+0x1c6>
		} else {
			baud <<= exp + 3;
    1524:	83 e0       	ldi	r24, 0x03	; 3
    1526:	8c 0f       	add	r24, r28
    1528:	a5 01       	movw	r20, r10
    152a:	94 01       	movw	r18, r8
    152c:	04 c0       	rjmp	.+8      	; 0x1536 <usart_set_baudrate+0x16a>
    152e:	22 0f       	add	r18, r18
    1530:	33 1f       	adc	r19, r19
    1532:	44 1f       	adc	r20, r20
    1534:	55 1f       	adc	r21, r21
    1536:	8a 95       	dec	r24
    1538:	d2 f7       	brpl	.-12     	; 0x152e <usart_set_baudrate+0x162>
			div = (cpu_hz + baud / 2) / baud;
    153a:	da 01       	movw	r26, r20
    153c:	c9 01       	movw	r24, r18
    153e:	b6 95       	lsr	r27
    1540:	a7 95       	ror	r26
    1542:	97 95       	ror	r25
    1544:	87 95       	ror	r24
    1546:	bc 01       	movw	r22, r24
    1548:	cd 01       	movw	r24, r26
    154a:	64 0d       	add	r22, r4
    154c:	75 1d       	adc	r23, r5
    154e:	86 1d       	adc	r24, r6
    1550:	97 1d       	adc	r25, r7
    1552:	0e 94 31 1b 	call	0x3662	; 0x3662 <__udivmodsi4>
    1556:	1d c0       	rjmp	.+58     	; 0x1592 <usart_set_baudrate+0x1c6>
		}
	} else {
		/* We will always do a right shift in this case, but we need to
		 * shift three extra positions because of the divide-by-8.
		 */
		baud <<= exp + 3;
    1558:	83 e0       	ldi	r24, 0x03	; 3
    155a:	8c 0f       	add	r24, r28
    155c:	a5 01       	movw	r20, r10
    155e:	94 01       	movw	r18, r8
    1560:	04 c0       	rjmp	.+8      	; 0x156a <usart_set_baudrate+0x19e>
    1562:	22 0f       	add	r18, r18
    1564:	33 1f       	adc	r19, r19
    1566:	44 1f       	adc	r20, r20
    1568:	55 1f       	adc	r21, r21
    156a:	8a 95       	dec	r24
    156c:	d2 f7       	brpl	.-12     	; 0x1562 <usart_set_baudrate+0x196>
		div = (cpu_hz + baud / 2) / baud - 1;
    156e:	da 01       	movw	r26, r20
    1570:	c9 01       	movw	r24, r18
    1572:	b6 95       	lsr	r27
    1574:	a7 95       	ror	r26
    1576:	97 95       	ror	r25
    1578:	87 95       	ror	r24
    157a:	bc 01       	movw	r22, r24
    157c:	cd 01       	movw	r24, r26
    157e:	64 0d       	add	r22, r4
    1580:	75 1d       	adc	r23, r5
    1582:	86 1d       	adc	r24, r6
    1584:	97 1d       	adc	r25, r7
    1586:	0e 94 31 1b 	call	0x3662	; 0x3662 <__udivmodsi4>
    158a:	21 50       	subi	r18, 0x01	; 1
    158c:	31 09       	sbc	r19, r1
    158e:	41 09       	sbc	r20, r1
    1590:	51 09       	sbc	r21, r1
	}

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
    1592:	83 2f       	mov	r24, r19
    1594:	8f 70       	andi	r24, 0x0F	; 15
    1596:	c2 95       	swap	r28
    1598:	c0 7f       	andi	r28, 0xF0	; 240
    159a:	c8 2b       	or	r28, r24
    159c:	f7 01       	movw	r30, r14
    159e:	c7 83       	std	Z+7, r28	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)div;
    15a0:	26 83       	std	Z+6, r18	; 0x06

	return true;
    15a2:	81 e0       	ldi	r24, 0x01	; 1
    15a4:	18 c0       	rjmp	.+48     	; 0x15d6 <usart_set_baudrate+0x20a>
		max_rate /= 2;
		min_rate /= 2;
	}

	if ((baud > max_rate) || (baud < min_rate)) {
		return false;
    15a6:	80 e0       	ldi	r24, 0x00	; 0
    15a8:	16 c0       	rjmp	.+44     	; 0x15d6 <usart_set_baudrate+0x20a>
    15aa:	80 e0       	ldi	r24, 0x00	; 0
    15ac:	14 c0       	rjmp	.+40     	; 0x15d6 <usart_set_baudrate+0x20a>
	if (exp < 0) {
		/* We are supposed to subtract 1, then apply BSCALE. We want to
		 * apply BSCALE first, so we need to turn everything inside the
		 * parenthesis into a single fractional expression.
		 */
		cpu_hz -= 8 * baud;
    15ae:	d5 01       	movw	r26, r10
    15b0:	c4 01       	movw	r24, r8
    15b2:	88 0f       	add	r24, r24
    15b4:	99 1f       	adc	r25, r25
    15b6:	aa 1f       	adc	r26, r26
    15b8:	bb 1f       	adc	r27, r27
    15ba:	88 0f       	add	r24, r24
    15bc:	99 1f       	adc	r25, r25
    15be:	aa 1f       	adc	r26, r26
    15c0:	bb 1f       	adc	r27, r27
    15c2:	88 0f       	add	r24, r24
    15c4:	99 1f       	adc	r25, r25
    15c6:	aa 1f       	adc	r26, r26
    15c8:	bb 1f       	adc	r27, r27
    15ca:	48 1a       	sub	r4, r24
    15cc:	59 0a       	sbc	r5, r25
    15ce:	6a 0a       	sbc	r6, r26
    15d0:	7b 0a       	sbc	r7, r27

	/* Find the lowest possible exponent. */
	limit = 0xfffU >> 4;
	ratio = cpu_hz / baud;

	for (exp = -7; exp < 7; exp++) {
    15d2:	c9 ef       	ldi	r28, 0xF9	; 249
    15d4:	89 cf       	rjmp	.-238    	; 0x14e8 <usart_set_baudrate+0x11c>

	(usart)->BAUDCTRLB = (uint8_t)(((div >> 8) & 0X0F) | (exp << 4));
	(usart)->BAUDCTRLA = (uint8_t)div;

	return true;
}
    15d6:	cf 91       	pop	r28
    15d8:	1f 91       	pop	r17
    15da:	0f 91       	pop	r16
    15dc:	ff 90       	pop	r15
    15de:	ef 90       	pop	r14
    15e0:	bf 90       	pop	r11
    15e2:	af 90       	pop	r10
    15e4:	9f 90       	pop	r9
    15e6:	8f 90       	pop	r8
    15e8:	7f 90       	pop	r7
    15ea:	6f 90       	pop	r6
    15ec:	5f 90       	pop	r5
    15ee:	4f 90       	pop	r4
    15f0:	08 95       	ret

000015f2 <usart_init_rs232>:
 *
 * \retval true if the initialization was successfull
 * \retval false if the initialization failed (error in baud rate calculation)
 */
bool usart_init_rs232(USART_t *usart, const usart_rs232_options_t *opt)
{
    15f2:	0f 93       	push	r16
    15f4:	1f 93       	push	r17
    15f6:	cf 93       	push	r28
    15f8:	df 93       	push	r29
    15fa:	ec 01       	movw	r28, r24
    15fc:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    15fe:	00 97       	sbiw	r24, 0x00	; 0
    1600:	09 f4       	brne	.+2      	; 0x1604 <usart_init_rs232+0x12>
    1602:	e6 c0       	rjmp	.+460    	; 0x17d0 <usart_init_rs232+0x1de>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1604:	80 3c       	cpi	r24, 0xC0	; 192
    1606:	91 05       	cpc	r25, r1
    1608:	21 f4       	brne	.+8      	; 0x1612 <usart_init_rs232+0x20>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    160a:	60 e1       	ldi	r22, 0x10	; 16
    160c:	80 e0       	ldi	r24, 0x00	; 0
    160e:	45 d9       	rcall	.-3446   	; 0x89a <sysclk_enable_module>
    1610:	df c0       	rjmp	.+446    	; 0x17d0 <usart_init_rs232+0x1de>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1612:	c0 38       	cpi	r28, 0x80	; 128
    1614:	81 e0       	ldi	r24, 0x01	; 1
    1616:	d8 07       	cpc	r29, r24
    1618:	21 f4       	brne	.+8      	; 0x1622 <usart_init_rs232+0x30>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    161a:	62 e0       	ldi	r22, 0x02	; 2
    161c:	80 e0       	ldi	r24, 0x00	; 0
    161e:	3d d9       	rcall	.-3462   	; 0x89a <sysclk_enable_module>
    1620:	d7 c0       	rjmp	.+430    	; 0x17d0 <usart_init_rs232+0x1de>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    1622:	c1 15       	cp	r28, r1
    1624:	e1 e0       	ldi	r30, 0x01	; 1
    1626:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1628:	21 f4       	brne	.+8      	; 0x1632 <usart_init_rs232+0x40>
    162a:	61 e0       	ldi	r22, 0x01	; 1
    162c:	80 e0       	ldi	r24, 0x00	; 0
    162e:	35 d9       	rcall	.-3478   	; 0x89a <sysclk_enable_module>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    1630:	cf c0       	rjmp	.+414    	; 0x17d0 <usart_init_rs232+0x1de>
    1632:	c0 38       	cpi	r28, 0x80	; 128
    1634:	f3 e0       	ldi	r31, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1636:	df 07       	cpc	r29, r31
    1638:	21 f4       	brne	.+8      	; 0x1642 <usart_init_rs232+0x50>
    163a:	61 e0       	ldi	r22, 0x01	; 1
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	2d d9       	rcall	.-3494   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    1640:	c7 c0       	rjmp	.+398    	; 0x17d0 <usart_init_rs232+0x1de>
    1642:	c0 39       	cpi	r28, 0x90	; 144
    1644:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1646:	d8 07       	cpc	r29, r24
    1648:	21 f4       	brne	.+8      	; 0x1652 <usart_init_rs232+0x60>
    164a:	61 e0       	ldi	r22, 0x01	; 1
    164c:	82 e0       	ldi	r24, 0x02	; 2
    164e:	25 d9       	rcall	.-3510   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    1650:	bf c0       	rjmp	.+382    	; 0x17d0 <usart_init_rs232+0x1de>
    1652:	c1 15       	cp	r28, r1
    1654:	e2 e0       	ldi	r30, 0x02	; 2
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1656:	de 07       	cpc	r29, r30
    1658:	21 f4       	brne	.+8      	; 0x1662 <usart_init_rs232+0x70>
    165a:	62 e0       	ldi	r22, 0x02	; 2
    165c:	81 e0       	ldi	r24, 0x01	; 1
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    165e:	1d d9       	rcall	.-3526   	; 0x89a <sysclk_enable_module>
    1660:	b7 c0       	rjmp	.+366    	; 0x17d0 <usart_init_rs232+0x1de>
    1662:	c0 34       	cpi	r28, 0x40	; 64
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1664:	f2 e0       	ldi	r31, 0x02	; 2
    1666:	df 07       	cpc	r29, r31
    1668:	21 f4       	brne	.+8      	; 0x1672 <usart_init_rs232+0x80>
    166a:	62 e0       	ldi	r22, 0x02	; 2
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    166c:	82 e0       	ldi	r24, 0x02	; 2
    166e:	15 d9       	rcall	.-3542   	; 0x89a <sysclk_enable_module>
    1670:	af c0       	rjmp	.+350    	; 0x17d0 <usart_init_rs232+0x1de>
    1672:	c0 32       	cpi	r28, 0x20	; 32
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    1674:	83 e0       	ldi	r24, 0x03	; 3
    1676:	d8 07       	cpc	r29, r24
    1678:	21 f4       	brne	.+8      	; 0x1682 <usart_init_rs232+0x90>
    167a:	64 e0       	ldi	r22, 0x04	; 4
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    167c:	82 e0       	ldi	r24, 0x02	; 2
    167e:	0d d9       	rcall	.-3558   	; 0x89a <sysclk_enable_module>
    1680:	a7 c0       	rjmp	.+334    	; 0x17d0 <usart_init_rs232+0x1de>
    1682:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1684:	e8 e0       	ldi	r30, 0x08	; 8
    1686:	de 07       	cpc	r29, r30
    1688:	21 f4       	brne	.+8      	; 0x1692 <usart_init_rs232+0xa0>
    168a:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    168c:	83 e0       	ldi	r24, 0x03	; 3
    168e:	05 d9       	rcall	.-3574   	; 0x89a <sysclk_enable_module>
    1690:	9f c0       	rjmp	.+318    	; 0x17d0 <usart_init_rs232+0x1de>
    1692:	c1 15       	cp	r28, r1
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1694:	f9 e0       	ldi	r31, 0x09	; 9
    1696:	df 07       	cpc	r29, r31
    1698:	21 f4       	brne	.+8      	; 0x16a2 <usart_init_rs232+0xb0>
    169a:	61 e0       	ldi	r22, 0x01	; 1
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    169c:	84 e0       	ldi	r24, 0x04	; 4
    169e:	fd d8       	rcall	.-3590   	; 0x89a <sysclk_enable_module>
    16a0:	97 c0       	rjmp	.+302    	; 0x17d0 <usart_init_rs232+0x1de>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    16a2:	c1 15       	cp	r28, r1
    16a4:	8a e0       	ldi	r24, 0x0A	; 10
    16a6:	d8 07       	cpc	r29, r24
    16a8:	21 f4       	brne	.+8      	; 0x16b2 <usart_init_rs232+0xc0>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    16aa:	61 e0       	ldi	r22, 0x01	; 1
    16ac:	85 e0       	ldi	r24, 0x05	; 5
    16ae:	f5 d8       	rcall	.-3606   	; 0x89a <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    16b0:	8f c0       	rjmp	.+286    	; 0x17d0 <usart_init_rs232+0x1de>
    16b2:	c1 15       	cp	r28, r1
    16b4:	eb e0       	ldi	r30, 0x0B	; 11
    16b6:	de 07       	cpc	r29, r30
    16b8:	21 f4       	brne	.+8      	; 0x16c2 <usart_init_rs232+0xd0>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    16ba:	61 e0       	ldi	r22, 0x01	; 1
    16bc:	86 e0       	ldi	r24, 0x06	; 6
    16be:	ed d8       	rcall	.-3622   	; 0x89a <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    16c0:	87 c0       	rjmp	.+270    	; 0x17d0 <usart_init_rs232+0x1de>
    16c2:	c0 34       	cpi	r28, 0x40	; 64
    16c4:	f8 e0       	ldi	r31, 0x08	; 8
    16c6:	df 07       	cpc	r29, r31
    16c8:	21 f4       	brne	.+8      	; 0x16d2 <usart_init_rs232+0xe0>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    16ca:	62 e0       	ldi	r22, 0x02	; 2
    16cc:	83 e0       	ldi	r24, 0x03	; 3
    16ce:	e5 d8       	rcall	.-3638   	; 0x89a <sysclk_enable_module>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    16d0:	7f c0       	rjmp	.+254    	; 0x17d0 <usart_init_rs232+0x1de>
    16d2:	c0 34       	cpi	r28, 0x40	; 64
    16d4:	89 e0       	ldi	r24, 0x09	; 9
    16d6:	d8 07       	cpc	r29, r24
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    16d8:	21 f4       	brne	.+8      	; 0x16e2 <usart_init_rs232+0xf0>
    16da:	62 e0       	ldi	r22, 0x02	; 2
    16dc:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    16de:	dd d8       	rcall	.-3654   	; 0x89a <sysclk_enable_module>
    16e0:	77 c0       	rjmp	.+238    	; 0x17d0 <usart_init_rs232+0x1de>
    16e2:	c0 34       	cpi	r28, 0x40	; 64
    16e4:	ea e0       	ldi	r30, 0x0A	; 10
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    16e6:	de 07       	cpc	r29, r30
    16e8:	21 f4       	brne	.+8      	; 0x16f2 <usart_init_rs232+0x100>
    16ea:	62 e0       	ldi	r22, 0x02	; 2
    16ec:	85 e0       	ldi	r24, 0x05	; 5
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    16ee:	d5 d8       	rcall	.-3670   	; 0x89a <sysclk_enable_module>
    16f0:	6f c0       	rjmp	.+222    	; 0x17d0 <usart_init_rs232+0x1de>
    16f2:	c0 39       	cpi	r28, 0x90	; 144
    16f4:	f8 e0       	ldi	r31, 0x08	; 8
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    16f6:	df 07       	cpc	r29, r31
    16f8:	21 f4       	brne	.+8      	; 0x1702 <usart_init_rs232+0x110>
    16fa:	64 e0       	ldi	r22, 0x04	; 4
    16fc:	83 e0       	ldi	r24, 0x03	; 3
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    16fe:	cd d8       	rcall	.-3686   	; 0x89a <sysclk_enable_module>
    1700:	67 c0       	rjmp	.+206    	; 0x17d0 <usart_init_rs232+0x1de>
    1702:	c0 39       	cpi	r28, 0x90	; 144
    1704:	89 e0       	ldi	r24, 0x09	; 9
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    1706:	d8 07       	cpc	r29, r24
    1708:	21 f4       	brne	.+8      	; 0x1712 <usart_init_rs232+0x120>
    170a:	64 e0       	ldi	r22, 0x04	; 4
    170c:	84 e0       	ldi	r24, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    170e:	c5 d8       	rcall	.-3702   	; 0x89a <sysclk_enable_module>
    1710:	5f c0       	rjmp	.+190    	; 0x17d0 <usart_init_rs232+0x1de>
    1712:	c0 39       	cpi	r28, 0x90	; 144
    1714:	ea e0       	ldi	r30, 0x0A	; 10
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    1716:	de 07       	cpc	r29, r30
    1718:	21 f4       	brne	.+8      	; 0x1722 <usart_init_rs232+0x130>
    171a:	64 e0       	ldi	r22, 0x04	; 4
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    171c:	85 e0       	ldi	r24, 0x05	; 5
    171e:	bd d8       	rcall	.-3718   	; 0x89a <sysclk_enable_module>
    1720:	57 c0       	rjmp	.+174    	; 0x17d0 <usart_init_rs232+0x1de>
    1722:	c0 39       	cpi	r28, 0x90	; 144
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    1724:	fb e0       	ldi	r31, 0x0B	; 11
    1726:	df 07       	cpc	r29, r31
    1728:	21 f4       	brne	.+8      	; 0x1732 <usart_init_rs232+0x140>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    172a:	64 e0       	ldi	r22, 0x04	; 4
    172c:	86 e0       	ldi	r24, 0x06	; 6
    172e:	b5 d8       	rcall	.-3734   	; 0x89a <sysclk_enable_module>
    1730:	4f c0       	rjmp	.+158    	; 0x17d0 <usart_init_rs232+0x1de>
    1732:	c0 3c       	cpi	r28, 0xC0	; 192
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    1734:	88 e0       	ldi	r24, 0x08	; 8
    1736:	d8 07       	cpc	r29, r24
    1738:	21 f4       	brne	.+8      	; 0x1742 <usart_init_rs232+0x150>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    173a:	68 e0       	ldi	r22, 0x08	; 8
    173c:	83 e0       	ldi	r24, 0x03	; 3
    173e:	ad d8       	rcall	.-3750   	; 0x89a <sysclk_enable_module>
    1740:	47 c0       	rjmp	.+142    	; 0x17d0 <usart_init_rs232+0x1de>
    1742:	c0 3c       	cpi	r28, 0xC0	; 192
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1744:	e9 e0       	ldi	r30, 0x09	; 9
    1746:	de 07       	cpc	r29, r30
    1748:	21 f4       	brne	.+8      	; 0x1752 <usart_init_rs232+0x160>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    174a:	68 e0       	ldi	r22, 0x08	; 8
    174c:	84 e0       	ldi	r24, 0x04	; 4
    174e:	a5 d8       	rcall	.-3766   	; 0x89a <sysclk_enable_module>
    1750:	3f c0       	rjmp	.+126    	; 0x17d0 <usart_init_rs232+0x1de>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1752:	c0 3a       	cpi	r28, 0xA0	; 160
    1754:	f8 e0       	ldi	r31, 0x08	; 8
    1756:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1758:	21 f4       	brne	.+8      	; 0x1762 <usart_init_rs232+0x170>
    175a:	60 e1       	ldi	r22, 0x10	; 16
    175c:	83 e0       	ldi	r24, 0x03	; 3
    175e:	9d d8       	rcall	.-3782   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1760:	37 c0       	rjmp	.+110    	; 0x17d0 <usart_init_rs232+0x1de>
    1762:	c0 3a       	cpi	r28, 0xA0	; 160
    1764:	89 e0       	ldi	r24, 0x09	; 9
    1766:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1768:	21 f4       	brne	.+8      	; 0x1772 <usart_init_rs232+0x180>
    176a:	60 e1       	ldi	r22, 0x10	; 16
    176c:	84 e0       	ldi	r24, 0x04	; 4
    176e:	95 d8       	rcall	.-3798   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1770:	2f c0       	rjmp	.+94     	; 0x17d0 <usart_init_rs232+0x1de>
    1772:	c0 3a       	cpi	r28, 0xA0	; 160
    1774:	ea e0       	ldi	r30, 0x0A	; 10
    1776:	de 07       	cpc	r29, r30
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1778:	21 f4       	brne	.+8      	; 0x1782 <usart_init_rs232+0x190>
    177a:	60 e1       	ldi	r22, 0x10	; 16
    177c:	85 e0       	ldi	r24, 0x05	; 5
    177e:	8d d8       	rcall	.-3814   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1780:	27 c0       	rjmp	.+78     	; 0x17d0 <usart_init_rs232+0x1de>
    1782:	c0 3a       	cpi	r28, 0xA0	; 160
    1784:	fb e0       	ldi	r31, 0x0B	; 11
    1786:	df 07       	cpc	r29, r31
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1788:	21 f4       	brne	.+8      	; 0x1792 <usart_init_rs232+0x1a0>
    178a:	60 e1       	ldi	r22, 0x10	; 16
    178c:	86 e0       	ldi	r24, 0x06	; 6
    178e:	85 d8       	rcall	.-3830   	; 0x89a <sysclk_enable_module>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1790:	1f c0       	rjmp	.+62     	; 0x17d0 <usart_init_rs232+0x1de>
    1792:	c0 3b       	cpi	r28, 0xB0	; 176
    1794:	88 e0       	ldi	r24, 0x08	; 8
    1796:	d8 07       	cpc	r29, r24
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1798:	21 f4       	brne	.+8      	; 0x17a2 <usart_init_rs232+0x1b0>
    179a:	60 e2       	ldi	r22, 0x20	; 32
    179c:	83 e0       	ldi	r24, 0x03	; 3
    179e:	7d d8       	rcall	.-3846   	; 0x89a <sysclk_enable_module>
    17a0:	17 c0       	rjmp	.+46     	; 0x17d0 <usart_init_rs232+0x1de>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    17a2:	c0 3b       	cpi	r28, 0xB0	; 176
    17a4:	e9 e0       	ldi	r30, 0x09	; 9
    17a6:	de 07       	cpc	r29, r30
    17a8:	21 f4       	brne	.+8      	; 0x17b2 <usart_init_rs232+0x1c0>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    17aa:	60 e2       	ldi	r22, 0x20	; 32
    17ac:	84 e0       	ldi	r24, 0x04	; 4
    17ae:	75 d8       	rcall	.-3862   	; 0x89a <sysclk_enable_module>
    17b0:	0f c0       	rjmp	.+30     	; 0x17d0 <usart_init_rs232+0x1de>
    17b2:	c0 38       	cpi	r28, 0x80	; 128
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    17b4:	f4 e0       	ldi	r31, 0x04	; 4
    17b6:	df 07       	cpc	r29, r31
    17b8:	21 f4       	brne	.+8      	; 0x17c2 <usart_init_rs232+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    17ba:	60 e4       	ldi	r22, 0x40	; 64
    17bc:	83 e0       	ldi	r24, 0x03	; 3
    17be:	6d d8       	rcall	.-3878   	; 0x89a <sysclk_enable_module>
    17c0:	07 c0       	rjmp	.+14     	; 0x17d0 <usart_init_rs232+0x1de>
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    17c2:	c0 3a       	cpi	r28, 0xA0	; 160
    17c4:	84 e0       	ldi	r24, 0x04	; 4
    17c6:	d8 07       	cpc	r29, r24
 *  \param twoStopBits Enable two stop bit mode. Use bool type.
 */
static inline void usart_format_set(USART_t *usart, USART_CHSIZE_t charSize,
		USART_PMODE_t parityMode, bool twoStopBits)
{
	(usart)->CTRLC = (uint8_t)charSize | parityMode
    17c8:	19 f4       	brne	.+6      	; 0x17d0 <usart_init_rs232+0x1de>
    17ca:	60 e4       	ldi	r22, 0x40	; 64
    17cc:	85 e0       	ldi	r24, 0x05	; 5
    17ce:	65 d8       	rcall	.-3894   	; 0x89a <sysclk_enable_module>
    17d0:	8d 81       	ldd	r24, Y+5	; 0x05
    17d2:	8f 73       	andi	r24, 0x3F	; 63
    17d4:	8d 83       	std	Y+5, r24	; 0x05
    17d6:	f8 01       	movw	r30, r16
    17d8:	95 81       	ldd	r25, Z+5	; 0x05
	bool result;
	sysclk_enable_peripheral_clock(usart);
	usart_set_mode(usart, USART_CMODE_ASYNCHRONOUS_gc);
	usart_format_set(usart, opt->charlength, opt->paritytype,
			opt->stopbits);
	result = usart_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    17da:	84 81       	ldd	r24, Z+4	; 0x04
    17dc:	89 2b       	or	r24, r25
    17de:	96 81       	ldd	r25, Z+6	; 0x06
    17e0:	91 11       	cpse	r25, r1
    17e2:	98 e0       	ldi	r25, 0x08	; 8
    17e4:	89 2b       	or	r24, r25
    17e6:	8d 83       	std	Y+5, r24	; 0x05
    17e8:	f8 01       	movw	r30, r16
    17ea:	40 81       	ld	r20, Z
    17ec:	51 81       	ldd	r21, Z+1	; 0x01
    17ee:	62 81       	ldd	r22, Z+2	; 0x02
    17f0:	73 81       	ldd	r23, Z+3	; 0x03
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    17f2:	00 e8       	ldi	r16, 0x80	; 128
    17f4:	14 e8       	ldi	r17, 0x84	; 132
    17f6:	2e e1       	ldi	r18, 0x1E	; 30
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    17f8:	30 e0       	ldi	r19, 0x00	; 0
    17fa:	ce 01       	movw	r24, r28
    17fc:	e7 dd       	rcall	.-1074   	; 0x13cc <usart_set_baudrate>
	usart_tx_enable(usart);
	usart_rx_enable(usart);
	
	return result;
}
    17fe:	9c 81       	ldd	r25, Y+4	; 0x04
    1800:	98 60       	ori	r25, 0x08	; 8
    1802:	9c 83       	std	Y+4, r25	; 0x04
    1804:	9c 81       	ldd	r25, Y+4	; 0x04
    1806:	90 61       	ori	r25, 0x10	; 16
    1808:	9c 83       	std	Y+4, r25	; 0x04
    180a:	df 91       	pop	r29
    180c:	cf 91       	pop	r28
    180e:	1f 91       	pop	r17
    1810:	0f 91       	pop	r16
    1812:	08 95       	ret

00001814 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    1814:	cf 92       	push	r12
    1816:	df 92       	push	r13
    1818:	ef 92       	push	r14
    181a:	ff 92       	push	r15
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	cf 93       	push	r28
    1822:	df 93       	push	r29
    1824:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    1826:	d9 01       	movw	r26, r18
    1828:	c8 01       	movw	r24, r16
    182a:	b6 95       	lsr	r27
    182c:	a7 95       	ror	r26
    182e:	97 95       	ror	r25
    1830:	87 95       	ror	r24
    1832:	48 17       	cp	r20, r24
    1834:	59 07       	cpc	r21, r25
    1836:	6a 07       	cpc	r22, r26
    1838:	7b 07       	cpc	r23, r27
    183a:	78 f4       	brcc	.+30     	; 0x185a <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    183c:	6a 01       	movw	r12, r20
    183e:	7b 01       	movw	r14, r22
    1840:	cc 0c       	add	r12, r12
    1842:	dd 1c       	adc	r13, r13
    1844:	ee 1c       	adc	r14, r14
    1846:	ff 1c       	adc	r15, r15
    1848:	c9 01       	movw	r24, r18
    184a:	b8 01       	movw	r22, r16
    184c:	a7 01       	movw	r20, r14
    184e:	96 01       	movw	r18, r12
    1850:	0e 94 31 1b 	call	0x3662	; 0x3662 <__udivmodsi4>
    1854:	21 50       	subi	r18, 0x01	; 1
    1856:	31 09       	sbc	r19, r1
    1858:	02 c0       	rjmp	.+4      	; 0x185e <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    185a:	20 e0       	ldi	r18, 0x00	; 0
    185c:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    185e:	83 2f       	mov	r24, r19
    1860:	8f 70       	andi	r24, 0x0F	; 15
    1862:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1864:	2e 83       	std	Y+6, r18	; 0x06
}
    1866:	df 91       	pop	r29
    1868:	cf 91       	pop	r28
    186a:	1f 91       	pop	r17
    186c:	0f 91       	pop	r16
    186e:	ff 90       	pop	r15
    1870:	ef 90       	pop	r14
    1872:	df 90       	pop	r13
    1874:	cf 90       	pop	r12
    1876:	08 95       	ret

00001878 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1878:	ef 92       	push	r14
    187a:	ff 92       	push	r15
    187c:	0f 93       	push	r16
    187e:	1f 93       	push	r17
    1880:	cf 93       	push	r28
    1882:	df 93       	push	r29
    1884:	ec 01       	movw	r28, r24
    1886:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    1888:	00 97       	sbiw	r24, 0x00	; 0
    188a:	09 f4       	brne	.+2      	; 0x188e <usart_init_spi+0x16>
    188c:	97 c1       	rjmp	.+814    	; 0x1bbc <usart_init_spi+0x344>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    188e:	80 3c       	cpi	r24, 0xC0	; 192
    1890:	91 05       	cpc	r25, r1
    1892:	21 f4       	brne	.+8      	; 0x189c <usart_init_spi+0x24>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1894:	60 e1       	ldi	r22, 0x10	; 16
    1896:	80 e0       	ldi	r24, 0x00	; 0
    1898:	00 d8       	rcall	.-4096   	; 0x89a <sysclk_enable_module>
    189a:	90 c1       	rjmp	.+800    	; 0x1bbc <usart_init_spi+0x344>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    189c:	80 38       	cpi	r24, 0x80	; 128
    189e:	91 40       	sbci	r25, 0x01	; 1
    18a0:	29 f4       	brne	.+10     	; 0x18ac <usart_init_spi+0x34>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    18a2:	62 e0       	ldi	r22, 0x02	; 2
    18a4:	80 e0       	ldi	r24, 0x00	; 0
    18a6:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    18aa:	88 c1       	rjmp	.+784    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    18ac:	c1 15       	cp	r28, r1
    18ae:	81 e0       	ldi	r24, 0x01	; 1
    18b0:	d8 07       	cpc	r29, r24
    18b2:	29 f4       	brne	.+10     	; 0x18be <usart_init_spi+0x46>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    18b4:	61 e0       	ldi	r22, 0x01	; 1
    18b6:	80 e0       	ldi	r24, 0x00	; 0
    18b8:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    18bc:	7f c1       	rjmp	.+766    	; 0x1bbc <usart_init_spi+0x344>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    18be:	c0 38       	cpi	r28, 0x80	; 128
    18c0:	e3 e0       	ldi	r30, 0x03	; 3
    18c2:	de 07       	cpc	r29, r30
    18c4:	29 f4       	brne	.+10     	; 0x18d0 <usart_init_spi+0x58>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    18c6:	61 e0       	ldi	r22, 0x01	; 1
    18c8:	81 e0       	ldi	r24, 0x01	; 1
    18ca:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    18ce:	76 c1       	rjmp	.+748    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    18d0:	c0 39       	cpi	r28, 0x90	; 144
    18d2:	f3 e0       	ldi	r31, 0x03	; 3
    18d4:	df 07       	cpc	r29, r31
    18d6:	29 f4       	brne	.+10     	; 0x18e2 <usart_init_spi+0x6a>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    18d8:	61 e0       	ldi	r22, 0x01	; 1
    18da:	82 e0       	ldi	r24, 0x02	; 2
    18dc:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    18e0:	6d c1       	rjmp	.+730    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    18e2:	c1 15       	cp	r28, r1
    18e4:	32 e0       	ldi	r19, 0x02	; 2
    18e6:	d3 07       	cpc	r29, r19
    18e8:	29 f4       	brne	.+10     	; 0x18f4 <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    18ea:	62 e0       	ldi	r22, 0x02	; 2
    18ec:	81 e0       	ldi	r24, 0x01	; 1
    18ee:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    18f2:	64 c1       	rjmp	.+712    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    18f4:	c0 34       	cpi	r28, 0x40	; 64
    18f6:	82 e0       	ldi	r24, 0x02	; 2
    18f8:	d8 07       	cpc	r29, r24
    18fa:	29 f4       	brne	.+10     	; 0x1906 <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    18fc:	62 e0       	ldi	r22, 0x02	; 2
    18fe:	82 e0       	ldi	r24, 0x02	; 2
    1900:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1904:	5b c1       	rjmp	.+694    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    1906:	c0 32       	cpi	r28, 0x20	; 32
    1908:	e3 e0       	ldi	r30, 0x03	; 3
    190a:	de 07       	cpc	r29, r30
    190c:	29 f4       	brne	.+10     	; 0x1918 <usart_init_spi+0xa0>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    190e:	64 e0       	ldi	r22, 0x04	; 4
    1910:	82 e0       	ldi	r24, 0x02	; 2
    1912:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1916:	52 c1       	rjmp	.+676    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    1918:	c1 15       	cp	r28, r1
    191a:	f8 e0       	ldi	r31, 0x08	; 8
    191c:	df 07       	cpc	r29, r31
    191e:	29 f4       	brne	.+10     	; 0x192a <usart_init_spi+0xb2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    1920:	61 e0       	ldi	r22, 0x01	; 1
    1922:	83 e0       	ldi	r24, 0x03	; 3
    1924:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1928:	49 c1       	rjmp	.+658    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    192a:	c1 15       	cp	r28, r1
    192c:	39 e0       	ldi	r19, 0x09	; 9
    192e:	d3 07       	cpc	r29, r19
    1930:	29 f4       	brne	.+10     	; 0x193c <usart_init_spi+0xc4>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    1932:	61 e0       	ldi	r22, 0x01	; 1
    1934:	84 e0       	ldi	r24, 0x04	; 4
    1936:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    193a:	40 c1       	rjmp	.+640    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    193c:	c1 15       	cp	r28, r1
    193e:	8a e0       	ldi	r24, 0x0A	; 10
    1940:	d8 07       	cpc	r29, r24
    1942:	29 f4       	brne	.+10     	; 0x194e <usart_init_spi+0xd6>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    1944:	61 e0       	ldi	r22, 0x01	; 1
    1946:	85 e0       	ldi	r24, 0x05	; 5
    1948:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    194c:	37 c1       	rjmp	.+622    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    194e:	c1 15       	cp	r28, r1
    1950:	eb e0       	ldi	r30, 0x0B	; 11
    1952:	de 07       	cpc	r29, r30
    1954:	29 f4       	brne	.+10     	; 0x1960 <usart_init_spi+0xe8>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    1956:	61 e0       	ldi	r22, 0x01	; 1
    1958:	86 e0       	ldi	r24, 0x06	; 6
    195a:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    195e:	2e c1       	rjmp	.+604    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    1960:	c0 34       	cpi	r28, 0x40	; 64
    1962:	f8 e0       	ldi	r31, 0x08	; 8
    1964:	df 07       	cpc	r29, r31
    1966:	29 f4       	brne	.+10     	; 0x1972 <usart_init_spi+0xfa>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    1968:	62 e0       	ldi	r22, 0x02	; 2
    196a:	83 e0       	ldi	r24, 0x03	; 3
    196c:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1970:	25 c1       	rjmp	.+586    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    1972:	c0 34       	cpi	r28, 0x40	; 64
    1974:	39 e0       	ldi	r19, 0x09	; 9
    1976:	d3 07       	cpc	r29, r19
    1978:	29 f4       	brne	.+10     	; 0x1984 <usart_init_spi+0x10c>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    197a:	62 e0       	ldi	r22, 0x02	; 2
    197c:	84 e0       	ldi	r24, 0x04	; 4
    197e:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1982:	1c c1       	rjmp	.+568    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    1984:	c0 34       	cpi	r28, 0x40	; 64
    1986:	8a e0       	ldi	r24, 0x0A	; 10
    1988:	d8 07       	cpc	r29, r24
    198a:	29 f4       	brne	.+10     	; 0x1996 <usart_init_spi+0x11e>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    198c:	62 e0       	ldi	r22, 0x02	; 2
    198e:	85 e0       	ldi	r24, 0x05	; 5
    1990:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1994:	13 c1       	rjmp	.+550    	; 0x1bbc <usart_init_spi+0x344>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    1996:	c0 39       	cpi	r28, 0x90	; 144
    1998:	e8 e0       	ldi	r30, 0x08	; 8
    199a:	de 07       	cpc	r29, r30
    199c:	29 f4       	brne	.+10     	; 0x19a8 <usart_init_spi+0x130>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    199e:	64 e0       	ldi	r22, 0x04	; 4
    19a0:	83 e0       	ldi	r24, 0x03	; 3
    19a2:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19a6:	0a c1       	rjmp	.+532    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    19a8:	c0 39       	cpi	r28, 0x90	; 144
    19aa:	f9 e0       	ldi	r31, 0x09	; 9
    19ac:	df 07       	cpc	r29, r31
    19ae:	29 f4       	brne	.+10     	; 0x19ba <usart_init_spi+0x142>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    19b0:	64 e0       	ldi	r22, 0x04	; 4
    19b2:	84 e0       	ldi	r24, 0x04	; 4
    19b4:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19b8:	01 c1       	rjmp	.+514    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    19ba:	c0 39       	cpi	r28, 0x90	; 144
    19bc:	3a e0       	ldi	r19, 0x0A	; 10
    19be:	d3 07       	cpc	r29, r19
    19c0:	29 f4       	brne	.+10     	; 0x19cc <usart_init_spi+0x154>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    19c2:	64 e0       	ldi	r22, 0x04	; 4
    19c4:	85 e0       	ldi	r24, 0x05	; 5
    19c6:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19ca:	f8 c0       	rjmp	.+496    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    19cc:	c0 39       	cpi	r28, 0x90	; 144
    19ce:	8b e0       	ldi	r24, 0x0B	; 11
    19d0:	d8 07       	cpc	r29, r24
    19d2:	29 f4       	brne	.+10     	; 0x19de <usart_init_spi+0x166>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    19d4:	64 e0       	ldi	r22, 0x04	; 4
    19d6:	86 e0       	ldi	r24, 0x06	; 6
    19d8:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19dc:	ef c0       	rjmp	.+478    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    19de:	c0 3c       	cpi	r28, 0xC0	; 192
    19e0:	e8 e0       	ldi	r30, 0x08	; 8
    19e2:	de 07       	cpc	r29, r30
    19e4:	29 f4       	brne	.+10     	; 0x19f0 <usart_init_spi+0x178>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    19e6:	68 e0       	ldi	r22, 0x08	; 8
    19e8:	83 e0       	ldi	r24, 0x03	; 3
    19ea:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    19ee:	e6 c0       	rjmp	.+460    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    19f0:	c0 3c       	cpi	r28, 0xC0	; 192
    19f2:	f9 e0       	ldi	r31, 0x09	; 9
    19f4:	df 07       	cpc	r29, r31
    19f6:	29 f4       	brne	.+10     	; 0x1a02 <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    19f8:	68 e0       	ldi	r22, 0x08	; 8
    19fa:	84 e0       	ldi	r24, 0x04	; 4
    19fc:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a00:	dd c0       	rjmp	.+442    	; 0x1bbc <usart_init_spi+0x344>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    1a02:	c0 3a       	cpi	r28, 0xA0	; 160
    1a04:	38 e0       	ldi	r19, 0x08	; 8
    1a06:	d3 07       	cpc	r29, r19
    1a08:	69 f4       	brne	.+26     	; 0x1a24 <usart_init_spi+0x1ac>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1a0a:	60 e1       	ldi	r22, 0x10	; 16
    1a0c:	83 e0       	ldi	r24, 0x03	; 3
    1a0e:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1a12:	e0 ea       	ldi	r30, 0xA0	; 160
    1a14:	f8 e0       	ldi	r31, 0x08	; 8
    1a16:	84 81       	ldd	r24, Z+4	; 0x04
    1a18:	8f 7e       	andi	r24, 0xEF	; 239
    1a1a:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1a1c:	f7 01       	movw	r30, r14
    1a1e:	24 81       	ldd	r18, Z+4	; 0x04
    1a20:	22 50       	subi	r18, 0x02	; 2
    1a22:	4a c0       	rjmp	.+148    	; 0x1ab8 <usart_init_spi+0x240>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    1a24:	c0 3a       	cpi	r28, 0xA0	; 160
    1a26:	f9 e0       	ldi	r31, 0x09	; 9
    1a28:	df 07       	cpc	r29, r31
    1a2a:	29 f4       	brne	.+10     	; 0x1a36 <usart_init_spi+0x1be>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    1a2c:	60 e1       	ldi	r22, 0x10	; 16
    1a2e:	84 e0       	ldi	r24, 0x04	; 4
    1a30:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a34:	c3 c0       	rjmp	.+390    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    1a36:	c0 3a       	cpi	r28, 0xA0	; 160
    1a38:	3a e0       	ldi	r19, 0x0A	; 10
    1a3a:	d3 07       	cpc	r29, r19
    1a3c:	29 f4       	brne	.+10     	; 0x1a48 <usart_init_spi+0x1d0>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    1a3e:	60 e1       	ldi	r22, 0x10	; 16
    1a40:	85 e0       	ldi	r24, 0x05	; 5
    1a42:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a46:	ba c0       	rjmp	.+372    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    1a48:	c0 3a       	cpi	r28, 0xA0	; 160
    1a4a:	8b e0       	ldi	r24, 0x0B	; 11
    1a4c:	d8 07       	cpc	r29, r24
    1a4e:	29 f4       	brne	.+10     	; 0x1a5a <usart_init_spi+0x1e2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    1a50:	60 e1       	ldi	r22, 0x10	; 16
    1a52:	86 e0       	ldi	r24, 0x06	; 6
    1a54:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a58:	b1 c0       	rjmp	.+354    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    1a5a:	c0 3b       	cpi	r28, 0xB0	; 176
    1a5c:	e8 e0       	ldi	r30, 0x08	; 8
    1a5e:	de 07       	cpc	r29, r30
    1a60:	29 f4       	brne	.+10     	; 0x1a6c <usart_init_spi+0x1f4>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    1a62:	60 e2       	ldi	r22, 0x20	; 32
    1a64:	83 e0       	ldi	r24, 0x03	; 3
    1a66:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a6a:	a8 c0       	rjmp	.+336    	; 0x1bbc <usart_init_spi+0x344>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    1a6c:	c0 3b       	cpi	r28, 0xB0	; 176
    1a6e:	f9 e0       	ldi	r31, 0x09	; 9
    1a70:	df 07       	cpc	r29, r31
    1a72:	29 f4       	brne	.+10     	; 0x1a7e <usart_init_spi+0x206>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    1a74:	60 e2       	ldi	r22, 0x20	; 32
    1a76:	84 e0       	ldi	r24, 0x04	; 4
    1a78:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a7c:	9f c0       	rjmp	.+318    	; 0x1bbc <usart_init_spi+0x344>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    1a7e:	c0 38       	cpi	r28, 0x80	; 128
    1a80:	34 e0       	ldi	r19, 0x04	; 4
    1a82:	d3 07       	cpc	r29, r19
    1a84:	29 f4       	brne	.+10     	; 0x1a90 <usart_init_spi+0x218>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    1a86:	60 e4       	ldi	r22, 0x40	; 64
    1a88:	83 e0       	ldi	r24, 0x03	; 3
    1a8a:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1a8e:	96 c0       	rjmp	.+300    	; 0x1bbc <usart_init_spi+0x344>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    1a90:	c0 3a       	cpi	r28, 0xA0	; 160
    1a92:	84 e0       	ldi	r24, 0x04	; 4
    1a94:	d8 07       	cpc	r29, r24
    1a96:	29 f4       	brne	.+10     	; 0x1aa2 <usart_init_spi+0x22a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1a98:	60 e4       	ldi	r22, 0x40	; 64
    1a9a:	85 e0       	ldi	r24, 0x05	; 5
    1a9c:	0e 94 4d 04 	call	0x89a	; 0x89a <sysclk_enable_module>
    1aa0:	8d c0       	rjmp	.+282    	; 0x1bbc <usart_init_spi+0x344>
    1aa2:	8c 81       	ldd	r24, Y+4	; 0x04
    1aa4:	8f 7e       	andi	r24, 0xEF	; 239
    1aa6:	8c 83       	std	Y+4, r24	; 0x04
    1aa8:	fb 01       	movw	r30, r22
    1aaa:	24 81       	ldd	r18, Z+4	; 0x04
    1aac:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1aae:	ce 01       	movw	r24, r28
    1ab0:	c0 3a       	cpi	r28, 0xA0	; 160
    1ab2:	f8 e0       	ldi	r31, 0x08	; 8
    1ab4:	df 07       	cpc	r29, r31
    1ab6:	31 f4       	brne	.+12     	; 0x1ac4 <usart_init_spi+0x24c>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1ab8:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
    1abc:	84 fd       	sbrc	r24, 4
    1abe:	86 c0       	rjmp	.+268    	; 0x1bcc <usart_init_spi+0x354>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    1ac0:	11 e1       	ldi	r17, 0x11	; 17
    1ac2:	85 c0       	rjmp	.+266    	; 0x1bce <usart_init_spi+0x356>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1ac4:	80 3b       	cpi	r24, 0xB0	; 176
    1ac6:	38 e0       	ldi	r19, 0x08	; 8
    1ac8:	93 07       	cpc	r25, r19
    1aca:	79 f0       	breq	.+30     	; 0x1aea <usart_init_spi+0x272>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1acc:	80 3a       	cpi	r24, 0xA0	; 160
    1ace:	e9 e0       	ldi	r30, 0x09	; 9
    1ad0:	9e 07       	cpc	r25, r30
    1ad2:	31 f4       	brne	.+12     	; 0x1ae0 <usart_init_spi+0x268>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1ad4:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
    1ad8:	34 fd       	sbrc	r19, 4
    1ada:	7c c0       	rjmp	.+248    	; 0x1bd4 <usart_init_spi+0x35c>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1adc:	19 e1       	ldi	r17, 0x19	; 25
    1ade:	10 c0       	rjmp	.+32     	; 0x1b00 <usart_init_spi+0x288>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    1ae0:	80 3b       	cpi	r24, 0xB0	; 176
    1ae2:	f9 e0       	ldi	r31, 0x09	; 9
    1ae4:	9f 07       	cpc	r25, r31
    1ae6:	a9 f0       	breq	.+42     	; 0x1b12 <usart_init_spi+0x29a>
    1ae8:	01 c0       	rjmp	.+2      	; 0x1aec <usart_init_spi+0x274>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1aea:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1aec:	80 3a       	cpi	r24, 0xA0	; 160
    1aee:	3a e0       	ldi	r19, 0x0A	; 10
    1af0:	93 07       	cpc	r25, r19
    1af2:	31 f4       	brne	.+12     	; 0x1b00 <usart_init_spi+0x288>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1af4:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
    1af8:	84 fd       	sbrc	r24, 4
    1afa:	6e c0       	rjmp	.+220    	; 0x1bd8 <usart_init_spi+0x360>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1afc:	11 e2       	ldi	r17, 0x21	; 33
    1afe:	0c c0       	rjmp	.+24     	; 0x1b18 <usart_init_spi+0x2a0>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    1b00:	80 3a       	cpi	r24, 0xA0	; 160
    1b02:	9b 40       	sbci	r25, 0x0B	; 11
    1b04:	49 f4       	brne	.+18     	; 0x1b18 <usart_init_spi+0x2a0>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1b06:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
    1b0a:	84 fd       	sbrc	r24, 4
    1b0c:	04 c0       	rjmp	.+8      	; 0x1b16 <usart_init_spi+0x29e>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    1b0e:	19 e2       	ldi	r17, 0x29	; 41
    1b10:	03 c0       	rjmp	.+6      	; 0x1b18 <usart_init_spi+0x2a0>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1b12:	1d e1       	ldi	r17, 0x1D	; 29
    1b14:	01 c0       	rjmp	.+2      	; 0x1b18 <usart_init_spi+0x2a0>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1b16:	1d e2       	ldi	r17, 0x2D	; 45
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1b18:	e1 2f       	mov	r30, r17
    1b1a:	e6 95       	lsr	r30
    1b1c:	e6 95       	lsr	r30
    1b1e:	e6 95       	lsr	r30
    1b20:	30 e2       	ldi	r19, 0x20	; 32
    1b22:	e3 9f       	mul	r30, r19
    1b24:	f0 01       	movw	r30, r0
    1b26:	11 24       	eor	r1, r1
    1b28:	fa 5f       	subi	r31, 0xFA	; 250
    1b2a:	17 70       	andi	r17, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1b2c:	81 e0       	ldi	r24, 0x01	; 1
    1b2e:	90 e0       	ldi	r25, 0x00	; 0
    1b30:	01 2e       	mov	r0, r17
    1b32:	02 c0       	rjmp	.+4      	; 0x1b38 <usart_init_spi+0x2c0>
    1b34:	88 0f       	add	r24, r24
    1b36:	99 1f       	adc	r25, r25
    1b38:	0a 94       	dec	r0
    1b3a:	e2 f7       	brpl	.-8      	; 0x1b34 <usart_init_spi+0x2bc>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    1b3c:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    1b3e:	22 30       	cpi	r18, 0x02	; 2
    1b40:	10 f0       	brcs	.+4      	; 0x1b46 <usart_init_spi+0x2ce>
    1b42:	40 e0       	ldi	r20, 0x00	; 0
    1b44:	01 c0       	rjmp	.+2      	; 0x1b48 <usart_init_spi+0x2d0>
    1b46:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    1b48:	df 01       	movw	r26, r30
    1b4a:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    1b4c:	a1 0f       	add	r26, r17
    1b4e:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1b50:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    1b52:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    1b54:	2c 91       	ld	r18, X
    1b56:	27 70       	andi	r18, 0x07	; 7
    1b58:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    1b5a:	9c 91       	ld	r25, X
    1b5c:	94 2b       	or	r25, r20
    1b5e:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1b60:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    1b62:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    1b64:	8d 81       	ldd	r24, Y+5	; 0x05
    1b66:	80 6c       	ori	r24, 0xC0	; 192
    1b68:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    1b6a:	f7 01       	movw	r30, r14
    1b6c:	84 81       	ldd	r24, Z+4	; 0x04
    1b6e:	8d 7f       	andi	r24, 0xFD	; 253
    1b70:	81 30       	cpi	r24, 0x01	; 1
    1b72:	21 f4       	brne	.+8      	; 0x1b7c <usart_init_spi+0x304>
		usart->CTRLC |= USART_UCPHA_bm;
    1b74:	8d 81       	ldd	r24, Y+5	; 0x05
    1b76:	82 60       	ori	r24, 0x02	; 2
    1b78:	8d 83       	std	Y+5, r24	; 0x05
    1b7a:	03 c0       	rjmp	.+6      	; 0x1b82 <usart_init_spi+0x30a>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    1b7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1b7e:	8d 7f       	andi	r24, 0xFD	; 253
    1b80:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    1b82:	f7 01       	movw	r30, r14
    1b84:	85 81       	ldd	r24, Z+5	; 0x05
    1b86:	88 23       	and	r24, r24
    1b88:	21 f0       	breq	.+8      	; 0x1b92 <usart_init_spi+0x31a>
		(usart)->CTRLC |= USART_DORD_bm;
    1b8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1b8c:	84 60       	ori	r24, 0x04	; 4
    1b8e:	8d 83       	std	Y+5, r24	; 0x05
    1b90:	03 c0       	rjmp	.+6      	; 0x1b98 <usart_init_spi+0x320>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    1b92:	8d 81       	ldd	r24, Y+5	; 0x05
    1b94:	8b 7f       	andi	r24, 0xFB	; 251
    1b96:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1b98:	f7 01       	movw	r30, r14
    1b9a:	40 81       	ld	r20, Z
    1b9c:	51 81       	ldd	r21, Z+1	; 0x01
    1b9e:	62 81       	ldd	r22, Z+2	; 0x02
    1ba0:	73 81       	ldd	r23, Z+3	; 0x03
    1ba2:	00 e8       	ldi	r16, 0x80	; 128
    1ba4:	14 e8       	ldi	r17, 0x84	; 132
    1ba6:	2e e1       	ldi	r18, 0x1E	; 30
    1ba8:	30 e0       	ldi	r19, 0x00	; 0
    1baa:	ce 01       	movw	r24, r28
    1bac:	33 de       	rcall	.-922    	; 0x1814 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    1bae:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb0:	88 60       	ori	r24, 0x08	; 8
    1bb2:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1bb4:	8c 81       	ldd	r24, Y+4	; 0x04
    1bb6:	80 61       	ori	r24, 0x10	; 16
    1bb8:	8c 83       	std	Y+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1bba:	10 c0       	rjmp	.+32     	; 0x1bdc <usart_init_spi+0x364>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1bbc:	8c 81       	ldd	r24, Y+4	; 0x04
    1bbe:	8f 7e       	andi	r24, 0xEF	; 239
    1bc0:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1bc2:	f7 01       	movw	r30, r14
    1bc4:	24 81       	ldd	r18, Z+4	; 0x04
    1bc6:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1bc8:	ce 01       	movw	r24, r28
    1bca:	7c cf       	rjmp	.-264    	; 0x1ac4 <usart_init_spi+0x24c>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1bcc:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    1bce:	80 ea       	ldi	r24, 0xA0	; 160
    1bd0:	98 e0       	ldi	r25, 0x08	; 8
    1bd2:	86 cf       	rjmp	.-244    	; 0x1ae0 <usart_init_spi+0x268>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1bd4:	1d e1       	ldi	r17, 0x1D	; 29
    1bd6:	94 cf       	rjmp	.-216    	; 0x1b00 <usart_init_spi+0x288>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1bd8:	15 e2       	ldi	r17, 0x25	; 37
    1bda:	9e cf       	rjmp	.-196    	; 0x1b18 <usart_init_spi+0x2a0>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1bdc:	df 91       	pop	r29
    1bde:	cf 91       	pop	r28
    1be0:	1f 91       	pop	r17
    1be2:	0f 91       	pop	r16
    1be4:	ff 90       	pop	r15
    1be6:	ef 90       	pop	r14
    1be8:	08 95       	ret

00001bea <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1bea:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bec:	03 96       	adiw	r24, 0x03	; 3
    1bee:	81 83       	std	Z+1, r24	; 0x01
    1bf0:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1bf2:	2f ef       	ldi	r18, 0xFF	; 255
    1bf4:	3f ef       	ldi	r19, 0xFF	; 255
    1bf6:	23 83       	std	Z+3, r18	; 0x03
    1bf8:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bfa:	85 83       	std	Z+5, r24	; 0x05
    1bfc:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1bfe:	87 83       	std	Z+7, r24	; 0x07
    1c00:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1c02:	10 82       	st	Z, r1
    1c04:	08 95       	ret

00001c06 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1c06:	fc 01       	movw	r30, r24
    1c08:	10 86       	std	Z+8, r1	; 0x08
    1c0a:	11 86       	std	Z+9, r1	; 0x09
    1c0c:	08 95       	ret

00001c0e <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c0e:	cf 93       	push	r28
    1c10:	df 93       	push	r29
    1c12:	9c 01       	movw	r18, r24
    1c14:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1c16:	dc 01       	movw	r26, r24
    1c18:	11 96       	adiw	r26, 0x01	; 1
    1c1a:	cd 91       	ld	r28, X+
    1c1c:	dc 91       	ld	r29, X
    1c1e:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1c20:	c2 83       	std	Z+2, r28	; 0x02
    1c22:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1c24:	8c 81       	ldd	r24, Y+4	; 0x04
    1c26:	9d 81       	ldd	r25, Y+5	; 0x05
    1c28:	84 83       	std	Z+4, r24	; 0x04
    1c2a:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1c2c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c2e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c30:	dc 01       	movw	r26, r24
    1c32:	12 96       	adiw	r26, 0x02	; 2
    1c34:	6d 93       	st	X+, r22
    1c36:	7c 93       	st	X, r23
    1c38:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    1c3a:	6c 83       	std	Y+4, r22	; 0x04
    1c3c:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1c3e:	20 87       	std	Z+8, r18	; 0x08
    1c40:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    1c42:	f9 01       	movw	r30, r18
    1c44:	80 81       	ld	r24, Z
    1c46:	8f 5f       	subi	r24, 0xFF	; 255
    1c48:	80 83       	st	Z, r24
}
    1c4a:	df 91       	pop	r29
    1c4c:	cf 91       	pop	r28
    1c4e:	08 95       	ret

00001c50 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1c50:	cf 93       	push	r28
    1c52:	df 93       	push	r29
    1c54:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    1c56:	48 81       	ld	r20, Y
    1c58:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1c5a:	4f 3f       	cpi	r20, 0xFF	; 255
    1c5c:	2f ef       	ldi	r18, 0xFF	; 255
    1c5e:	52 07       	cpc	r21, r18
    1c60:	21 f4       	brne	.+8      	; 0x1c6a <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1c62:	fc 01       	movw	r30, r24
    1c64:	a7 81       	ldd	r26, Z+7	; 0x07
    1c66:	b0 85       	ldd	r27, Z+8	; 0x08
    1c68:	0d c0       	rjmp	.+26     	; 0x1c84 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1c6a:	dc 01       	movw	r26, r24
    1c6c:	13 96       	adiw	r26, 0x03	; 3
    1c6e:	01 c0       	rjmp	.+2      	; 0x1c72 <vListInsert+0x22>
    1c70:	df 01       	movw	r26, r30
    1c72:	12 96       	adiw	r26, 0x02	; 2
    1c74:	ed 91       	ld	r30, X+
    1c76:	fc 91       	ld	r31, X
    1c78:	13 97       	sbiw	r26, 0x03	; 3
    1c7a:	20 81       	ld	r18, Z
    1c7c:	31 81       	ldd	r19, Z+1	; 0x01
    1c7e:	42 17       	cp	r20, r18
    1c80:	53 07       	cpc	r21, r19
    1c82:	b0 f7       	brcc	.-20     	; 0x1c70 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1c84:	12 96       	adiw	r26, 0x02	; 2
    1c86:	ed 91       	ld	r30, X+
    1c88:	fc 91       	ld	r31, X
    1c8a:	13 97       	sbiw	r26, 0x03	; 3
    1c8c:	ea 83       	std	Y+2, r30	; 0x02
    1c8e:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1c90:	c4 83       	std	Z+4, r28	; 0x04
    1c92:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1c94:	ac 83       	std	Y+4, r26	; 0x04
    1c96:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1c98:	12 96       	adiw	r26, 0x02	; 2
    1c9a:	cd 93       	st	X+, r28
    1c9c:	dc 93       	st	X, r29
    1c9e:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1ca0:	88 87       	std	Y+8, r24	; 0x08
    1ca2:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1ca4:	fc 01       	movw	r30, r24
    1ca6:	20 81       	ld	r18, Z
    1ca8:	2f 5f       	subi	r18, 0xFF	; 255
    1caa:	20 83       	st	Z, r18
}
    1cac:	df 91       	pop	r29
    1cae:	cf 91       	pop	r28
    1cb0:	08 95       	ret

00001cb2 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1cb2:	cf 93       	push	r28
    1cb4:	df 93       	push	r29
    1cb6:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1cb8:	a0 85       	ldd	r26, Z+8	; 0x08
    1cba:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1cbc:	c2 81       	ldd	r28, Z+2	; 0x02
    1cbe:	d3 81       	ldd	r29, Z+3	; 0x03
    1cc0:	84 81       	ldd	r24, Z+4	; 0x04
    1cc2:	95 81       	ldd	r25, Z+5	; 0x05
    1cc4:	8c 83       	std	Y+4, r24	; 0x04
    1cc6:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1cc8:	c4 81       	ldd	r28, Z+4	; 0x04
    1cca:	d5 81       	ldd	r29, Z+5	; 0x05
    1ccc:	82 81       	ldd	r24, Z+2	; 0x02
    1cce:	93 81       	ldd	r25, Z+3	; 0x03
    1cd0:	8a 83       	std	Y+2, r24	; 0x02
    1cd2:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1cd4:	11 96       	adiw	r26, 0x01	; 1
    1cd6:	8d 91       	ld	r24, X+
    1cd8:	9c 91       	ld	r25, X
    1cda:	12 97       	sbiw	r26, 0x02	; 2
    1cdc:	e8 17       	cp	r30, r24
    1cde:	f9 07       	cpc	r31, r25
    1ce0:	31 f4       	brne	.+12     	; 0x1cee <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1ce2:	84 81       	ldd	r24, Z+4	; 0x04
    1ce4:	95 81       	ldd	r25, Z+5	; 0x05
    1ce6:	11 96       	adiw	r26, 0x01	; 1
    1ce8:	8d 93       	st	X+, r24
    1cea:	9c 93       	st	X, r25
    1cec:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1cee:	10 86       	std	Z+8, r1	; 0x08
    1cf0:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1cf2:	8c 91       	ld	r24, X
    1cf4:	81 50       	subi	r24, 0x01	; 1
    1cf6:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1cf8:	df 91       	pop	r29
    1cfa:	cf 91       	pop	r28
    1cfc:	08 95       	ret

00001cfe <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    1cfe:	0f 93       	push	r16
    1d00:	1f 93       	push	r17
    1d02:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1d04:	71 e1       	ldi	r23, 0x11	; 17
    1d06:	fc 01       	movw	r30, r24
    1d08:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1d0a:	31 97       	sbiw	r30, 0x01	; 1
    1d0c:	62 e2       	ldi	r22, 0x22	; 34
    1d0e:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    1d10:	31 97       	sbiw	r30, 0x01	; 1
    1d12:	23 e3       	ldi	r18, 0x33	; 51
    1d14:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1d16:	01 2e       	mov	r0, r17
    1d18:	00 0c       	add	r0, r0
    1d1a:	22 0b       	sbc	r18, r18
    1d1c:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d1e:	31 97       	sbiw	r30, 0x01	; 1
    1d20:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d22:	31 97       	sbiw	r30, 0x01	; 1
    1d24:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1d26:	31 97       	sbiw	r30, 0x01	; 1
    1d28:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1d2a:	31 97       	sbiw	r30, 0x01	; 1
    1d2c:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    1d2e:	31 97       	sbiw	r30, 0x01	; 1
    1d30:	20 e8       	ldi	r18, 0x80	; 128
    1d32:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    1d34:	31 97       	sbiw	r30, 0x01	; 1
    1d36:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    1d38:	31 97       	sbiw	r30, 0x01	; 1
    1d3a:	22 e0       	ldi	r18, 0x02	; 2
    1d3c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    1d3e:	31 97       	sbiw	r30, 0x01	; 1
    1d40:	23 e0       	ldi	r18, 0x03	; 3
    1d42:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    1d44:	31 97       	sbiw	r30, 0x01	; 1
    1d46:	24 e0       	ldi	r18, 0x04	; 4
    1d48:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    1d4a:	31 97       	sbiw	r30, 0x01	; 1
    1d4c:	25 e0       	ldi	r18, 0x05	; 5
    1d4e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    1d50:	31 97       	sbiw	r30, 0x01	; 1
    1d52:	26 e0       	ldi	r18, 0x06	; 6
    1d54:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    1d56:	31 97       	sbiw	r30, 0x01	; 1
    1d58:	27 e0       	ldi	r18, 0x07	; 7
    1d5a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    1d5c:	31 97       	sbiw	r30, 0x01	; 1
    1d5e:	28 e0       	ldi	r18, 0x08	; 8
    1d60:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    1d62:	31 97       	sbiw	r30, 0x01	; 1
    1d64:	29 e0       	ldi	r18, 0x09	; 9
    1d66:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    1d68:	31 97       	sbiw	r30, 0x01	; 1
    1d6a:	20 e1       	ldi	r18, 0x10	; 16
    1d6c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    1d6e:	31 97       	sbiw	r30, 0x01	; 1
    1d70:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1d72:	31 97       	sbiw	r30, 0x01	; 1
    1d74:	22 e1       	ldi	r18, 0x12	; 18
    1d76:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1d78:	31 97       	sbiw	r30, 0x01	; 1
    1d7a:	23 e1       	ldi	r18, 0x13	; 19
    1d7c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    1d7e:	31 97       	sbiw	r30, 0x01	; 1
    1d80:	24 e1       	ldi	r18, 0x14	; 20
    1d82:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1d84:	31 97       	sbiw	r30, 0x01	; 1
    1d86:	25 e1       	ldi	r18, 0x15	; 21
    1d88:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    1d8a:	31 97       	sbiw	r30, 0x01	; 1
    1d8c:	26 e1       	ldi	r18, 0x16	; 22
    1d8e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1d90:	31 97       	sbiw	r30, 0x01	; 1
    1d92:	27 e1       	ldi	r18, 0x17	; 23
    1d94:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1d96:	31 97       	sbiw	r30, 0x01	; 1
    1d98:	28 e1       	ldi	r18, 0x18	; 24
    1d9a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1d9c:	31 97       	sbiw	r30, 0x01	; 1
    1d9e:	29 e1       	ldi	r18, 0x19	; 25
    1da0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1da2:	31 97       	sbiw	r30, 0x01	; 1
    1da4:	20 e2       	ldi	r18, 0x20	; 32
    1da6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1da8:	31 97       	sbiw	r30, 0x01	; 1
    1daa:	21 e2       	ldi	r18, 0x21	; 33
    1dac:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    1dae:	31 97       	sbiw	r30, 0x01	; 1
    1db0:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	23 e2       	ldi	r18, 0x23	; 35
    1db6:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1db8:	31 97       	sbiw	r30, 0x01	; 1
    1dba:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1dbc:	31 97       	sbiw	r30, 0x01	; 1
    1dbe:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1dc0:	31 97       	sbiw	r30, 0x01	; 1
    1dc2:	26 e2       	ldi	r18, 0x26	; 38
    1dc4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1dc6:	31 97       	sbiw	r30, 0x01	; 1
    1dc8:	27 e2       	ldi	r18, 0x27	; 39
    1dca:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1dcc:	31 97       	sbiw	r30, 0x01	; 1
    1dce:	28 e2       	ldi	r18, 0x28	; 40
    1dd0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1dd2:	31 97       	sbiw	r30, 0x01	; 1
    1dd4:	29 e2       	ldi	r18, 0x29	; 41
    1dd6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1dd8:	31 97       	sbiw	r30, 0x01	; 1
    1dda:	20 e3       	ldi	r18, 0x30	; 48
    1ddc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    1dde:	31 97       	sbiw	r30, 0x01	; 1
    1de0:	21 e3       	ldi	r18, 0x31	; 49
    1de2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1de4:	87 97       	sbiw	r24, 0x27	; 39
    1de6:	1f 91       	pop	r17
    1de8:	0f 91       	pop	r16
    1dea:	08 95       	ret

00001dec <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1dec:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    1dee:	e0 e7       	ldi	r30, 0x70	; 112
    1df0:	f0 e0       	ldi	r31, 0x00	; 0
    1df2:	83 81       	ldd	r24, Z+3	; 0x03
    1df4:	8a 7f       	andi	r24, 0xFA	; 250
    1df6:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1df8:	e0 e0       	ldi	r30, 0x00	; 0
    1dfa:	f8 e0       	ldi	r31, 0x08	; 8
    1dfc:	80 e0       	ldi	r24, 0x00	; 0
    1dfe:	9a ef       	ldi	r25, 0xFA	; 250
    1e00:	86 a3       	std	Z+38, r24	; 0x26
    1e02:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1e04:	91 e0       	ldi	r25, 0x01	; 1
    1e06:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1e08:	a0 ea       	ldi	r26, 0xA0	; 160
    1e0a:	b0 e0       	ldi	r27, 0x00	; 0
    1e0c:	12 96       	adiw	r26, 0x02	; 2
    1e0e:	8c 91       	ld	r24, X
    1e10:	12 97       	sbiw	r26, 0x02	; 2
    1e12:	81 60       	ori	r24, 0x01	; 1
    1e14:	12 96       	adiw	r26, 0x02	; 2
    1e16:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1e18:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1e1a:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1e1c:	a0 91 9c 22 	lds	r26, 0x229C	; 0x80229c <pxCurrentTCB>
    1e20:	b0 91 9d 22 	lds	r27, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    1e24:	0d 90       	ld	r0, X+
    1e26:	0d be       	out	0x3d, r0	; 61
    1e28:	0d 90       	ld	r0, X+
    1e2a:	0e be       	out	0x3e, r0	; 62
    1e2c:	ff 91       	pop	r31
    1e2e:	ef 91       	pop	r30
    1e30:	df 91       	pop	r29
    1e32:	cf 91       	pop	r28
    1e34:	bf 91       	pop	r27
    1e36:	af 91       	pop	r26
    1e38:	9f 91       	pop	r25
    1e3a:	8f 91       	pop	r24
    1e3c:	7f 91       	pop	r23
    1e3e:	6f 91       	pop	r22
    1e40:	5f 91       	pop	r21
    1e42:	4f 91       	pop	r20
    1e44:	3f 91       	pop	r19
    1e46:	2f 91       	pop	r18
    1e48:	1f 91       	pop	r17
    1e4a:	0f 91       	pop	r16
    1e4c:	ff 90       	pop	r15
    1e4e:	ef 90       	pop	r14
    1e50:	df 90       	pop	r13
    1e52:	cf 90       	pop	r12
    1e54:	bf 90       	pop	r11
    1e56:	af 90       	pop	r10
    1e58:	9f 90       	pop	r9
    1e5a:	8f 90       	pop	r8
    1e5c:	7f 90       	pop	r7
    1e5e:	6f 90       	pop	r6
    1e60:	5f 90       	pop	r5
    1e62:	4f 90       	pop	r4
    1e64:	3f 90       	pop	r3
    1e66:	2f 90       	pop	r2
    1e68:	1f 90       	pop	r1
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1e70:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1e72:	81 e0       	ldi	r24, 0x01	; 1
    1e74:	08 95       	ret

00001e76 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1e76:	0f 92       	push	r0
    1e78:	0f b6       	in	r0, 0x3f	; 63
    1e7a:	f8 94       	cli
    1e7c:	0f 92       	push	r0
    1e7e:	1f 92       	push	r1
    1e80:	11 24       	eor	r1, r1
    1e82:	2f 92       	push	r2
    1e84:	3f 92       	push	r3
    1e86:	4f 92       	push	r4
    1e88:	5f 92       	push	r5
    1e8a:	6f 92       	push	r6
    1e8c:	7f 92       	push	r7
    1e8e:	8f 92       	push	r8
    1e90:	9f 92       	push	r9
    1e92:	af 92       	push	r10
    1e94:	bf 92       	push	r11
    1e96:	cf 92       	push	r12
    1e98:	df 92       	push	r13
    1e9a:	ef 92       	push	r14
    1e9c:	ff 92       	push	r15
    1e9e:	0f 93       	push	r16
    1ea0:	1f 93       	push	r17
    1ea2:	2f 93       	push	r18
    1ea4:	3f 93       	push	r19
    1ea6:	4f 93       	push	r20
    1ea8:	5f 93       	push	r21
    1eaa:	6f 93       	push	r22
    1eac:	7f 93       	push	r23
    1eae:	8f 93       	push	r24
    1eb0:	9f 93       	push	r25
    1eb2:	af 93       	push	r26
    1eb4:	bf 93       	push	r27
    1eb6:	cf 93       	push	r28
    1eb8:	df 93       	push	r29
    1eba:	ef 93       	push	r30
    1ebc:	ff 93       	push	r31
    1ebe:	a0 91 9c 22 	lds	r26, 0x229C	; 0x80229c <pxCurrentTCB>
    1ec2:	b0 91 9d 22 	lds	r27, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    1ec6:	0d b6       	in	r0, 0x3d	; 61
    1ec8:	0d 92       	st	X+, r0
    1eca:	0e b6       	in	r0, 0x3e	; 62
    vTaskSwitchContext();
    1ecc:	0d 92       	st	X+, r0
    portRESTORE_CONTEXT();
    1ece:	0e d6       	rcall	.+3100   	; 0x2aec <vTaskSwitchContext>
    1ed0:	a0 91 9c 22 	lds	r26, 0x229C	; 0x80229c <pxCurrentTCB>
    1ed4:	b0 91 9d 22 	lds	r27, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    1ed8:	0d 90       	ld	r0, X+
    1eda:	0d be       	out	0x3d, r0	; 61
    1edc:	0d 90       	ld	r0, X+
    1ede:	0e be       	out	0x3e, r0	; 62
    1ee0:	ff 91       	pop	r31
    1ee2:	ef 91       	pop	r30
    1ee4:	df 91       	pop	r29
    1ee6:	cf 91       	pop	r28
    1ee8:	bf 91       	pop	r27
    1eea:	af 91       	pop	r26
    1eec:	9f 91       	pop	r25
    1eee:	8f 91       	pop	r24
    1ef0:	7f 91       	pop	r23
    1ef2:	6f 91       	pop	r22
    1ef4:	5f 91       	pop	r21
    1ef6:	4f 91       	pop	r20
    1ef8:	3f 91       	pop	r19
    1efa:	2f 91       	pop	r18
    1efc:	1f 91       	pop	r17
    1efe:	0f 91       	pop	r16
    1f00:	ff 90       	pop	r15
    1f02:	ef 90       	pop	r14
    1f04:	df 90       	pop	r13
    1f06:	cf 90       	pop	r12
    1f08:	bf 90       	pop	r11
    1f0a:	af 90       	pop	r10
    1f0c:	9f 90       	pop	r9
    1f0e:	8f 90       	pop	r8
    1f10:	7f 90       	pop	r7
    1f12:	6f 90       	pop	r6
    1f14:	5f 90       	pop	r5
    1f16:	4f 90       	pop	r4
    1f18:	3f 90       	pop	r3
    1f1a:	2f 90       	pop	r2
    1f1c:	1f 90       	pop	r1
    1f1e:	0f 90       	pop	r0
    1f20:	0f be       	out	0x3f, r0	; 63

    asm volatile ( "ret" );
    1f22:	0f 90       	pop	r0
    1f24:	08 95       	ret

00001f26 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1f26:	0f 92       	push	r0
    1f28:	0f b6       	in	r0, 0x3f	; 63
    1f2a:	f8 94       	cli
    1f2c:	0f 92       	push	r0
    1f2e:	1f 92       	push	r1
    1f30:	11 24       	eor	r1, r1
    1f32:	2f 92       	push	r2
    1f34:	3f 92       	push	r3
    1f36:	4f 92       	push	r4
    1f38:	5f 92       	push	r5
    1f3a:	6f 92       	push	r6
    1f3c:	7f 92       	push	r7
    1f3e:	8f 92       	push	r8
    1f40:	9f 92       	push	r9
    1f42:	af 92       	push	r10
    1f44:	bf 92       	push	r11
    1f46:	cf 92       	push	r12
    1f48:	df 92       	push	r13
    1f4a:	ef 92       	push	r14
    1f4c:	ff 92       	push	r15
    1f4e:	0f 93       	push	r16
    1f50:	1f 93       	push	r17
    1f52:	2f 93       	push	r18
    1f54:	3f 93       	push	r19
    1f56:	4f 93       	push	r20
    1f58:	5f 93       	push	r21
    1f5a:	6f 93       	push	r22
    1f5c:	7f 93       	push	r23
    1f5e:	8f 93       	push	r24
    1f60:	9f 93       	push	r25
    1f62:	af 93       	push	r26
    1f64:	bf 93       	push	r27
    1f66:	cf 93       	push	r28
    1f68:	df 93       	push	r29
    1f6a:	ef 93       	push	r30
    1f6c:	ff 93       	push	r31
    1f6e:	a0 91 9c 22 	lds	r26, 0x229C	; 0x80229c <pxCurrentTCB>
    1f72:	b0 91 9d 22 	lds	r27, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    1f76:	0d b6       	in	r0, 0x3d	; 61
    1f78:	0d 92       	st	X+, r0
    1f7a:	0e b6       	in	r0, 0x3e	; 62
        if( xTaskIncrementTick() != pdFALSE )
    1f7c:	0d 92       	st	X+, r0
        {
            vTaskSwitchContext();
    1f7e:	4b d4       	rcall	.+2198   	; 0x2816 <xTaskIncrementTick>
    1f80:	81 11       	cpse	r24, r1
        }
        portRESTORE_CONTEXT();
    1f82:	b4 d5       	rcall	.+2920   	; 0x2aec <vTaskSwitchContext>
    1f84:	a0 91 9c 22 	lds	r26, 0x229C	; 0x80229c <pxCurrentTCB>
    1f88:	b0 91 9d 22 	lds	r27, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    1f8c:	0d 90       	ld	r0, X+
    1f8e:	0d be       	out	0x3d, r0	; 61
    1f90:	0d 90       	ld	r0, X+
    1f92:	0e be       	out	0x3e, r0	; 62
    1f94:	ff 91       	pop	r31
    1f96:	ef 91       	pop	r30
    1f98:	df 91       	pop	r29
    1f9a:	cf 91       	pop	r28
    1f9c:	bf 91       	pop	r27
    1f9e:	af 91       	pop	r26
    1fa0:	9f 91       	pop	r25
    1fa2:	8f 91       	pop	r24
    1fa4:	7f 91       	pop	r23
    1fa6:	6f 91       	pop	r22
    1fa8:	5f 91       	pop	r21
    1faa:	4f 91       	pop	r20
    1fac:	3f 91       	pop	r19
    1fae:	2f 91       	pop	r18
    1fb0:	1f 91       	pop	r17
    1fb2:	0f 91       	pop	r16
    1fb4:	ff 90       	pop	r15
    1fb6:	ef 90       	pop	r14
    1fb8:	df 90       	pop	r13
    1fba:	cf 90       	pop	r12
    1fbc:	bf 90       	pop	r11
    1fbe:	af 90       	pop	r10
    1fc0:	9f 90       	pop	r9
    1fc2:	8f 90       	pop	r8
    1fc4:	7f 90       	pop	r7
    1fc6:	6f 90       	pop	r6
    1fc8:	5f 90       	pop	r5
    1fca:	4f 90       	pop	r4
    1fcc:	3f 90       	pop	r3
    1fce:	2f 90       	pop	r2
    1fd0:	1f 90       	pop	r1
    1fd2:	0f 90       	pop	r0
    1fd4:	0f be       	out	0x3f, r0	; 63

        asm volatile ( "reti" );
    1fd6:	0f 90       	pop	r0
    1fd8:	18 95       	reti

00001fda <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1fda:	cf 93       	push	r28
    1fdc:	df 93       	push	r29
void *pvReturn;

	vTaskSuspendAll();
    1fde:	ec 01       	movw	r28, r24
	{
		pvReturn = malloc( xWantedSize );
    1fe0:	0a d4       	rcall	.+2068   	; 0x27f6 <vTaskSuspendAll>
    1fe2:	ce 01       	movw	r24, r28
    1fe4:	0e 94 5b 1b 	call	0x36b6	; 0x36b6 <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1fe8:	ec 01       	movw	r28, r24
		}
	}
	#endif

	return pvReturn;
}
    1fea:	e8 d4       	rcall	.+2512   	; 0x29bc <xTaskResumeAll>
    1fec:	ce 01       	movw	r24, r28
    1fee:	df 91       	pop	r29
    1ff0:	cf 91       	pop	r28
    1ff2:	08 95       	ret

00001ff4 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1ff4:	cf 93       	push	r28
    1ff6:	df 93       	push	r29
	if( pv )
    1ff8:	00 97       	sbiw	r24, 0x00	; 0
    1ffa:	31 f0       	breq	.+12     	; 0x2008 <vPortFree+0x14>
	{
		vTaskSuspendAll();
    1ffc:	ec 01       	movw	r28, r24
		{
			free( pv );
    1ffe:	fb d3       	rcall	.+2038   	; 0x27f6 <vTaskSuspendAll>
    2000:	ce 01       	movw	r24, r28
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    2002:	0e 94 f3 1b 	call	0x37e6	; 0x37e6 <free>
	}
}
    2006:	da d4       	rcall	.+2484   	; 0x29bc <xTaskResumeAll>
    2008:	df 91       	pop	r29
    200a:	cf 91       	pop	r28
    200c:	08 95       	ret

0000200e <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    200e:	1f 93       	push	r17
    2010:	cf 93       	push	r28
    2012:	df 93       	push	r29
    2014:	ec 01       	movw	r28, r24
    2016:	14 2f       	mov	r17, r20
    2018:	4c 8d       	ldd	r20, Y+28	; 0x1c
    201a:	44 23       	and	r20, r20
    201c:	d9 f1       	breq	.+118    	; 0x2094 <prvCopyDataToQueue+0x86>
    201e:	11 11       	cpse	r17, r1
    2020:	16 c0       	rjmp	.+44     	; 0x204e <prvCopyDataToQueue+0x40>
    2022:	50 e0       	ldi	r21, 0x00	; 0
    2024:	8c 81       	ldd	r24, Y+4	; 0x04
    2026:	9d 81       	ldd	r25, Y+5	; 0x05
    2028:	0e 94 7c 1c 	call	0x38f8	; 0x38f8 <memcpy>
    202c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    202e:	8c 81       	ldd	r24, Y+4	; 0x04
    2030:	9d 81       	ldd	r25, Y+5	; 0x05
    2032:	82 0f       	add	r24, r18
    2034:	91 1d       	adc	r25, r1
    2036:	8c 83       	std	Y+4, r24	; 0x04
    2038:	9d 83       	std	Y+5, r25	; 0x05
    203a:	2a 81       	ldd	r18, Y+2	; 0x02
    203c:	3b 81       	ldd	r19, Y+3	; 0x03
    203e:	82 17       	cp	r24, r18
    2040:	93 07       	cpc	r25, r19
    2042:	40 f1       	brcs	.+80     	; 0x2094 <prvCopyDataToQueue+0x86>
    2044:	88 81       	ld	r24, Y
    2046:	99 81       	ldd	r25, Y+1	; 0x01
    2048:	8c 83       	std	Y+4, r24	; 0x04
    204a:	9d 83       	std	Y+5, r25	; 0x05
    204c:	23 c0       	rjmp	.+70     	; 0x2094 <prvCopyDataToQueue+0x86>
    204e:	50 e0       	ldi	r21, 0x00	; 0
    2050:	8e 81       	ldd	r24, Y+6	; 0x06
    2052:	9f 81       	ldd	r25, Y+7	; 0x07
    2054:	0e 94 7c 1c 	call	0x38f8	; 0x38f8 <memcpy>
    2058:	8c 8d       	ldd	r24, Y+28	; 0x1c
    205a:	90 e0       	ldi	r25, 0x00	; 0
    205c:	91 95       	neg	r25
    205e:	81 95       	neg	r24
    2060:	91 09       	sbc	r25, r1
    2062:	2e 81       	ldd	r18, Y+6	; 0x06
    2064:	3f 81       	ldd	r19, Y+7	; 0x07
    2066:	28 0f       	add	r18, r24
    2068:	39 1f       	adc	r19, r25
    206a:	2e 83       	std	Y+6, r18	; 0x06
    206c:	3f 83       	std	Y+7, r19	; 0x07
    206e:	48 81       	ld	r20, Y
    2070:	59 81       	ldd	r21, Y+1	; 0x01
    2072:	24 17       	cp	r18, r20
    2074:	35 07       	cpc	r19, r21
    2076:	30 f4       	brcc	.+12     	; 0x2084 <prvCopyDataToQueue+0x76>
    2078:	2a 81       	ldd	r18, Y+2	; 0x02
    207a:	3b 81       	ldd	r19, Y+3	; 0x03
    207c:	82 0f       	add	r24, r18
    207e:	93 1f       	adc	r25, r19
    2080:	8e 83       	std	Y+6, r24	; 0x06
    2082:	9f 83       	std	Y+7, r25	; 0x07
    2084:	12 30       	cpi	r17, 0x02	; 2
    2086:	31 f4       	brne	.+12     	; 0x2094 <prvCopyDataToQueue+0x86>
    2088:	8a 8d       	ldd	r24, Y+26	; 0x1a
    208a:	88 23       	and	r24, r24
    208c:	19 f0       	breq	.+6      	; 0x2094 <prvCopyDataToQueue+0x86>
    208e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2090:	81 50       	subi	r24, 0x01	; 1
    2092:	8a 8f       	std	Y+26, r24	; 0x1a
    2094:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2096:	8f 5f       	subi	r24, 0xFF	; 255
    2098:	8a 8f       	std	Y+26, r24	; 0x1a
    209a:	80 e0       	ldi	r24, 0x00	; 0
    209c:	df 91       	pop	r29
    209e:	cf 91       	pop	r28
    20a0:	1f 91       	pop	r17
    20a2:	08 95       	ret

000020a4 <prvCopyDataFromQueue>:
    20a4:	fc 01       	movw	r30, r24
    20a6:	44 8d       	ldd	r20, Z+28	; 0x1c
    20a8:	44 23       	and	r20, r20
    20aa:	a9 f0       	breq	.+42     	; 0x20d6 <prvCopyDataFromQueue+0x32>
    20ac:	50 e0       	ldi	r21, 0x00	; 0
    20ae:	26 81       	ldd	r18, Z+6	; 0x06
    20b0:	37 81       	ldd	r19, Z+7	; 0x07
    20b2:	24 0f       	add	r18, r20
    20b4:	35 1f       	adc	r19, r21
    20b6:	26 83       	std	Z+6, r18	; 0x06
    20b8:	37 83       	std	Z+7, r19	; 0x07
    20ba:	82 81       	ldd	r24, Z+2	; 0x02
    20bc:	93 81       	ldd	r25, Z+3	; 0x03
    20be:	28 17       	cp	r18, r24
    20c0:	39 07       	cpc	r19, r25
    20c2:	20 f0       	brcs	.+8      	; 0x20cc <prvCopyDataFromQueue+0x28>
    20c4:	80 81       	ld	r24, Z
    20c6:	91 81       	ldd	r25, Z+1	; 0x01
    20c8:	86 83       	std	Z+6, r24	; 0x06
    20ca:	97 83       	std	Z+7, r25	; 0x07
    20cc:	cb 01       	movw	r24, r22
    20ce:	66 81       	ldd	r22, Z+6	; 0x06
    20d0:	77 81       	ldd	r23, Z+7	; 0x07
    20d2:	0c 94 7c 1c 	jmp	0x38f8	; 0x38f8 <memcpy>
    20d6:	08 95       	ret

000020d8 <prvUnlockQueue>:
    20d8:	0f 93       	push	r16
    20da:	1f 93       	push	r17
    20dc:	cf 93       	push	r28
    20de:	df 93       	push	r29
    20e0:	ec 01       	movw	r28, r24
    20e2:	0f b6       	in	r0, 0x3f	; 63
    20e4:	f8 94       	cli
    20e6:	0f 92       	push	r0
    20e8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    20ea:	18 16       	cp	r1, r24
    20ec:	ac f4       	brge	.+42     	; 0x2118 <prvUnlockQueue+0x40>
    20ee:	89 89       	ldd	r24, Y+17	; 0x11
    20f0:	81 11       	cpse	r24, r1
    20f2:	05 c0       	rjmp	.+10     	; 0x20fe <prvUnlockQueue+0x26>
    20f4:	11 c0       	rjmp	.+34     	; 0x2118 <prvUnlockQueue+0x40>
    20f6:	89 89       	ldd	r24, Y+17	; 0x11
    20f8:	81 11       	cpse	r24, r1
    20fa:	04 c0       	rjmp	.+8      	; 0x2104 <prvUnlockQueue+0x2c>
    20fc:	0d c0       	rjmp	.+26     	; 0x2118 <prvUnlockQueue+0x40>
    20fe:	8e 01       	movw	r16, r28
    2100:	0f 5e       	subi	r16, 0xEF	; 239
    2102:	1f 4f       	sbci	r17, 0xFF	; 255
    2104:	c8 01       	movw	r24, r16
    2106:	93 d5       	rcall	.+2854   	; 0x2c2e <xTaskRemoveFromEventList>
    2108:	81 11       	cpse	r24, r1
    210a:	13 d6       	rcall	.+3110   	; 0x2d32 <vTaskMissedYield>
    210c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    210e:	81 50       	subi	r24, 0x01	; 1
    2110:	8e 8f       	std	Y+30, r24	; 0x1e
    2112:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2114:	18 16       	cp	r1, r24
    2116:	7c f3       	brlt	.-34     	; 0x20f6 <prvUnlockQueue+0x1e>
    2118:	8f ef       	ldi	r24, 0xFF	; 255
    211a:	8e 8f       	std	Y+30, r24	; 0x1e
    211c:	0f 90       	pop	r0
    211e:	0f be       	out	0x3f, r0	; 63
    2120:	0f b6       	in	r0, 0x3f	; 63
    2122:	f8 94       	cli
    2124:	0f 92       	push	r0
    2126:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2128:	18 16       	cp	r1, r24
    212a:	ac f4       	brge	.+42     	; 0x2156 <prvUnlockQueue+0x7e>
    212c:	88 85       	ldd	r24, Y+8	; 0x08
    212e:	81 11       	cpse	r24, r1
    2130:	05 c0       	rjmp	.+10     	; 0x213c <prvUnlockQueue+0x64>
    2132:	11 c0       	rjmp	.+34     	; 0x2156 <prvUnlockQueue+0x7e>
    2134:	88 85       	ldd	r24, Y+8	; 0x08
    2136:	81 11       	cpse	r24, r1
    2138:	04 c0       	rjmp	.+8      	; 0x2142 <prvUnlockQueue+0x6a>
    213a:	0d c0       	rjmp	.+26     	; 0x2156 <prvUnlockQueue+0x7e>
    213c:	8e 01       	movw	r16, r28
    213e:	08 5f       	subi	r16, 0xF8	; 248
    2140:	1f 4f       	sbci	r17, 0xFF	; 255
    2142:	c8 01       	movw	r24, r16
    2144:	74 d5       	rcall	.+2792   	; 0x2c2e <xTaskRemoveFromEventList>
    2146:	81 11       	cpse	r24, r1
    2148:	f4 d5       	rcall	.+3048   	; 0x2d32 <vTaskMissedYield>
    214a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    214c:	81 50       	subi	r24, 0x01	; 1
    214e:	8d 8f       	std	Y+29, r24	; 0x1d
    2150:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2152:	18 16       	cp	r1, r24
    2154:	7c f3       	brlt	.-34     	; 0x2134 <prvUnlockQueue+0x5c>
    2156:	8f ef       	ldi	r24, 0xFF	; 255
    2158:	8d 8f       	std	Y+29, r24	; 0x1d
    215a:	0f 90       	pop	r0
    215c:	0f be       	out	0x3f, r0	; 63
    215e:	df 91       	pop	r29
    2160:	cf 91       	pop	r28
    2162:	1f 91       	pop	r17
    2164:	0f 91       	pop	r16
    2166:	08 95       	ret

00002168 <xQueueGenericReset>:
    2168:	cf 93       	push	r28
    216a:	df 93       	push	r29
    216c:	ec 01       	movw	r28, r24
    216e:	0f b6       	in	r0, 0x3f	; 63
    2170:	f8 94       	cli
    2172:	0f 92       	push	r0
    2174:	48 81       	ld	r20, Y
    2176:	59 81       	ldd	r21, Y+1	; 0x01
    2178:	2c 8d       	ldd	r18, Y+28	; 0x1c
    217a:	30 e0       	ldi	r19, 0x00	; 0
    217c:	7b 8d       	ldd	r23, Y+27	; 0x1b
    217e:	72 9f       	mul	r23, r18
    2180:	c0 01       	movw	r24, r0
    2182:	73 9f       	mul	r23, r19
    2184:	90 0d       	add	r25, r0
    2186:	11 24       	eor	r1, r1
    2188:	fa 01       	movw	r30, r20
    218a:	e8 0f       	add	r30, r24
    218c:	f9 1f       	adc	r31, r25
    218e:	ea 83       	std	Y+2, r30	; 0x02
    2190:	fb 83       	std	Y+3, r31	; 0x03
    2192:	1a 8e       	std	Y+26, r1	; 0x1a
    2194:	4c 83       	std	Y+4, r20	; 0x04
    2196:	5d 83       	std	Y+5, r21	; 0x05
    2198:	82 1b       	sub	r24, r18
    219a:	93 0b       	sbc	r25, r19
    219c:	84 0f       	add	r24, r20
    219e:	95 1f       	adc	r25, r21
    21a0:	8e 83       	std	Y+6, r24	; 0x06
    21a2:	9f 83       	std	Y+7, r25	; 0x07
    21a4:	8f ef       	ldi	r24, 0xFF	; 255
    21a6:	8d 8f       	std	Y+29, r24	; 0x1d
    21a8:	8e 8f       	std	Y+30, r24	; 0x1e
    21aa:	61 11       	cpse	r22, r1
    21ac:	0a c0       	rjmp	.+20     	; 0x21c2 <xQueueGenericReset+0x5a>
    21ae:	88 85       	ldd	r24, Y+8	; 0x08
    21b0:	88 23       	and	r24, r24
    21b2:	69 f0       	breq	.+26     	; 0x21ce <xQueueGenericReset+0x66>
    21b4:	ce 01       	movw	r24, r28
    21b6:	08 96       	adiw	r24, 0x08	; 8
    21b8:	3a d5       	rcall	.+2676   	; 0x2c2e <xTaskRemoveFromEventList>
    21ba:	81 30       	cpi	r24, 0x01	; 1
    21bc:	41 f4       	brne	.+16     	; 0x21ce <xQueueGenericReset+0x66>
    21be:	5b de       	rcall	.-842    	; 0x1e76 <vPortYield>
    21c0:	06 c0       	rjmp	.+12     	; 0x21ce <xQueueGenericReset+0x66>
    21c2:	ce 01       	movw	r24, r28
    21c4:	08 96       	adiw	r24, 0x08	; 8
    21c6:	11 dd       	rcall	.-1502   	; 0x1bea <vListInitialise>
    21c8:	ce 01       	movw	r24, r28
    21ca:	41 96       	adiw	r24, 0x11	; 17
    21cc:	0e dd       	rcall	.-1508   	; 0x1bea <vListInitialise>
    21ce:	0f 90       	pop	r0
    21d0:	0f be       	out	0x3f, r0	; 63
    21d2:	81 e0       	ldi	r24, 0x01	; 1
    21d4:	df 91       	pop	r29
    21d6:	cf 91       	pop	r28
    21d8:	08 95       	ret

000021da <xQueueGenericCreate>:
    21da:	0f 93       	push	r16
    21dc:	1f 93       	push	r17
    21de:	cf 93       	push	r28
    21e0:	df 93       	push	r29
    21e2:	08 2f       	mov	r16, r24
    21e4:	16 2f       	mov	r17, r22
    21e6:	66 23       	and	r22, r22
    21e8:	a9 f0       	breq	.+42     	; 0x2214 <xQueueGenericCreate+0x3a>
    21ea:	86 9f       	mul	r24, r22
    21ec:	c0 01       	movw	r24, r0
    21ee:	11 24       	eor	r1, r1
    21f0:	80 96       	adiw	r24, 0x20	; 32
    21f2:	f3 de       	rcall	.-538    	; 0x1fda <pvPortMalloc>
    21f4:	ec 01       	movw	r28, r24
    21f6:	00 97       	sbiw	r24, 0x00	; 0
    21f8:	21 f4       	brne	.+8      	; 0x2202 <xQueueGenericCreate+0x28>
    21fa:	12 c0       	rjmp	.+36     	; 0x2220 <xQueueGenericCreate+0x46>
    21fc:	c8 83       	st	Y, r28
    21fe:	d9 83       	std	Y+1, r29	; 0x01
    2200:	03 c0       	rjmp	.+6      	; 0x2208 <xQueueGenericCreate+0x2e>
    2202:	4f 96       	adiw	r24, 0x1f	; 31
    2204:	88 83       	st	Y, r24
    2206:	99 83       	std	Y+1, r25	; 0x01
    2208:	0b 8f       	std	Y+27, r16	; 0x1b
    220a:	1c 8f       	std	Y+28, r17	; 0x1c
    220c:	61 e0       	ldi	r22, 0x01	; 1
    220e:	ce 01       	movw	r24, r28
    2210:	ab df       	rcall	.-170    	; 0x2168 <xQueueGenericReset>
    2212:	06 c0       	rjmp	.+12     	; 0x2220 <xQueueGenericCreate+0x46>
    2214:	8f e1       	ldi	r24, 0x1F	; 31
    2216:	90 e0       	ldi	r25, 0x00	; 0
    2218:	e0 de       	rcall	.-576    	; 0x1fda <pvPortMalloc>
    221a:	ec 01       	movw	r28, r24
    221c:	89 2b       	or	r24, r25
    221e:	71 f7       	brne	.-36     	; 0x21fc <xQueueGenericCreate+0x22>
    2220:	ce 01       	movw	r24, r28
    2222:	df 91       	pop	r29
    2224:	cf 91       	pop	r28
    2226:	1f 91       	pop	r17
    2228:	0f 91       	pop	r16
    222a:	08 95       	ret

0000222c <xQueueGenericSend>:
    222c:	af 92       	push	r10
    222e:	bf 92       	push	r11
    2230:	cf 92       	push	r12
    2232:	df 92       	push	r13
    2234:	ef 92       	push	r14
    2236:	ff 92       	push	r15
    2238:	0f 93       	push	r16
    223a:	1f 93       	push	r17
    223c:	cf 93       	push	r28
    223e:	df 93       	push	r29
    2240:	cd b7       	in	r28, 0x3d	; 61
    2242:	de b7       	in	r29, 0x3e	; 62
    2244:	25 97       	sbiw	r28, 0x05	; 5
    2246:	cd bf       	out	0x3d, r28	; 61
    2248:	de bf       	out	0x3e, r29	; 62
    224a:	8c 01       	movw	r16, r24
    224c:	6b 01       	movw	r12, r22
    224e:	4c 83       	std	Y+4, r20	; 0x04
    2250:	5d 83       	std	Y+5, r21	; 0x05
    2252:	a2 2e       	mov	r10, r18
    2254:	b1 2c       	mov	r11, r1
    2256:	7c 01       	movw	r14, r24
    2258:	88 e0       	ldi	r24, 0x08	; 8
    225a:	e8 0e       	add	r14, r24
    225c:	f1 1c       	adc	r15, r1
    225e:	0f b6       	in	r0, 0x3f	; 63
    2260:	f8 94       	cli
    2262:	0f 92       	push	r0
    2264:	f8 01       	movw	r30, r16
    2266:	92 8d       	ldd	r25, Z+26	; 0x1a
    2268:	83 8d       	ldd	r24, Z+27	; 0x1b
    226a:	98 17       	cp	r25, r24
    226c:	18 f0       	brcs	.+6      	; 0x2274 <xQueueGenericSend+0x48>
    226e:	f2 e0       	ldi	r31, 0x02	; 2
    2270:	af 12       	cpse	r10, r31
    2272:	15 c0       	rjmp	.+42     	; 0x229e <xQueueGenericSend+0x72>
    2274:	4a 2d       	mov	r20, r10
    2276:	b6 01       	movw	r22, r12
    2278:	c8 01       	movw	r24, r16
    227a:	c9 de       	rcall	.-622    	; 0x200e <prvCopyDataToQueue>
    227c:	f8 01       	movw	r30, r16
    227e:	91 89       	ldd	r25, Z+17	; 0x11
    2280:	99 23       	and	r25, r25
    2282:	39 f0       	breq	.+14     	; 0x2292 <xQueueGenericSend+0x66>
    2284:	c8 01       	movw	r24, r16
    2286:	41 96       	adiw	r24, 0x11	; 17
    2288:	d2 d4       	rcall	.+2468   	; 0x2c2e <xTaskRemoveFromEventList>
    228a:	81 30       	cpi	r24, 0x01	; 1
    228c:	21 f4       	brne	.+8      	; 0x2296 <xQueueGenericSend+0x6a>
    228e:	f3 dd       	rcall	.-1050   	; 0x1e76 <vPortYield>
    2290:	02 c0       	rjmp	.+4      	; 0x2296 <xQueueGenericSend+0x6a>
    2292:	81 11       	cpse	r24, r1
    2294:	f0 dd       	rcall	.-1056   	; 0x1e76 <vPortYield>
    2296:	0f 90       	pop	r0
    2298:	0f be       	out	0x3f, r0	; 63
    229a:	81 e0       	ldi	r24, 0x01	; 1
    229c:	46 c0       	rjmp	.+140    	; 0x232a <xQueueGenericSend+0xfe>
    229e:	8c 81       	ldd	r24, Y+4	; 0x04
    22a0:	9d 81       	ldd	r25, Y+5	; 0x05
    22a2:	89 2b       	or	r24, r25
    22a4:	21 f4       	brne	.+8      	; 0x22ae <xQueueGenericSend+0x82>
    22a6:	0f 90       	pop	r0
    22a8:	0f be       	out	0x3f, r0	; 63
    22aa:	80 e0       	ldi	r24, 0x00	; 0
    22ac:	3e c0       	rjmp	.+124    	; 0x232a <xQueueGenericSend+0xfe>
    22ae:	b1 10       	cpse	r11, r1
    22b0:	05 c0       	rjmp	.+10     	; 0x22bc <xQueueGenericSend+0x90>
    22b2:	ce 01       	movw	r24, r28
    22b4:	01 96       	adiw	r24, 0x01	; 1
    22b6:	01 d5       	rcall	.+2562   	; 0x2cba <vTaskSetTimeOutState>
    22b8:	bb 24       	eor	r11, r11
    22ba:	b3 94       	inc	r11
    22bc:	0f 90       	pop	r0
    22be:	0f be       	out	0x3f, r0	; 63
    22c0:	9a d2       	rcall	.+1332   	; 0x27f6 <vTaskSuspendAll>
    22c2:	0f b6       	in	r0, 0x3f	; 63
    22c4:	f8 94       	cli
    22c6:	0f 92       	push	r0
    22c8:	f8 01       	movw	r30, r16
    22ca:	85 8d       	ldd	r24, Z+29	; 0x1d
    22cc:	8f 3f       	cpi	r24, 0xFF	; 255
    22ce:	09 f4       	brne	.+2      	; 0x22d2 <xQueueGenericSend+0xa6>
    22d0:	15 8e       	std	Z+29, r1	; 0x1d
    22d2:	f8 01       	movw	r30, r16
    22d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    22d6:	8f 3f       	cpi	r24, 0xFF	; 255
    22d8:	09 f4       	brne	.+2      	; 0x22dc <xQueueGenericSend+0xb0>
    22da:	16 8e       	std	Z+30, r1	; 0x1e
    22dc:	0f 90       	pop	r0
    22de:	0f be       	out	0x3f, r0	; 63
    22e0:	be 01       	movw	r22, r28
    22e2:	6c 5f       	subi	r22, 0xFC	; 252
    22e4:	7f 4f       	sbci	r23, 0xFF	; 255
    22e6:	ce 01       	movw	r24, r28
    22e8:	01 96       	adiw	r24, 0x01	; 1
    22ea:	f2 d4       	rcall	.+2532   	; 0x2cd0 <xTaskCheckForTimeOut>
    22ec:	81 11       	cpse	r24, r1
    22ee:	19 c0       	rjmp	.+50     	; 0x2322 <xQueueGenericSend+0xf6>
    22f0:	0f b6       	in	r0, 0x3f	; 63
    22f2:	f8 94       	cli
    22f4:	0f 92       	push	r0
    22f6:	f8 01       	movw	r30, r16
    22f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    22fa:	0f 90       	pop	r0
    22fc:	0f be       	out	0x3f, r0	; 63
    22fe:	83 8d       	ldd	r24, Z+27	; 0x1b
    2300:	98 13       	cpse	r25, r24
    2302:	0b c0       	rjmp	.+22     	; 0x231a <xQueueGenericSend+0xee>
    2304:	6c 81       	ldd	r22, Y+4	; 0x04
    2306:	7d 81       	ldd	r23, Y+5	; 0x05
    2308:	c7 01       	movw	r24, r14
    230a:	5d d4       	rcall	.+2234   	; 0x2bc6 <vTaskPlaceOnEventList>
    230c:	c8 01       	movw	r24, r16
    230e:	e4 de       	rcall	.-568    	; 0x20d8 <prvUnlockQueue>
    2310:	55 d3       	rcall	.+1706   	; 0x29bc <xTaskResumeAll>
    2312:	81 11       	cpse	r24, r1
    2314:	a4 cf       	rjmp	.-184    	; 0x225e <xQueueGenericSend+0x32>
    2316:	af dd       	rcall	.-1186   	; 0x1e76 <vPortYield>
    2318:	a2 cf       	rjmp	.-188    	; 0x225e <xQueueGenericSend+0x32>
    231a:	c8 01       	movw	r24, r16
    231c:	dd de       	rcall	.-582    	; 0x20d8 <prvUnlockQueue>
    231e:	4e d3       	rcall	.+1692   	; 0x29bc <xTaskResumeAll>
    2320:	9e cf       	rjmp	.-196    	; 0x225e <xQueueGenericSend+0x32>
    2322:	c8 01       	movw	r24, r16
    2324:	d9 de       	rcall	.-590    	; 0x20d8 <prvUnlockQueue>
    2326:	4a d3       	rcall	.+1684   	; 0x29bc <xTaskResumeAll>
    2328:	80 e0       	ldi	r24, 0x00	; 0
    232a:	25 96       	adiw	r28, 0x05	; 5
    232c:	cd bf       	out	0x3d, r28	; 61
    232e:	de bf       	out	0x3e, r29	; 62
    2330:	df 91       	pop	r29
    2332:	cf 91       	pop	r28
    2334:	1f 91       	pop	r17
    2336:	0f 91       	pop	r16
    2338:	ff 90       	pop	r15
    233a:	ef 90       	pop	r14
    233c:	df 90       	pop	r13
    233e:	cf 90       	pop	r12
    2340:	bf 90       	pop	r11
    2342:	af 90       	pop	r10
    2344:	08 95       	ret

00002346 <xQueueGenericSendFromISR>:
    2346:	0f 93       	push	r16
    2348:	1f 93       	push	r17
    234a:	cf 93       	push	r28
    234c:	df 93       	push	r29
    234e:	fa 01       	movw	r30, r20
    2350:	dc 01       	movw	r26, r24
    2352:	5a 96       	adiw	r26, 0x1a	; 26
    2354:	5c 91       	ld	r21, X
    2356:	5a 97       	sbiw	r26, 0x1a	; 26
    2358:	5b 96       	adiw	r26, 0x1b	; 27
    235a:	3c 91       	ld	r19, X
    235c:	53 17       	cp	r21, r19
    235e:	10 f0       	brcs	.+4      	; 0x2364 <xQueueGenericSendFromISR+0x1e>
    2360:	22 30       	cpi	r18, 0x02	; 2
    2362:	d9 f4       	brne	.+54     	; 0x239a <xQueueGenericSendFromISR+0x54>
    2364:	42 2f       	mov	r20, r18
    2366:	8f 01       	movw	r16, r30
    2368:	ec 01       	movw	r28, r24
    236a:	51 de       	rcall	.-862    	; 0x200e <prvCopyDataToQueue>
    236c:	8e 8d       	ldd	r24, Y+30	; 0x1e
    236e:	8f 3f       	cpi	r24, 0xFF	; 255
    2370:	79 f4       	brne	.+30     	; 0x2390 <xQueueGenericSendFromISR+0x4a>
    2372:	89 89       	ldd	r24, Y+17	; 0x11
    2374:	88 23       	and	r24, r24
    2376:	99 f0       	breq	.+38     	; 0x239e <xQueueGenericSendFromISR+0x58>
    2378:	ce 01       	movw	r24, r28
    237a:	41 96       	adiw	r24, 0x11	; 17
    237c:	58 d4       	rcall	.+2224   	; 0x2c2e <xTaskRemoveFromEventList>
    237e:	88 23       	and	r24, r24
    2380:	81 f0       	breq	.+32     	; 0x23a2 <xQueueGenericSendFromISR+0x5c>
    2382:	01 15       	cp	r16, r1
    2384:	11 05       	cpc	r17, r1
    2386:	79 f0       	breq	.+30     	; 0x23a6 <xQueueGenericSendFromISR+0x60>
    2388:	81 e0       	ldi	r24, 0x01	; 1
    238a:	f8 01       	movw	r30, r16
    238c:	80 83       	st	Z, r24
    238e:	0c c0       	rjmp	.+24     	; 0x23a8 <xQueueGenericSendFromISR+0x62>
    2390:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2392:	8f 5f       	subi	r24, 0xFF	; 255
    2394:	8e 8f       	std	Y+30, r24	; 0x1e
    2396:	81 e0       	ldi	r24, 0x01	; 1
    2398:	07 c0       	rjmp	.+14     	; 0x23a8 <xQueueGenericSendFromISR+0x62>
    239a:	80 e0       	ldi	r24, 0x00	; 0
    239c:	05 c0       	rjmp	.+10     	; 0x23a8 <xQueueGenericSendFromISR+0x62>
    239e:	81 e0       	ldi	r24, 0x01	; 1
    23a0:	03 c0       	rjmp	.+6      	; 0x23a8 <xQueueGenericSendFromISR+0x62>
    23a2:	81 e0       	ldi	r24, 0x01	; 1
    23a4:	01 c0       	rjmp	.+2      	; 0x23a8 <xQueueGenericSendFromISR+0x62>
    23a6:	81 e0       	ldi	r24, 0x01	; 1
    23a8:	df 91       	pop	r29
    23aa:	cf 91       	pop	r28
    23ac:	1f 91       	pop	r17
    23ae:	0f 91       	pop	r16
    23b0:	08 95       	ret

000023b2 <xQueueGenericReceive>:
    23b2:	af 92       	push	r10
    23b4:	bf 92       	push	r11
    23b6:	cf 92       	push	r12
    23b8:	df 92       	push	r13
    23ba:	ef 92       	push	r14
    23bc:	ff 92       	push	r15
    23be:	0f 93       	push	r16
    23c0:	1f 93       	push	r17
    23c2:	cf 93       	push	r28
    23c4:	df 93       	push	r29
    23c6:	cd b7       	in	r28, 0x3d	; 61
    23c8:	de b7       	in	r29, 0x3e	; 62
    23ca:	25 97       	sbiw	r28, 0x05	; 5
    23cc:	cd bf       	out	0x3d, r28	; 61
    23ce:	de bf       	out	0x3e, r29	; 62
    23d0:	8c 01       	movw	r16, r24
    23d2:	6b 01       	movw	r12, r22
    23d4:	4c 83       	std	Y+4, r20	; 0x04
    23d6:	5d 83       	std	Y+5, r21	; 0x05
    23d8:	a2 2e       	mov	r10, r18
    23da:	b1 2c       	mov	r11, r1
    23dc:	7c 01       	movw	r14, r24
    23de:	81 e1       	ldi	r24, 0x11	; 17
    23e0:	e8 0e       	add	r14, r24
    23e2:	f1 1c       	adc	r15, r1
    23e4:	0f b6       	in	r0, 0x3f	; 63
    23e6:	f8 94       	cli
    23e8:	0f 92       	push	r0
    23ea:	f8 01       	movw	r30, r16
    23ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    23ee:	88 23       	and	r24, r24
    23f0:	21 f1       	breq	.+72     	; 0x243a <xQueueGenericReceive+0x88>
    23f2:	e6 80       	ldd	r14, Z+6	; 0x06
    23f4:	f7 80       	ldd	r15, Z+7	; 0x07
    23f6:	b6 01       	movw	r22, r12
    23f8:	c8 01       	movw	r24, r16
    23fa:	54 de       	rcall	.-856    	; 0x20a4 <prvCopyDataFromQueue>
    23fc:	a1 10       	cpse	r10, r1
    23fe:	0e c0       	rjmp	.+28     	; 0x241c <xQueueGenericReceive+0x6a>
    2400:	f8 01       	movw	r30, r16
    2402:	82 8d       	ldd	r24, Z+26	; 0x1a
    2404:	81 50       	subi	r24, 0x01	; 1
    2406:	82 8f       	std	Z+26, r24	; 0x1a
    2408:	80 85       	ldd	r24, Z+8	; 0x08
    240a:	88 23       	and	r24, r24
    240c:	91 f0       	breq	.+36     	; 0x2432 <xQueueGenericReceive+0x80>
    240e:	c8 01       	movw	r24, r16
    2410:	08 96       	adiw	r24, 0x08	; 8
    2412:	0d d4       	rcall	.+2074   	; 0x2c2e <xTaskRemoveFromEventList>
    2414:	81 30       	cpi	r24, 0x01	; 1
    2416:	69 f4       	brne	.+26     	; 0x2432 <xQueueGenericReceive+0x80>
    2418:	2e dd       	rcall	.-1444   	; 0x1e76 <vPortYield>
    241a:	0b c0       	rjmp	.+22     	; 0x2432 <xQueueGenericReceive+0x80>
    241c:	f8 01       	movw	r30, r16
    241e:	e6 82       	std	Z+6, r14	; 0x06
    2420:	f7 82       	std	Z+7, r15	; 0x07
    2422:	81 89       	ldd	r24, Z+17	; 0x11
    2424:	88 23       	and	r24, r24
    2426:	29 f0       	breq	.+10     	; 0x2432 <xQueueGenericReceive+0x80>
    2428:	c8 01       	movw	r24, r16
    242a:	41 96       	adiw	r24, 0x11	; 17
    242c:	00 d4       	rcall	.+2048   	; 0x2c2e <xTaskRemoveFromEventList>
    242e:	81 11       	cpse	r24, r1
    2430:	22 dd       	rcall	.-1468   	; 0x1e76 <vPortYield>
    2432:	0f 90       	pop	r0
    2434:	0f be       	out	0x3f, r0	; 63
    2436:	81 e0       	ldi	r24, 0x01	; 1
    2438:	45 c0       	rjmp	.+138    	; 0x24c4 <xQueueGenericReceive+0x112>
    243a:	8c 81       	ldd	r24, Y+4	; 0x04
    243c:	9d 81       	ldd	r25, Y+5	; 0x05
    243e:	89 2b       	or	r24, r25
    2440:	21 f4       	brne	.+8      	; 0x244a <xQueueGenericReceive+0x98>
    2442:	0f 90       	pop	r0
    2444:	0f be       	out	0x3f, r0	; 63
    2446:	80 e0       	ldi	r24, 0x00	; 0
    2448:	3d c0       	rjmp	.+122    	; 0x24c4 <xQueueGenericReceive+0x112>
    244a:	b1 10       	cpse	r11, r1
    244c:	05 c0       	rjmp	.+10     	; 0x2458 <xQueueGenericReceive+0xa6>
    244e:	ce 01       	movw	r24, r28
    2450:	01 96       	adiw	r24, 0x01	; 1
    2452:	33 d4       	rcall	.+2150   	; 0x2cba <vTaskSetTimeOutState>
    2454:	bb 24       	eor	r11, r11
    2456:	b3 94       	inc	r11
    2458:	0f 90       	pop	r0
    245a:	0f be       	out	0x3f, r0	; 63
    245c:	cc d1       	rcall	.+920    	; 0x27f6 <vTaskSuspendAll>
    245e:	0f b6       	in	r0, 0x3f	; 63
    2460:	f8 94       	cli
    2462:	0f 92       	push	r0
    2464:	f8 01       	movw	r30, r16
    2466:	85 8d       	ldd	r24, Z+29	; 0x1d
    2468:	8f 3f       	cpi	r24, 0xFF	; 255
    246a:	09 f4       	brne	.+2      	; 0x246e <xQueueGenericReceive+0xbc>
    246c:	15 8e       	std	Z+29, r1	; 0x1d
    246e:	f8 01       	movw	r30, r16
    2470:	86 8d       	ldd	r24, Z+30	; 0x1e
    2472:	8f 3f       	cpi	r24, 0xFF	; 255
    2474:	09 f4       	brne	.+2      	; 0x2478 <xQueueGenericReceive+0xc6>
    2476:	16 8e       	std	Z+30, r1	; 0x1e
    2478:	0f 90       	pop	r0
    247a:	0f be       	out	0x3f, r0	; 63
    247c:	be 01       	movw	r22, r28
    247e:	6c 5f       	subi	r22, 0xFC	; 252
    2480:	7f 4f       	sbci	r23, 0xFF	; 255
    2482:	ce 01       	movw	r24, r28
    2484:	01 96       	adiw	r24, 0x01	; 1
    2486:	24 d4       	rcall	.+2120   	; 0x2cd0 <xTaskCheckForTimeOut>
    2488:	81 11       	cpse	r24, r1
    248a:	18 c0       	rjmp	.+48     	; 0x24bc <xQueueGenericReceive+0x10a>
    248c:	0f b6       	in	r0, 0x3f	; 63
    248e:	f8 94       	cli
    2490:	0f 92       	push	r0
    2492:	f8 01       	movw	r30, r16
    2494:	82 8d       	ldd	r24, Z+26	; 0x1a
    2496:	0f 90       	pop	r0
    2498:	0f be       	out	0x3f, r0	; 63
    249a:	81 11       	cpse	r24, r1
    249c:	0b c0       	rjmp	.+22     	; 0x24b4 <xQueueGenericReceive+0x102>
    249e:	6c 81       	ldd	r22, Y+4	; 0x04
    24a0:	7d 81       	ldd	r23, Y+5	; 0x05
    24a2:	c7 01       	movw	r24, r14
    24a4:	90 d3       	rcall	.+1824   	; 0x2bc6 <vTaskPlaceOnEventList>
    24a6:	c8 01       	movw	r24, r16
    24a8:	17 de       	rcall	.-978    	; 0x20d8 <prvUnlockQueue>
    24aa:	88 d2       	rcall	.+1296   	; 0x29bc <xTaskResumeAll>
    24ac:	81 11       	cpse	r24, r1
    24ae:	9a cf       	rjmp	.-204    	; 0x23e4 <xQueueGenericReceive+0x32>
    24b0:	e2 dc       	rcall	.-1596   	; 0x1e76 <vPortYield>
    24b2:	98 cf       	rjmp	.-208    	; 0x23e4 <xQueueGenericReceive+0x32>
    24b4:	c8 01       	movw	r24, r16
    24b6:	10 de       	rcall	.-992    	; 0x20d8 <prvUnlockQueue>
    24b8:	81 d2       	rcall	.+1282   	; 0x29bc <xTaskResumeAll>
    24ba:	94 cf       	rjmp	.-216    	; 0x23e4 <xQueueGenericReceive+0x32>
    24bc:	c8 01       	movw	r24, r16
    24be:	0c de       	rcall	.-1000   	; 0x20d8 <prvUnlockQueue>
    24c0:	7d d2       	rcall	.+1274   	; 0x29bc <xTaskResumeAll>
    24c2:	80 e0       	ldi	r24, 0x00	; 0
    24c4:	25 96       	adiw	r28, 0x05	; 5
    24c6:	cd bf       	out	0x3d, r28	; 61
    24c8:	de bf       	out	0x3e, r29	; 62
    24ca:	df 91       	pop	r29
    24cc:	cf 91       	pop	r28
    24ce:	1f 91       	pop	r17
    24d0:	0f 91       	pop	r16
    24d2:	ff 90       	pop	r15
    24d4:	ef 90       	pop	r14
    24d6:	df 90       	pop	r13
    24d8:	cf 90       	pop	r12
    24da:	bf 90       	pop	r11
    24dc:	af 90       	pop	r10
    24de:	08 95       	ret

000024e0 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    24e0:	cf 93       	push	r28
    24e2:	df 93       	push	r29
    24e4:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    24e6:	0f b6       	in	r0, 0x3f	; 63
    24e8:	f8 94       	cli
    24ea:	0f 92       	push	r0
    24ec:	8d 8d       	ldd	r24, Y+29	; 0x1d
    24ee:	8f 3f       	cpi	r24, 0xFF	; 255
    24f0:	09 f4       	brne	.+2      	; 0x24f4 <vQueueWaitForMessageRestricted+0x14>
    24f2:	1d 8e       	std	Y+29, r1	; 0x1d
    24f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    24f6:	8f 3f       	cpi	r24, 0xFF	; 255
    24f8:	09 f4       	brne	.+2      	; 0x24fc <vQueueWaitForMessageRestricted+0x1c>
    24fa:	1e 8e       	std	Y+30, r1	; 0x1e
    24fc:	0f 90       	pop	r0
    24fe:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2500:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2502:	81 11       	cpse	r24, r1
    2504:	03 c0       	rjmp	.+6      	; 0x250c <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2506:	ce 01       	movw	r24, r28
    2508:	41 96       	adiw	r24, 0x11	; 17
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    250a:	77 d3       	rcall	.+1774   	; 0x2bfa <vTaskPlaceOnEventListRestricted>
    250c:	ce 01       	movw	r24, r28
	}
    250e:	e4 dd       	rcall	.-1080   	; 0x20d8 <prvUnlockQueue>
    2510:	df 91       	pop	r29
    2512:	cf 91       	pop	r28
    2514:	08 95       	ret

00002516 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2516:	cf e6       	ldi	r28, 0x6F	; 111
    2518:	d2 e2       	ldi	r29, 0x22	; 34
    251a:	88 81       	ld	r24, Y
    251c:	82 30       	cpi	r24, 0x02	; 2
    251e:	f0 f3       	brcs	.-4      	; 0x251c <prvIdleTask+0x6>
    2520:	aa dc       	rcall	.-1708   	; 0x1e76 <vPortYield>
    2522:	fb cf       	rjmp	.-10     	; 0x251a <prvIdleTask+0x4>

00002524 <prvAddCurrentTaskToDelayedList>:
    2524:	cf 93       	push	r28
    2526:	df 93       	push	r29
    2528:	ec 01       	movw	r28, r24
    252a:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    252e:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2532:	82 83       	std	Z+2, r24	; 0x02
    2534:	93 83       	std	Z+3, r25	; 0x03
    2536:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <xTickCount>
    253a:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <xTickCount+0x1>
    253e:	c8 17       	cp	r28, r24
    2540:	d9 07       	cpc	r29, r25
    2542:	60 f4       	brcc	.+24     	; 0x255c <prvAddCurrentTaskToDelayedList+0x38>
    2544:	60 91 9c 22 	lds	r22, 0x229C	; 0x80229c <pxCurrentTCB>
    2548:	70 91 9d 22 	lds	r23, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    254c:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <pxOverflowDelayedTaskList>
    2550:	90 91 5a 22 	lds	r25, 0x225A	; 0x80225a <pxOverflowDelayedTaskList+0x1>
    2554:	6e 5f       	subi	r22, 0xFE	; 254
    2556:	7f 4f       	sbci	r23, 0xFF	; 255
    2558:	7b db       	rcall	.-2314   	; 0x1c50 <vListInsert>
    255a:	16 c0       	rjmp	.+44     	; 0x2588 <prvAddCurrentTaskToDelayedList+0x64>
    255c:	60 91 9c 22 	lds	r22, 0x229C	; 0x80229c <pxCurrentTCB>
    2560:	70 91 9d 22 	lds	r23, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2564:	80 91 5b 22 	lds	r24, 0x225B	; 0x80225b <pxDelayedTaskList>
    2568:	90 91 5c 22 	lds	r25, 0x225C	; 0x80225c <pxDelayedTaskList+0x1>
    256c:	6e 5f       	subi	r22, 0xFE	; 254
    256e:	7f 4f       	sbci	r23, 0xFF	; 255
    2570:	6f db       	rcall	.-2338   	; 0x1c50 <vListInsert>
    2572:	80 91 45 22 	lds	r24, 0x2245	; 0x802245 <xNextTaskUnblockTime>
    2576:	90 91 46 22 	lds	r25, 0x2246	; 0x802246 <xNextTaskUnblockTime+0x1>
    257a:	c8 17       	cp	r28, r24
    257c:	d9 07       	cpc	r29, r25
    257e:	20 f4       	brcc	.+8      	; 0x2588 <prvAddCurrentTaskToDelayedList+0x64>
    2580:	c0 93 45 22 	sts	0x2245, r28	; 0x802245 <xNextTaskUnblockTime>
    2584:	d0 93 46 22 	sts	0x2246, r29	; 0x802246 <xNextTaskUnblockTime+0x1>
    2588:	df 91       	pop	r29
    258a:	cf 91       	pop	r28
    258c:	08 95       	ret

0000258e <xTaskGenericCreate>:
    258e:	4f 92       	push	r4
    2590:	5f 92       	push	r5
    2592:	6f 92       	push	r6
    2594:	7f 92       	push	r7
    2596:	8f 92       	push	r8
    2598:	9f 92       	push	r9
    259a:	af 92       	push	r10
    259c:	bf 92       	push	r11
    259e:	cf 92       	push	r12
    25a0:	df 92       	push	r13
    25a2:	ef 92       	push	r14
    25a4:	ff 92       	push	r15
    25a6:	0f 93       	push	r16
    25a8:	1f 93       	push	r17
    25aa:	cf 93       	push	r28
    25ac:	df 93       	push	r29
    25ae:	4c 01       	movw	r8, r24
    25b0:	eb 01       	movw	r28, r22
    25b2:	5a 01       	movw	r10, r20
    25b4:	29 01       	movw	r4, r18
    25b6:	c1 14       	cp	r12, r1
    25b8:	d1 04       	cpc	r13, r1
    25ba:	31 f4       	brne	.+12     	; 0x25c8 <xTaskGenericCreate+0x3a>
    25bc:	ca 01       	movw	r24, r20
    25be:	0d dd       	rcall	.-1510   	; 0x1fda <pvPortMalloc>
    25c0:	6c 01       	movw	r12, r24
    25c2:	89 2b       	or	r24, r25
    25c4:	09 f4       	brne	.+2      	; 0x25c8 <xTaskGenericCreate+0x3a>
    25c6:	d2 c0       	rjmp	.+420    	; 0x276c <xTaskGenericCreate+0x1de>
    25c8:	86 e2       	ldi	r24, 0x26	; 38
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	06 dd       	rcall	.-1524   	; 0x1fda <pvPortMalloc>
    25ce:	3c 01       	movw	r6, r24
    25d0:	00 97       	sbiw	r24, 0x00	; 0
    25d2:	79 f0       	breq	.+30     	; 0x25f2 <xTaskGenericCreate+0x64>
    25d4:	fc 01       	movw	r30, r24
    25d6:	c7 8a       	std	Z+23, r12	; 0x17
    25d8:	d0 8e       	std	Z+24, r13	; 0x18
    25da:	f1 e0       	ldi	r31, 0x01	; 1
    25dc:	af 1a       	sub	r10, r31
    25de:	b1 08       	sbc	r11, r1
    25e0:	ca 0c       	add	r12, r10
    25e2:	db 1c       	adc	r13, r11
    25e4:	88 81       	ld	r24, Y
    25e6:	f3 01       	movw	r30, r6
    25e8:	81 8f       	std	Z+25, r24	; 0x19
    25ea:	88 81       	ld	r24, Y
    25ec:	81 11       	cpse	r24, r1
    25ee:	04 c0       	rjmp	.+8      	; 0x25f8 <xTaskGenericCreate+0x6a>
    25f0:	13 c0       	rjmp	.+38     	; 0x2618 <xTaskGenericCreate+0x8a>
    25f2:	c6 01       	movw	r24, r12
    25f4:	ff dc       	rcall	.-1538   	; 0x1ff4 <vPortFree>
    25f6:	ba c0       	rjmp	.+372    	; 0x276c <xTaskGenericCreate+0x1de>
    25f8:	d3 01       	movw	r26, r6
    25fa:	5a 96       	adiw	r26, 0x1a	; 26
    25fc:	fe 01       	movw	r30, r28
    25fe:	31 96       	adiw	r30, 0x01	; 1
    2600:	9e 01       	movw	r18, r28
    2602:	28 5f       	subi	r18, 0xF8	; 248
    2604:	3f 4f       	sbci	r19, 0xFF	; 255
    2606:	ef 01       	movw	r28, r30
    2608:	81 91       	ld	r24, Z+
    260a:	8d 93       	st	X+, r24
    260c:	88 81       	ld	r24, Y
    260e:	88 23       	and	r24, r24
    2610:	19 f0       	breq	.+6      	; 0x2618 <xTaskGenericCreate+0x8a>
    2612:	2e 17       	cp	r18, r30
    2614:	3f 07       	cpc	r19, r31
    2616:	b9 f7       	brne	.-18     	; 0x2606 <xTaskGenericCreate+0x78>
    2618:	f3 01       	movw	r30, r6
    261a:	10 a2       	std	Z+32, r1	; 0x20
    261c:	10 2f       	mov	r17, r16
    261e:	05 30       	cpi	r16, 0x05	; 5
    2620:	08 f0       	brcs	.+2      	; 0x2624 <xTaskGenericCreate+0x96>
    2622:	14 e0       	ldi	r17, 0x04	; 4
    2624:	f3 01       	movw	r30, r6
    2626:	16 8b       	std	Z+22, r17	; 0x16
    2628:	e3 01       	movw	r28, r6
    262a:	22 96       	adiw	r28, 0x02	; 2
    262c:	ce 01       	movw	r24, r28
    262e:	eb da       	rcall	.-2602   	; 0x1c06 <vListInitialiseItem>
    2630:	c3 01       	movw	r24, r6
    2632:	0c 96       	adiw	r24, 0x0c	; 12
    2634:	e8 da       	rcall	.-2608   	; 0x1c06 <vListInitialiseItem>
    2636:	f3 01       	movw	r30, r6
    2638:	60 86       	std	Z+8, r6	; 0x08
    263a:	71 86       	std	Z+9, r7	; 0x09
    263c:	85 e0       	ldi	r24, 0x05	; 5
    263e:	90 e0       	ldi	r25, 0x00	; 0
    2640:	81 1b       	sub	r24, r17
    2642:	91 09       	sbc	r25, r1
    2644:	84 87       	std	Z+12, r24	; 0x0c
    2646:	95 87       	std	Z+13, r25	; 0x0d
    2648:	62 8a       	std	Z+18, r6	; 0x12
    264a:	73 8a       	std	Z+19, r7	; 0x13
    264c:	11 a2       	std	Z+33, r1	; 0x21
    264e:	12 a2       	std	Z+34, r1	; 0x22
    2650:	13 a2       	std	Z+35, r1	; 0x23
    2652:	14 a2       	std	Z+36, r1	; 0x24
    2654:	15 a2       	std	Z+37, r1	; 0x25
    2656:	a2 01       	movw	r20, r4
    2658:	b4 01       	movw	r22, r8
    265a:	c6 01       	movw	r24, r12
    265c:	50 db       	rcall	.-2400   	; 0x1cfe <pxPortInitialiseStack>
    265e:	f3 01       	movw	r30, r6
    2660:	80 83       	st	Z, r24
    2662:	91 83       	std	Z+1, r25	; 0x01
    2664:	e1 14       	cp	r14, r1
    2666:	f1 04       	cpc	r15, r1
    2668:	19 f0       	breq	.+6      	; 0x2670 <xTaskGenericCreate+0xe2>
    266a:	f7 01       	movw	r30, r14
    266c:	60 82       	st	Z, r6
    266e:	71 82       	std	Z+1, r7	; 0x01
    2670:	0f b6       	in	r0, 0x3f	; 63
    2672:	f8 94       	cli
    2674:	0f 92       	push	r0
    2676:	80 91 4f 22 	lds	r24, 0x224F	; 0x80224f <uxCurrentNumberOfTasks>
    267a:	8f 5f       	subi	r24, 0xFF	; 255
    267c:	80 93 4f 22 	sts	0x224F, r24	; 0x80224f <uxCurrentNumberOfTasks>
    2680:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <pxCurrentTCB>
    2684:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2688:	89 2b       	or	r24, r25
    268a:	91 f5       	brne	.+100    	; 0x26f0 <xTaskGenericCreate+0x162>
    268c:	60 92 9c 22 	sts	0x229C, r6	; 0x80229c <pxCurrentTCB>
    2690:	70 92 9d 22 	sts	0x229D, r7	; 0x80229d <pxCurrentTCB+0x1>
    2694:	80 91 4f 22 	lds	r24, 0x224F	; 0x80224f <uxCurrentNumberOfTasks>
    2698:	81 30       	cpi	r24, 0x01	; 1
    269a:	c9 f5       	brne	.+114    	; 0x270e <xTaskGenericCreate+0x180>
    269c:	0f 2e       	mov	r0, r31
    269e:	ff e6       	ldi	r31, 0x6F	; 111
    26a0:	ef 2e       	mov	r14, r31
    26a2:	f2 e2       	ldi	r31, 0x22	; 34
    26a4:	ff 2e       	mov	r15, r31
    26a6:	f0 2d       	mov	r31, r0
    26a8:	0f 2e       	mov	r0, r31
    26aa:	fc e9       	ldi	r31, 0x9C	; 156
    26ac:	cf 2e       	mov	r12, r31
    26ae:	f2 e2       	ldi	r31, 0x22	; 34
    26b0:	df 2e       	mov	r13, r31
    26b2:	f0 2d       	mov	r31, r0
    26b4:	c7 01       	movw	r24, r14
    26b6:	99 da       	rcall	.-2766   	; 0x1bea <vListInitialise>
    26b8:	f9 e0       	ldi	r31, 0x09	; 9
    26ba:	ef 0e       	add	r14, r31
    26bc:	f1 1c       	adc	r15, r1
    26be:	ec 14       	cp	r14, r12
    26c0:	fd 04       	cpc	r15, r13
    26c2:	c1 f7       	brne	.-16     	; 0x26b4 <xTaskGenericCreate+0x126>
    26c4:	86 e6       	ldi	r24, 0x66	; 102
    26c6:	92 e2       	ldi	r25, 0x22	; 34
    26c8:	90 da       	rcall	.-2784   	; 0x1bea <vListInitialise>
    26ca:	8d e5       	ldi	r24, 0x5D	; 93
    26cc:	92 e2       	ldi	r25, 0x22	; 34
    26ce:	8d da       	rcall	.-2790   	; 0x1bea <vListInitialise>
    26d0:	80 e5       	ldi	r24, 0x50	; 80
    26d2:	92 e2       	ldi	r25, 0x22	; 34
    26d4:	8a da       	rcall	.-2796   	; 0x1bea <vListInitialise>
    26d6:	86 e6       	ldi	r24, 0x66	; 102
    26d8:	92 e2       	ldi	r25, 0x22	; 34
    26da:	80 93 5b 22 	sts	0x225B, r24	; 0x80225b <pxDelayedTaskList>
    26de:	90 93 5c 22 	sts	0x225C, r25	; 0x80225c <pxDelayedTaskList+0x1>
    26e2:	8d e5       	ldi	r24, 0x5D	; 93
    26e4:	92 e2       	ldi	r25, 0x22	; 34
    26e6:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <pxOverflowDelayedTaskList>
    26ea:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <pxOverflowDelayedTaskList+0x1>
    26ee:	0f c0       	rjmp	.+30     	; 0x270e <xTaskGenericCreate+0x180>
    26f0:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xSchedulerRunning>
    26f4:	81 11       	cpse	r24, r1
    26f6:	0b c0       	rjmp	.+22     	; 0x270e <xTaskGenericCreate+0x180>
    26f8:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    26fc:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2700:	86 89       	ldd	r24, Z+22	; 0x16
    2702:	08 17       	cp	r16, r24
    2704:	20 f0       	brcs	.+8      	; 0x270e <xTaskGenericCreate+0x180>
    2706:	60 92 9c 22 	sts	0x229C, r6	; 0x80229c <pxCurrentTCB>
    270a:	70 92 9d 22 	sts	0x229D, r7	; 0x80229d <pxCurrentTCB+0x1>
    270e:	80 91 47 22 	lds	r24, 0x2247	; 0x802247 <uxTaskNumber>
    2712:	8f 5f       	subi	r24, 0xFF	; 255
    2714:	80 93 47 22 	sts	0x2247, r24	; 0x802247 <uxTaskNumber>
    2718:	f3 01       	movw	r30, r6
    271a:	86 89       	ldd	r24, Z+22	; 0x16
    271c:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <uxTopReadyPriority>
    2720:	98 17       	cp	r25, r24
    2722:	10 f4       	brcc	.+4      	; 0x2728 <xTaskGenericCreate+0x19a>
    2724:	80 93 4c 22 	sts	0x224C, r24	; 0x80224c <uxTopReadyPriority>
    2728:	90 e0       	ldi	r25, 0x00	; 0
    272a:	9c 01       	movw	r18, r24
    272c:	22 0f       	add	r18, r18
    272e:	33 1f       	adc	r19, r19
    2730:	22 0f       	add	r18, r18
    2732:	33 1f       	adc	r19, r19
    2734:	22 0f       	add	r18, r18
    2736:	33 1f       	adc	r19, r19
    2738:	82 0f       	add	r24, r18
    273a:	93 1f       	adc	r25, r19
    273c:	be 01       	movw	r22, r28
    273e:	81 59       	subi	r24, 0x91	; 145
    2740:	9d 4d       	sbci	r25, 0xDD	; 221
    2742:	65 da       	rcall	.-2870   	; 0x1c0e <vListInsertEnd>
    2744:	0f 90       	pop	r0
    2746:	0f be       	out	0x3f, r0	; 63
    2748:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xSchedulerRunning>
    274c:	88 23       	and	r24, r24
    274e:	51 f0       	breq	.+20     	; 0x2764 <xTaskGenericCreate+0x1d6>
    2750:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    2754:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2758:	86 89       	ldd	r24, Z+22	; 0x16
    275a:	80 17       	cp	r24, r16
    275c:	28 f4       	brcc	.+10     	; 0x2768 <xTaskGenericCreate+0x1da>
    275e:	8b db       	rcall	.-2282   	; 0x1e76 <vPortYield>
    2760:	81 e0       	ldi	r24, 0x01	; 1
    2762:	05 c0       	rjmp	.+10     	; 0x276e <xTaskGenericCreate+0x1e0>
    2764:	81 e0       	ldi	r24, 0x01	; 1
    2766:	03 c0       	rjmp	.+6      	; 0x276e <xTaskGenericCreate+0x1e0>
    2768:	81 e0       	ldi	r24, 0x01	; 1
    276a:	01 c0       	rjmp	.+2      	; 0x276e <xTaskGenericCreate+0x1e0>
    276c:	8f ef       	ldi	r24, 0xFF	; 255
    276e:	df 91       	pop	r29
    2770:	cf 91       	pop	r28
    2772:	1f 91       	pop	r17
    2774:	0f 91       	pop	r16
    2776:	ff 90       	pop	r15
    2778:	ef 90       	pop	r14
    277a:	df 90       	pop	r13
    277c:	cf 90       	pop	r12
    277e:	bf 90       	pop	r11
    2780:	af 90       	pop	r10
    2782:	9f 90       	pop	r9
    2784:	8f 90       	pop	r8
    2786:	7f 90       	pop	r7
    2788:	6f 90       	pop	r6
    278a:	5f 90       	pop	r5
    278c:	4f 90       	pop	r4
    278e:	08 95       	ret

00002790 <vTaskStartScheduler>:
    2790:	af 92       	push	r10
    2792:	bf 92       	push	r11
    2794:	cf 92       	push	r12
    2796:	df 92       	push	r13
    2798:	ef 92       	push	r14
    279a:	ff 92       	push	r15
    279c:	0f 93       	push	r16
    279e:	a1 2c       	mov	r10, r1
    27a0:	b1 2c       	mov	r11, r1
    27a2:	c1 2c       	mov	r12, r1
    27a4:	d1 2c       	mov	r13, r1
    27a6:	e1 2c       	mov	r14, r1
    27a8:	f1 2c       	mov	r15, r1
    27aa:	00 e0       	ldi	r16, 0x00	; 0
    27ac:	20 e0       	ldi	r18, 0x00	; 0
    27ae:	30 e0       	ldi	r19, 0x00	; 0
    27b0:	45 e5       	ldi	r20, 0x55	; 85
    27b2:	50 e0       	ldi	r21, 0x00	; 0
    27b4:	68 e1       	ldi	r22, 0x18	; 24
    27b6:	70 e2       	ldi	r23, 0x20	; 32
    27b8:	8b e8       	ldi	r24, 0x8B	; 139
    27ba:	92 e1       	ldi	r25, 0x12	; 18
    27bc:	e8 de       	rcall	.-560    	; 0x258e <xTaskGenericCreate>
    27be:	81 30       	cpi	r24, 0x01	; 1
    27c0:	91 f4       	brne	.+36     	; 0x27e6 <vTaskStartScheduler+0x56>
    27c2:	20 d3       	rcall	.+1600   	; 0x2e04 <xTimerCreateTimerTask>
    27c4:	81 30       	cpi	r24, 0x01	; 1
    27c6:	79 f4       	brne	.+30     	; 0x27e6 <vTaskStartScheduler+0x56>
    27c8:	f8 94       	cli
    27ca:	8f ef       	ldi	r24, 0xFF	; 255
    27cc:	9f ef       	ldi	r25, 0xFF	; 255
    27ce:	80 93 45 22 	sts	0x2245, r24	; 0x802245 <xNextTaskUnblockTime>
    27d2:	90 93 46 22 	sts	0x2246, r25	; 0x802246 <xNextTaskUnblockTime+0x1>
    27d6:	81 e0       	ldi	r24, 0x01	; 1
    27d8:	80 93 4b 22 	sts	0x224B, r24	; 0x80224b <xSchedulerRunning>
    27dc:	10 92 4d 22 	sts	0x224D, r1	; 0x80224d <xTickCount>
    27e0:	10 92 4e 22 	sts	0x224E, r1	; 0x80224e <xTickCount+0x1>
    27e4:	03 db       	rcall	.-2554   	; 0x1dec <xPortStartScheduler>
    27e6:	0f 91       	pop	r16
    27e8:	ff 90       	pop	r15
    27ea:	ef 90       	pop	r14
    27ec:	df 90       	pop	r13
    27ee:	cf 90       	pop	r12
    27f0:	bf 90       	pop	r11
    27f2:	af 90       	pop	r10
    27f4:	08 95       	ret

000027f6 <vTaskSuspendAll>:
    27f6:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    27fa:	8f 5f       	subi	r24, 0xFF	; 255
    27fc:	80 93 44 22 	sts	0x2244, r24	; 0x802244 <uxSchedulerSuspended>
    2800:	08 95       	ret

00002802 <xTaskGetTickCount>:
    2802:	0f b6       	in	r0, 0x3f	; 63
    2804:	f8 94       	cli
    2806:	0f 92       	push	r0
    2808:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <xTickCount>
    280c:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <xTickCount+0x1>
    2810:	0f 90       	pop	r0
    2812:	0f be       	out	0x3f, r0	; 63
    2814:	08 95       	ret

00002816 <xTaskIncrementTick>:
    2816:	df 92       	push	r13
    2818:	ef 92       	push	r14
    281a:	ff 92       	push	r15
    281c:	0f 93       	push	r16
    281e:	1f 93       	push	r17
    2820:	cf 93       	push	r28
    2822:	df 93       	push	r29
    2824:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    2828:	81 11       	cpse	r24, r1
    282a:	b3 c0       	rjmp	.+358    	; 0x2992 <xTaskIncrementTick+0x17c>
    282c:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <xTickCount>
    2830:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <xTickCount+0x1>
    2834:	01 96       	adiw	r24, 0x01	; 1
    2836:	80 93 4d 22 	sts	0x224D, r24	; 0x80224d <xTickCount>
    283a:	90 93 4e 22 	sts	0x224E, r25	; 0x80224e <xTickCount+0x1>
    283e:	e0 90 4d 22 	lds	r14, 0x224D	; 0x80224d <xTickCount>
    2842:	f0 90 4e 22 	lds	r15, 0x224E	; 0x80224e <xTickCount+0x1>
    2846:	e1 14       	cp	r14, r1
    2848:	f1 04       	cpc	r15, r1
    284a:	99 f5       	brne	.+102    	; 0x28b2 <xTaskIncrementTick+0x9c>
    284c:	80 91 5b 22 	lds	r24, 0x225B	; 0x80225b <pxDelayedTaskList>
    2850:	90 91 5c 22 	lds	r25, 0x225C	; 0x80225c <pxDelayedTaskList+0x1>
    2854:	20 91 59 22 	lds	r18, 0x2259	; 0x802259 <pxOverflowDelayedTaskList>
    2858:	30 91 5a 22 	lds	r19, 0x225A	; 0x80225a <pxOverflowDelayedTaskList+0x1>
    285c:	20 93 5b 22 	sts	0x225B, r18	; 0x80225b <pxDelayedTaskList>
    2860:	30 93 5c 22 	sts	0x225C, r19	; 0x80225c <pxDelayedTaskList+0x1>
    2864:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <pxOverflowDelayedTaskList>
    2868:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <pxOverflowDelayedTaskList+0x1>
    286c:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <xNumOfOverflows>
    2870:	8f 5f       	subi	r24, 0xFF	; 255
    2872:	80 93 48 22 	sts	0x2248, r24	; 0x802248 <xNumOfOverflows>
    2876:	e0 91 5b 22 	lds	r30, 0x225B	; 0x80225b <pxDelayedTaskList>
    287a:	f0 91 5c 22 	lds	r31, 0x225C	; 0x80225c <pxDelayedTaskList+0x1>
    287e:	80 81       	ld	r24, Z
    2880:	81 11       	cpse	r24, r1
    2882:	07 c0       	rjmp	.+14     	; 0x2892 <xTaskIncrementTick+0x7c>
    2884:	8f ef       	ldi	r24, 0xFF	; 255
    2886:	9f ef       	ldi	r25, 0xFF	; 255
    2888:	80 93 45 22 	sts	0x2245, r24	; 0x802245 <xNextTaskUnblockTime>
    288c:	90 93 46 22 	sts	0x2246, r25	; 0x802246 <xNextTaskUnblockTime+0x1>
    2890:	10 c0       	rjmp	.+32     	; 0x28b2 <xTaskIncrementTick+0x9c>
    2892:	e0 91 5b 22 	lds	r30, 0x225B	; 0x80225b <pxDelayedTaskList>
    2896:	f0 91 5c 22 	lds	r31, 0x225C	; 0x80225c <pxDelayedTaskList+0x1>
    289a:	05 80       	ldd	r0, Z+5	; 0x05
    289c:	f6 81       	ldd	r31, Z+6	; 0x06
    289e:	e0 2d       	mov	r30, r0
    28a0:	06 80       	ldd	r0, Z+6	; 0x06
    28a2:	f7 81       	ldd	r31, Z+7	; 0x07
    28a4:	e0 2d       	mov	r30, r0
    28a6:	82 81       	ldd	r24, Z+2	; 0x02
    28a8:	93 81       	ldd	r25, Z+3	; 0x03
    28aa:	80 93 45 22 	sts	0x2245, r24	; 0x802245 <xNextTaskUnblockTime>
    28ae:	90 93 46 22 	sts	0x2246, r25	; 0x802246 <xNextTaskUnblockTime+0x1>
    28b2:	80 91 45 22 	lds	r24, 0x2245	; 0x802245 <xNextTaskUnblockTime>
    28b6:	90 91 46 22 	lds	r25, 0x2246	; 0x802246 <xNextTaskUnblockTime+0x1>
    28ba:	e8 16       	cp	r14, r24
    28bc:	f9 06       	cpc	r15, r25
    28be:	10 f4       	brcc	.+4      	; 0x28c4 <xTaskIncrementTick+0xae>
    28c0:	d1 2c       	mov	r13, r1
    28c2:	4f c0       	rjmp	.+158    	; 0x2962 <xTaskIncrementTick+0x14c>
    28c4:	d1 2c       	mov	r13, r1
    28c6:	e0 91 5b 22 	lds	r30, 0x225B	; 0x80225b <pxDelayedTaskList>
    28ca:	f0 91 5c 22 	lds	r31, 0x225C	; 0x80225c <pxDelayedTaskList+0x1>
    28ce:	80 81       	ld	r24, Z
    28d0:	81 11       	cpse	r24, r1
    28d2:	07 c0       	rjmp	.+14     	; 0x28e2 <xTaskIncrementTick+0xcc>
    28d4:	8f ef       	ldi	r24, 0xFF	; 255
    28d6:	9f ef       	ldi	r25, 0xFF	; 255
    28d8:	80 93 45 22 	sts	0x2245, r24	; 0x802245 <xNextTaskUnblockTime>
    28dc:	90 93 46 22 	sts	0x2246, r25	; 0x802246 <xNextTaskUnblockTime+0x1>
    28e0:	40 c0       	rjmp	.+128    	; 0x2962 <xTaskIncrementTick+0x14c>
    28e2:	e0 91 5b 22 	lds	r30, 0x225B	; 0x80225b <pxDelayedTaskList>
    28e6:	f0 91 5c 22 	lds	r31, 0x225C	; 0x80225c <pxDelayedTaskList+0x1>
    28ea:	05 80       	ldd	r0, Z+5	; 0x05
    28ec:	f6 81       	ldd	r31, Z+6	; 0x06
    28ee:	e0 2d       	mov	r30, r0
    28f0:	c6 81       	ldd	r28, Z+6	; 0x06
    28f2:	d7 81       	ldd	r29, Z+7	; 0x07
    28f4:	8a 81       	ldd	r24, Y+2	; 0x02
    28f6:	9b 81       	ldd	r25, Y+3	; 0x03
    28f8:	e8 16       	cp	r14, r24
    28fa:	f9 06       	cpc	r15, r25
    28fc:	28 f4       	brcc	.+10     	; 0x2908 <xTaskIncrementTick+0xf2>
    28fe:	80 93 45 22 	sts	0x2245, r24	; 0x802245 <xNextTaskUnblockTime>
    2902:	90 93 46 22 	sts	0x2246, r25	; 0x802246 <xNextTaskUnblockTime+0x1>
    2906:	2d c0       	rjmp	.+90     	; 0x2962 <xTaskIncrementTick+0x14c>
    2908:	8e 01       	movw	r16, r28
    290a:	0e 5f       	subi	r16, 0xFE	; 254
    290c:	1f 4f       	sbci	r17, 0xFF	; 255
    290e:	c8 01       	movw	r24, r16
    2910:	d0 d9       	rcall	.-3168   	; 0x1cb2 <uxListRemove>
    2912:	8c 89       	ldd	r24, Y+20	; 0x14
    2914:	9d 89       	ldd	r25, Y+21	; 0x15
    2916:	89 2b       	or	r24, r25
    2918:	19 f0       	breq	.+6      	; 0x2920 <xTaskIncrementTick+0x10a>
    291a:	ce 01       	movw	r24, r28
    291c:	0c 96       	adiw	r24, 0x0c	; 12
    291e:	c9 d9       	rcall	.-3182   	; 0x1cb2 <uxListRemove>
    2920:	8e 89       	ldd	r24, Y+22	; 0x16
    2922:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <uxTopReadyPriority>
    2926:	98 17       	cp	r25, r24
    2928:	10 f4       	brcc	.+4      	; 0x292e <xTaskIncrementTick+0x118>
    292a:	80 93 4c 22 	sts	0x224C, r24	; 0x80224c <uxTopReadyPriority>
    292e:	90 e0       	ldi	r25, 0x00	; 0
    2930:	9c 01       	movw	r18, r24
    2932:	22 0f       	add	r18, r18
    2934:	33 1f       	adc	r19, r19
    2936:	22 0f       	add	r18, r18
    2938:	33 1f       	adc	r19, r19
    293a:	22 0f       	add	r18, r18
    293c:	33 1f       	adc	r19, r19
    293e:	82 0f       	add	r24, r18
    2940:	93 1f       	adc	r25, r19
    2942:	b8 01       	movw	r22, r16
    2944:	81 59       	subi	r24, 0x91	; 145
    2946:	9d 4d       	sbci	r25, 0xDD	; 221
    2948:	62 d9       	rcall	.-3388   	; 0x1c0e <vListInsertEnd>
    294a:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    294e:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2952:	9e 89       	ldd	r25, Y+22	; 0x16
    2954:	86 89       	ldd	r24, Z+22	; 0x16
    2956:	98 17       	cp	r25, r24
    2958:	08 f4       	brcc	.+2      	; 0x295c <xTaskIncrementTick+0x146>
    295a:	b5 cf       	rjmp	.-150    	; 0x28c6 <xTaskIncrementTick+0xb0>
    295c:	dd 24       	eor	r13, r13
    295e:	d3 94       	inc	r13
    2960:	b2 cf       	rjmp	.-156    	; 0x28c6 <xTaskIncrementTick+0xb0>
    2962:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    2966:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    296a:	86 89       	ldd	r24, Z+22	; 0x16
    296c:	90 e0       	ldi	r25, 0x00	; 0
    296e:	fc 01       	movw	r30, r24
    2970:	ee 0f       	add	r30, r30
    2972:	ff 1f       	adc	r31, r31
    2974:	ee 0f       	add	r30, r30
    2976:	ff 1f       	adc	r31, r31
    2978:	ee 0f       	add	r30, r30
    297a:	ff 1f       	adc	r31, r31
    297c:	8e 0f       	add	r24, r30
    297e:	9f 1f       	adc	r25, r31
    2980:	fc 01       	movw	r30, r24
    2982:	e1 59       	subi	r30, 0x91	; 145
    2984:	fd 4d       	sbci	r31, 0xDD	; 221
    2986:	80 81       	ld	r24, Z
    2988:	82 30       	cpi	r24, 0x02	; 2
    298a:	48 f0       	brcs	.+18     	; 0x299e <xTaskIncrementTick+0x188>
    298c:	dd 24       	eor	r13, r13
    298e:	d3 94       	inc	r13
    2990:	06 c0       	rjmp	.+12     	; 0x299e <xTaskIncrementTick+0x188>
    2992:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxPendedTicks>
    2996:	8f 5f       	subi	r24, 0xFF	; 255
    2998:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxPendedTicks>
    299c:	d1 2c       	mov	r13, r1
    299e:	80 91 49 22 	lds	r24, 0x2249	; 0x802249 <xYieldPending>
    29a2:	88 23       	and	r24, r24
    29a4:	11 f0       	breq	.+4      	; 0x29aa <xTaskIncrementTick+0x194>
    29a6:	dd 24       	eor	r13, r13
    29a8:	d3 94       	inc	r13
    29aa:	8d 2d       	mov	r24, r13
    29ac:	df 91       	pop	r29
    29ae:	cf 91       	pop	r28
    29b0:	1f 91       	pop	r17
    29b2:	0f 91       	pop	r16
    29b4:	ff 90       	pop	r15
    29b6:	ef 90       	pop	r14
    29b8:	df 90       	pop	r13
    29ba:	08 95       	ret

000029bc <xTaskResumeAll>:
    29bc:	df 92       	push	r13
    29be:	ef 92       	push	r14
    29c0:	ff 92       	push	r15
    29c2:	0f 93       	push	r16
    29c4:	1f 93       	push	r17
    29c6:	cf 93       	push	r28
    29c8:	df 93       	push	r29
    29ca:	0f b6       	in	r0, 0x3f	; 63
    29cc:	f8 94       	cli
    29ce:	0f 92       	push	r0
    29d0:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    29d4:	81 50       	subi	r24, 0x01	; 1
    29d6:	80 93 44 22 	sts	0x2244, r24	; 0x802244 <uxSchedulerSuspended>
    29da:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    29de:	81 11       	cpse	r24, r1
    29e0:	5d c0       	rjmp	.+186    	; 0x2a9c <xTaskResumeAll+0xe0>
    29e2:	80 91 4f 22 	lds	r24, 0x224F	; 0x80224f <uxCurrentNumberOfTasks>
    29e6:	81 11       	cpse	r24, r1
    29e8:	30 c0       	rjmp	.+96     	; 0x2a4a <xTaskResumeAll+0x8e>
    29ea:	5b c0       	rjmp	.+182    	; 0x2aa2 <xTaskResumeAll+0xe6>
    29ec:	d7 01       	movw	r26, r14
    29ee:	15 96       	adiw	r26, 0x05	; 5
    29f0:	ed 91       	ld	r30, X+
    29f2:	fc 91       	ld	r31, X
    29f4:	16 97       	sbiw	r26, 0x06	; 6
    29f6:	c6 81       	ldd	r28, Z+6	; 0x06
    29f8:	d7 81       	ldd	r29, Z+7	; 0x07
    29fa:	ce 01       	movw	r24, r28
    29fc:	0c 96       	adiw	r24, 0x0c	; 12
    29fe:	59 d9       	rcall	.-3406   	; 0x1cb2 <uxListRemove>
    2a00:	8e 01       	movw	r16, r28
    2a02:	0e 5f       	subi	r16, 0xFE	; 254
    2a04:	1f 4f       	sbci	r17, 0xFF	; 255
    2a06:	c8 01       	movw	r24, r16
    2a08:	54 d9       	rcall	.-3416   	; 0x1cb2 <uxListRemove>
    2a0a:	8e 89       	ldd	r24, Y+22	; 0x16
    2a0c:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <uxTopReadyPriority>
    2a10:	98 17       	cp	r25, r24
    2a12:	10 f4       	brcc	.+4      	; 0x2a18 <xTaskResumeAll+0x5c>
    2a14:	80 93 4c 22 	sts	0x224C, r24	; 0x80224c <uxTopReadyPriority>
    2a18:	90 e0       	ldi	r25, 0x00	; 0
    2a1a:	9c 01       	movw	r18, r24
    2a1c:	22 0f       	add	r18, r18
    2a1e:	33 1f       	adc	r19, r19
    2a20:	22 0f       	add	r18, r18
    2a22:	33 1f       	adc	r19, r19
    2a24:	22 0f       	add	r18, r18
    2a26:	33 1f       	adc	r19, r19
    2a28:	82 0f       	add	r24, r18
    2a2a:	93 1f       	adc	r25, r19
    2a2c:	b8 01       	movw	r22, r16
    2a2e:	81 59       	subi	r24, 0x91	; 145
    2a30:	9d 4d       	sbci	r25, 0xDD	; 221
    2a32:	ed d8       	rcall	.-3622   	; 0x1c0e <vListInsertEnd>
    2a34:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    2a38:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2a3c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a3e:	86 89       	ldd	r24, Z+22	; 0x16
    2a40:	98 17       	cp	r25, r24
    2a42:	58 f0       	brcs	.+22     	; 0x2a5a <xTaskResumeAll+0x9e>
    2a44:	d0 92 49 22 	sts	0x2249, r13	; 0x802249 <xYieldPending>
    2a48:	08 c0       	rjmp	.+16     	; 0x2a5a <xTaskResumeAll+0x9e>
    2a4a:	0f 2e       	mov	r0, r31
    2a4c:	f0 e5       	ldi	r31, 0x50	; 80
    2a4e:	ef 2e       	mov	r14, r31
    2a50:	f2 e2       	ldi	r31, 0x22	; 34
    2a52:	ff 2e       	mov	r15, r31
    2a54:	f0 2d       	mov	r31, r0
    2a56:	dd 24       	eor	r13, r13
    2a58:	d3 94       	inc	r13
    2a5a:	f7 01       	movw	r30, r14
    2a5c:	80 81       	ld	r24, Z
    2a5e:	81 11       	cpse	r24, r1
    2a60:	c5 cf       	rjmp	.-118    	; 0x29ec <xTaskResumeAll+0x30>
    2a62:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxPendedTicks>
    2a66:	88 23       	and	r24, r24
    2a68:	91 f0       	breq	.+36     	; 0x2a8e <xTaskResumeAll+0xd2>
    2a6a:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxPendedTicks>
    2a6e:	88 23       	and	r24, r24
    2a70:	71 f0       	breq	.+28     	; 0x2a8e <xTaskResumeAll+0xd2>
    2a72:	c1 e0       	ldi	r28, 0x01	; 1
    2a74:	d0 de       	rcall	.-608    	; 0x2816 <xTaskIncrementTick>
    2a76:	81 11       	cpse	r24, r1
    2a78:	c0 93 49 22 	sts	0x2249, r28	; 0x802249 <xYieldPending>
    2a7c:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxPendedTicks>
    2a80:	81 50       	subi	r24, 0x01	; 1
    2a82:	80 93 4a 22 	sts	0x224A, r24	; 0x80224a <uxPendedTicks>
    2a86:	80 91 4a 22 	lds	r24, 0x224A	; 0x80224a <uxPendedTicks>
    2a8a:	81 11       	cpse	r24, r1
    2a8c:	f3 cf       	rjmp	.-26     	; 0x2a74 <xTaskResumeAll+0xb8>
    2a8e:	80 91 49 22 	lds	r24, 0x2249	; 0x802249 <xYieldPending>
    2a92:	81 30       	cpi	r24, 0x01	; 1
    2a94:	29 f4       	brne	.+10     	; 0x2aa0 <xTaskResumeAll+0xe4>
    2a96:	ef d9       	rcall	.-3106   	; 0x1e76 <vPortYield>
    2a98:	81 e0       	ldi	r24, 0x01	; 1
    2a9a:	03 c0       	rjmp	.+6      	; 0x2aa2 <xTaskResumeAll+0xe6>
    2a9c:	80 e0       	ldi	r24, 0x00	; 0
    2a9e:	01 c0       	rjmp	.+2      	; 0x2aa2 <xTaskResumeAll+0xe6>
    2aa0:	80 e0       	ldi	r24, 0x00	; 0
    2aa2:	0f 90       	pop	r0
    2aa4:	0f be       	out	0x3f, r0	; 63
    2aa6:	df 91       	pop	r29
    2aa8:	cf 91       	pop	r28
    2aaa:	1f 91       	pop	r17
    2aac:	0f 91       	pop	r16
    2aae:	ff 90       	pop	r15
    2ab0:	ef 90       	pop	r14
    2ab2:	df 90       	pop	r13
    2ab4:	08 95       	ret

00002ab6 <vTaskDelay>:
    2ab6:	cf 93       	push	r28
    2ab8:	df 93       	push	r29
    2aba:	ec 01       	movw	r28, r24
    2abc:	89 2b       	or	r24, r25
    2abe:	91 f0       	breq	.+36     	; 0x2ae4 <vTaskDelay+0x2e>
    2ac0:	9a de       	rcall	.-716    	; 0x27f6 <vTaskSuspendAll>
    2ac2:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <xTickCount>
    2ac6:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <xTickCount+0x1>
    2aca:	c8 0f       	add	r28, r24
    2acc:	d9 1f       	adc	r29, r25
    2ace:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <pxCurrentTCB>
    2ad2:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2ad6:	02 96       	adiw	r24, 0x02	; 2
    2ad8:	ec d8       	rcall	.-3624   	; 0x1cb2 <uxListRemove>
    2ada:	ce 01       	movw	r24, r28
    2adc:	23 dd       	rcall	.-1466   	; 0x2524 <prvAddCurrentTaskToDelayedList>
    2ade:	6e df       	rcall	.-292    	; 0x29bc <xTaskResumeAll>
    2ae0:	81 11       	cpse	r24, r1
    2ae2:	01 c0       	rjmp	.+2      	; 0x2ae6 <vTaskDelay+0x30>
    2ae4:	c8 d9       	rcall	.-3184   	; 0x1e76 <vPortYield>
    2ae6:	df 91       	pop	r29
    2ae8:	cf 91       	pop	r28
    2aea:	08 95       	ret

00002aec <vTaskSwitchContext>:
    2aec:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    2af0:	88 23       	and	r24, r24
    2af2:	21 f0       	breq	.+8      	; 0x2afc <vTaskSwitchContext+0x10>
    2af4:	81 e0       	ldi	r24, 0x01	; 1
    2af6:	80 93 49 22 	sts	0x2249, r24	; 0x802249 <xYieldPending>
    2afa:	08 95       	ret
    2afc:	10 92 49 22 	sts	0x2249, r1	; 0x802249 <xYieldPending>
    2b00:	80 91 4c 22 	lds	r24, 0x224C	; 0x80224c <uxTopReadyPriority>
    2b04:	90 e0       	ldi	r25, 0x00	; 0
    2b06:	fc 01       	movw	r30, r24
    2b08:	ee 0f       	add	r30, r30
    2b0a:	ff 1f       	adc	r31, r31
    2b0c:	ee 0f       	add	r30, r30
    2b0e:	ff 1f       	adc	r31, r31
    2b10:	ee 0f       	add	r30, r30
    2b12:	ff 1f       	adc	r31, r31
    2b14:	8e 0f       	add	r24, r30
    2b16:	9f 1f       	adc	r25, r31
    2b18:	fc 01       	movw	r30, r24
    2b1a:	e1 59       	subi	r30, 0x91	; 145
    2b1c:	fd 4d       	sbci	r31, 0xDD	; 221
    2b1e:	80 81       	ld	r24, Z
    2b20:	81 11       	cpse	r24, r1
    2b22:	17 c0       	rjmp	.+46     	; 0x2b52 <vTaskSwitchContext+0x66>
    2b24:	80 91 4c 22 	lds	r24, 0x224C	; 0x80224c <uxTopReadyPriority>
    2b28:	81 50       	subi	r24, 0x01	; 1
    2b2a:	80 93 4c 22 	sts	0x224C, r24	; 0x80224c <uxTopReadyPriority>
    2b2e:	80 91 4c 22 	lds	r24, 0x224C	; 0x80224c <uxTopReadyPriority>
    2b32:	90 e0       	ldi	r25, 0x00	; 0
    2b34:	fc 01       	movw	r30, r24
    2b36:	ee 0f       	add	r30, r30
    2b38:	ff 1f       	adc	r31, r31
    2b3a:	ee 0f       	add	r30, r30
    2b3c:	ff 1f       	adc	r31, r31
    2b3e:	ee 0f       	add	r30, r30
    2b40:	ff 1f       	adc	r31, r31
    2b42:	8e 0f       	add	r24, r30
    2b44:	9f 1f       	adc	r25, r31
    2b46:	fc 01       	movw	r30, r24
    2b48:	e1 59       	subi	r30, 0x91	; 145
    2b4a:	fd 4d       	sbci	r31, 0xDD	; 221
    2b4c:	80 81       	ld	r24, Z
    2b4e:	88 23       	and	r24, r24
    2b50:	49 f3       	breq	.-46     	; 0x2b24 <vTaskSwitchContext+0x38>
    2b52:	80 91 4c 22 	lds	r24, 0x224C	; 0x80224c <uxTopReadyPriority>
    2b56:	90 e0       	ldi	r25, 0x00	; 0
    2b58:	9c 01       	movw	r18, r24
    2b5a:	22 0f       	add	r18, r18
    2b5c:	33 1f       	adc	r19, r19
    2b5e:	22 0f       	add	r18, r18
    2b60:	33 1f       	adc	r19, r19
    2b62:	22 0f       	add	r18, r18
    2b64:	33 1f       	adc	r19, r19
    2b66:	28 0f       	add	r18, r24
    2b68:	39 1f       	adc	r19, r25
    2b6a:	d9 01       	movw	r26, r18
    2b6c:	a1 59       	subi	r26, 0x91	; 145
    2b6e:	bd 4d       	sbci	r27, 0xDD	; 221
    2b70:	11 96       	adiw	r26, 0x01	; 1
    2b72:	ed 91       	ld	r30, X+
    2b74:	fc 91       	ld	r31, X
    2b76:	12 97       	sbiw	r26, 0x02	; 2
    2b78:	02 80       	ldd	r0, Z+2	; 0x02
    2b7a:	f3 81       	ldd	r31, Z+3	; 0x03
    2b7c:	e0 2d       	mov	r30, r0
    2b7e:	11 96       	adiw	r26, 0x01	; 1
    2b80:	ed 93       	st	X+, r30
    2b82:	fc 93       	st	X, r31
    2b84:	12 97       	sbiw	r26, 0x02	; 2
    2b86:	2e 58       	subi	r18, 0x8E	; 142
    2b88:	3d 4d       	sbci	r19, 0xDD	; 221
    2b8a:	e2 17       	cp	r30, r18
    2b8c:	f3 07       	cpc	r31, r19
    2b8e:	29 f4       	brne	.+10     	; 0x2b9a <vTaskSwitchContext+0xae>
    2b90:	22 81       	ldd	r18, Z+2	; 0x02
    2b92:	33 81       	ldd	r19, Z+3	; 0x03
    2b94:	fd 01       	movw	r30, r26
    2b96:	21 83       	std	Z+1, r18	; 0x01
    2b98:	32 83       	std	Z+2, r19	; 0x02
    2b9a:	fc 01       	movw	r30, r24
    2b9c:	ee 0f       	add	r30, r30
    2b9e:	ff 1f       	adc	r31, r31
    2ba0:	ee 0f       	add	r30, r30
    2ba2:	ff 1f       	adc	r31, r31
    2ba4:	ee 0f       	add	r30, r30
    2ba6:	ff 1f       	adc	r31, r31
    2ba8:	8e 0f       	add	r24, r30
    2baa:	9f 1f       	adc	r25, r31
    2bac:	fc 01       	movw	r30, r24
    2bae:	e1 59       	subi	r30, 0x91	; 145
    2bb0:	fd 4d       	sbci	r31, 0xDD	; 221
    2bb2:	01 80       	ldd	r0, Z+1	; 0x01
    2bb4:	f2 81       	ldd	r31, Z+2	; 0x02
    2bb6:	e0 2d       	mov	r30, r0
    2bb8:	86 81       	ldd	r24, Z+6	; 0x06
    2bba:	97 81       	ldd	r25, Z+7	; 0x07
    2bbc:	80 93 9c 22 	sts	0x229C, r24	; 0x80229c <pxCurrentTCB>
    2bc0:	90 93 9d 22 	sts	0x229D, r25	; 0x80229d <pxCurrentTCB+0x1>
    2bc4:	08 95       	ret

00002bc6 <vTaskPlaceOnEventList>:
    2bc6:	cf 93       	push	r28
    2bc8:	df 93       	push	r29
    2bca:	eb 01       	movw	r28, r22
    2bcc:	60 91 9c 22 	lds	r22, 0x229C	; 0x80229c <pxCurrentTCB>
    2bd0:	70 91 9d 22 	lds	r23, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2bd4:	64 5f       	subi	r22, 0xF4	; 244
    2bd6:	7f 4f       	sbci	r23, 0xFF	; 255
    2bd8:	3b d8       	rcall	.-3978   	; 0x1c50 <vListInsert>
    2bda:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <pxCurrentTCB>
    2bde:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2be2:	02 96       	adiw	r24, 0x02	; 2
    2be4:	66 d8       	rcall	.-3892   	; 0x1cb2 <uxListRemove>
    2be6:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <xTickCount>
    2bea:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <xTickCount+0x1>
    2bee:	8c 0f       	add	r24, r28
    2bf0:	9d 1f       	adc	r25, r29
    2bf2:	98 dc       	rcall	.-1744   	; 0x2524 <prvAddCurrentTaskToDelayedList>
    2bf4:	df 91       	pop	r29
    2bf6:	cf 91       	pop	r28
    2bf8:	08 95       	ret

00002bfa <vTaskPlaceOnEventListRestricted>:
    2bfa:	cf 93       	push	r28
    2bfc:	df 93       	push	r29
    2bfe:	eb 01       	movw	r28, r22
    2c00:	60 91 9c 22 	lds	r22, 0x229C	; 0x80229c <pxCurrentTCB>
    2c04:	70 91 9d 22 	lds	r23, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2c08:	64 5f       	subi	r22, 0xF4	; 244
    2c0a:	7f 4f       	sbci	r23, 0xFF	; 255
    2c0c:	00 d8       	rcall	.-4096   	; 0x1c0e <vListInsertEnd>
    2c0e:	80 91 9c 22 	lds	r24, 0x229C	; 0x80229c <pxCurrentTCB>
    2c12:	90 91 9d 22 	lds	r25, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2c16:	02 96       	adiw	r24, 0x02	; 2
    2c18:	4c d8       	rcall	.-3944   	; 0x1cb2 <uxListRemove>
    2c1a:	80 91 4d 22 	lds	r24, 0x224D	; 0x80224d <xTickCount>
    2c1e:	90 91 4e 22 	lds	r25, 0x224E	; 0x80224e <xTickCount+0x1>
    2c22:	8c 0f       	add	r24, r28
    2c24:	9d 1f       	adc	r25, r29
    2c26:	7e dc       	rcall	.-1796   	; 0x2524 <prvAddCurrentTaskToDelayedList>
    2c28:	df 91       	pop	r29
    2c2a:	cf 91       	pop	r28
    2c2c:	08 95       	ret

00002c2e <xTaskRemoveFromEventList>:
    2c2e:	0f 93       	push	r16
    2c30:	1f 93       	push	r17
    2c32:	cf 93       	push	r28
    2c34:	df 93       	push	r29
    2c36:	dc 01       	movw	r26, r24
    2c38:	15 96       	adiw	r26, 0x05	; 5
    2c3a:	ed 91       	ld	r30, X+
    2c3c:	fc 91       	ld	r31, X
    2c3e:	16 97       	sbiw	r26, 0x06	; 6
    2c40:	c6 81       	ldd	r28, Z+6	; 0x06
    2c42:	d7 81       	ldd	r29, Z+7	; 0x07
    2c44:	8e 01       	movw	r16, r28
    2c46:	04 5f       	subi	r16, 0xF4	; 244
    2c48:	1f 4f       	sbci	r17, 0xFF	; 255
    2c4a:	c8 01       	movw	r24, r16
    2c4c:	32 d8       	rcall	.-3996   	; 0x1cb2 <uxListRemove>
    2c4e:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    2c52:	81 11       	cpse	r24, r1
    2c54:	1b c0       	rjmp	.+54     	; 0x2c8c <xTaskRemoveFromEventList+0x5e>
    2c56:	0a 50       	subi	r16, 0x0A	; 10
    2c58:	11 09       	sbc	r17, r1
    2c5a:	c8 01       	movw	r24, r16
    2c5c:	2a d8       	rcall	.-4012   	; 0x1cb2 <uxListRemove>
    2c5e:	8e 89       	ldd	r24, Y+22	; 0x16
    2c60:	90 91 4c 22 	lds	r25, 0x224C	; 0x80224c <uxTopReadyPriority>
    2c64:	98 17       	cp	r25, r24
    2c66:	10 f4       	brcc	.+4      	; 0x2c6c <xTaskRemoveFromEventList+0x3e>
    2c68:	80 93 4c 22 	sts	0x224C, r24	; 0x80224c <uxTopReadyPriority>
    2c6c:	90 e0       	ldi	r25, 0x00	; 0
    2c6e:	9c 01       	movw	r18, r24
    2c70:	22 0f       	add	r18, r18
    2c72:	33 1f       	adc	r19, r19
    2c74:	22 0f       	add	r18, r18
    2c76:	33 1f       	adc	r19, r19
    2c78:	22 0f       	add	r18, r18
    2c7a:	33 1f       	adc	r19, r19
    2c7c:	82 0f       	add	r24, r18
    2c7e:	93 1f       	adc	r25, r19
    2c80:	b8 01       	movw	r22, r16
    2c82:	81 59       	subi	r24, 0x91	; 145
    2c84:	9d 4d       	sbci	r25, 0xDD	; 221
    2c86:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <vListInsertEnd>
    2c8a:	05 c0       	rjmp	.+10     	; 0x2c96 <xTaskRemoveFromEventList+0x68>
    2c8c:	b8 01       	movw	r22, r16
    2c8e:	80 e5       	ldi	r24, 0x50	; 80
    2c90:	92 e2       	ldi	r25, 0x22	; 34
    2c92:	0e 94 07 0e 	call	0x1c0e	; 0x1c0e <vListInsertEnd>
    2c96:	e0 91 9c 22 	lds	r30, 0x229C	; 0x80229c <pxCurrentTCB>
    2c9a:	f0 91 9d 22 	lds	r31, 0x229D	; 0x80229d <pxCurrentTCB+0x1>
    2c9e:	9e 89       	ldd	r25, Y+22	; 0x16
    2ca0:	86 89       	ldd	r24, Z+22	; 0x16
    2ca2:	89 17       	cp	r24, r25
    2ca4:	20 f4       	brcc	.+8      	; 0x2cae <xTaskRemoveFromEventList+0x80>
    2ca6:	81 e0       	ldi	r24, 0x01	; 1
    2ca8:	80 93 49 22 	sts	0x2249, r24	; 0x802249 <xYieldPending>
    2cac:	01 c0       	rjmp	.+2      	; 0x2cb0 <xTaskRemoveFromEventList+0x82>
    2cae:	80 e0       	ldi	r24, 0x00	; 0
    2cb0:	df 91       	pop	r29
    2cb2:	cf 91       	pop	r28
    2cb4:	1f 91       	pop	r17
    2cb6:	0f 91       	pop	r16
    2cb8:	08 95       	ret

00002cba <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2cba:	20 91 48 22 	lds	r18, 0x2248	; 0x802248 <xNumOfOverflows>
    2cbe:	fc 01       	movw	r30, r24
    2cc0:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2cc2:	20 91 4d 22 	lds	r18, 0x224D	; 0x80224d <xTickCount>
    2cc6:	30 91 4e 22 	lds	r19, 0x224E	; 0x80224e <xTickCount+0x1>
    2cca:	21 83       	std	Z+1, r18	; 0x01
    2ccc:	32 83       	std	Z+2, r19	; 0x02
    2cce:	08 95       	ret

00002cd0 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2cd0:	cf 93       	push	r28
    2cd2:	df 93       	push	r29
    2cd4:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2cd6:	0f b6       	in	r0, 0x3f	; 63
    2cd8:	f8 94       	cli
    2cda:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2cdc:	20 91 4d 22 	lds	r18, 0x224D	; 0x80224d <xTickCount>
    2ce0:	30 91 4e 22 	lds	r19, 0x224E	; 0x80224e <xTickCount+0x1>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2ce4:	80 91 48 22 	lds	r24, 0x2248	; 0x802248 <xNumOfOverflows>
    2ce8:	90 81       	ld	r25, Z
    2cea:	98 17       	cp	r25, r24
    2cec:	29 f0       	breq	.+10     	; 0x2cf8 <xTaskCheckForTimeOut+0x28>
    2cee:	81 81       	ldd	r24, Z+1	; 0x01
    2cf0:	92 81       	ldd	r25, Z+2	; 0x02
    2cf2:	28 17       	cp	r18, r24
    2cf4:	39 07       	cpc	r19, r25
    2cf6:	a8 f4       	brcc	.+42     	; 0x2d22 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    2cf8:	a1 81       	ldd	r26, Z+1	; 0x01
    2cfa:	b2 81       	ldd	r27, Z+2	; 0x02
    2cfc:	eb 01       	movw	r28, r22
    2cfe:	48 81       	ld	r20, Y
    2d00:	59 81       	ldd	r21, Y+1	; 0x01
    2d02:	c9 01       	movw	r24, r18
    2d04:	8a 1b       	sub	r24, r26
    2d06:	9b 0b       	sbc	r25, r27
    2d08:	84 17       	cp	r24, r20
    2d0a:	95 07       	cpc	r25, r21
    2d0c:	60 f4       	brcc	.+24     	; 0x2d26 <xTaskCheckForTimeOut+0x56>
    2d0e:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2d10:	a2 1b       	sub	r26, r18
    2d12:	b3 0b       	sbc	r27, r19
    2d14:	4a 0f       	add	r20, r26
    2d16:	5b 1f       	adc	r21, r27
    2d18:	48 83       	st	Y, r20
			vTaskSetTimeOutState( pxTimeOut );
    2d1a:	59 83       	std	Y+1, r21	; 0x01
			xReturn = pdFALSE;
    2d1c:	ce df       	rcall	.-100    	; 0x2cba <vTaskSetTimeOutState>
    2d1e:	80 e0       	ldi	r24, 0x00	; 0
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2d20:	03 c0       	rjmp	.+6      	; 0x2d28 <xTaskCheckForTimeOut+0x58>
    2d22:	81 e0       	ldi	r24, 0x01	; 1
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    2d24:	01 c0       	rjmp	.+2      	; 0x2d28 <xTaskCheckForTimeOut+0x58>
		}
	}
	taskEXIT_CRITICAL();
    2d26:	81 e0       	ldi	r24, 0x01	; 1
    2d28:	0f 90       	pop	r0

	return xReturn;
}
    2d2a:	0f be       	out	0x3f, r0	; 63
    2d2c:	df 91       	pop	r29
    2d2e:	cf 91       	pop	r28
    2d30:	08 95       	ret

00002d32 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2d32:	81 e0       	ldi	r24, 0x01	; 1
    2d34:	80 93 49 22 	sts	0x2249, r24	; 0x802249 <xYieldPending>
    2d38:	08 95       	ret

00002d3a <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    2d3a:	80 91 4b 22 	lds	r24, 0x224B	; 0x80224b <xSchedulerRunning>
    2d3e:	88 23       	and	r24, r24
    2d40:	31 f0       	breq	.+12     	; 0x2d4e <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2d42:	80 91 44 22 	lds	r24, 0x2244	; 0x802244 <uxSchedulerSuspended>
    2d46:	88 23       	and	r24, r24
    2d48:	21 f0       	breq	.+8      	; 0x2d52 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    2d4a:	80 e0       	ldi	r24, 0x00	; 0
    2d4c:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2d4e:	81 e0       	ldi	r24, 0x01	; 1
    2d50:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2d52:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2d54:	08 95       	ret

00002d56 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2d56:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2d58:	62 83       	std	Z+2, r22	; 0x02
    2d5a:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2d5c:	80 87       	std	Z+8, r24	; 0x08
    2d5e:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    2d60:	46 17       	cp	r20, r22
    2d62:	57 07       	cpc	r21, r23
    2d64:	90 f0       	brcs	.+36     	; 0x2d8a <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    2d66:	42 1b       	sub	r20, r18
    2d68:	53 0b       	sbc	r21, r19
    2d6a:	84 85       	ldd	r24, Z+12	; 0x0c
    2d6c:	95 85       	ldd	r25, Z+13	; 0x0d
    2d6e:	48 17       	cp	r20, r24
    2d70:	59 07       	cpc	r21, r25
    2d72:	e0 f4       	brcc	.+56     	; 0x2dac <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2d74:	bf 01       	movw	r22, r30
    2d76:	6e 5f       	subi	r22, 0xFE	; 254
    2d78:	7f 4f       	sbci	r23, 0xFF	; 255
    2d7a:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <pxOverflowTimerList>
    2d7e:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <pxOverflowTimerList+0x1>
    2d82:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2d86:	80 e0       	ldi	r24, 0x00	; 0
    2d88:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2d8a:	42 17       	cp	r20, r18
    2d8c:	53 07       	cpc	r21, r19
    2d8e:	18 f4       	brcc	.+6      	; 0x2d96 <prvInsertTimerInActiveList+0x40>
    2d90:	62 17       	cp	r22, r18
    2d92:	73 07       	cpc	r23, r19
    2d94:	68 f4       	brcc	.+26     	; 0x2db0 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2d96:	bf 01       	movw	r22, r30
    2d98:	6e 5f       	subi	r22, 0xFE	; 254
    2d9a:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9c:	80 91 a4 22 	lds	r24, 0x22A4	; 0x8022a4 <pxCurrentTimerList>
    2da0:	90 91 a5 22 	lds	r25, 0x22A5	; 0x8022a5 <pxCurrentTimerList+0x1>
    2da4:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2da8:	80 e0       	ldi	r24, 0x00	; 0
    2daa:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2dac:	81 e0       	ldi	r24, 0x01	; 1
    2dae:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2db0:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2db2:	08 95       	ret

00002db4 <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    2db4:	0f b6       	in	r0, 0x3f	; 63
    2db6:	f8 94       	cli
    2db8:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2dba:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xTimerQueue>
    2dbe:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
    2dc2:	89 2b       	or	r24, r25
    2dc4:	e1 f4       	brne	.+56     	; 0x2dfe <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    2dc6:	8f ea       	ldi	r24, 0xAF	; 175
    2dc8:	92 e2       	ldi	r25, 0x22	; 34
    2dca:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    2dce:	86 ea       	ldi	r24, 0xA6	; 166
    2dd0:	92 e2       	ldi	r25, 0x22	; 34
    2dd2:	0e 94 f5 0d 	call	0x1bea	; 0x1bea <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    2dd6:	8f ea       	ldi	r24, 0xAF	; 175
    2dd8:	92 e2       	ldi	r25, 0x22	; 34
    2dda:	80 93 a4 22 	sts	0x22A4, r24	; 0x8022a4 <pxCurrentTimerList>
    2dde:	90 93 a5 22 	sts	0x22A5, r25	; 0x8022a5 <pxCurrentTimerList+0x1>
			pxOverflowTimerList = &xActiveTimerList2;
    2de2:	86 ea       	ldi	r24, 0xA6	; 166
    2de4:	92 e2       	ldi	r25, 0x22	; 34
    2de6:	80 93 a2 22 	sts	0x22A2, r24	; 0x8022a2 <pxOverflowTimerList>
    2dea:	90 93 a3 22 	sts	0x22A3, r25	; 0x8022a3 <pxOverflowTimerList+0x1>
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2dee:	40 e0       	ldi	r20, 0x00	; 0
    2df0:	65 e0       	ldi	r22, 0x05	; 5
    2df2:	8a e0       	ldi	r24, 0x0A	; 10
    2df4:	f2 d9       	rcall	.-3100   	; 0x21da <xQueueGenericCreate>
    2df6:	80 93 a0 22 	sts	0x22A0, r24	; 0x8022a0 <xTimerQueue>
    2dfa:	90 93 a1 22 	sts	0x22A1, r25	; 0x8022a1 <xTimerQueue+0x1>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2dfe:	0f 90       	pop	r0
    2e00:	0f be       	out	0x3f, r0	; 63
    2e02:	08 95       	ret

00002e04 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    2e04:	af 92       	push	r10
    2e06:	bf 92       	push	r11
    2e08:	cf 92       	push	r12
    2e0a:	df 92       	push	r13
    2e0c:	ef 92       	push	r14
    2e0e:	ff 92       	push	r15

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2e10:	0f 93       	push	r16

	if( xTimerQueue != NULL )
    2e12:	d0 df       	rcall	.-96     	; 0x2db4 <prvCheckForValidListAndQueue>
    2e14:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xTimerQueue>
    2e18:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
    2e1c:	89 2b       	or	r24, r25
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    2e1e:	89 f0       	breq	.+34     	; 0x2e42 <xTimerCreateTimerTask+0x3e>
    2e20:	a1 2c       	mov	r10, r1
    2e22:	b1 2c       	mov	r11, r1
    2e24:	c1 2c       	mov	r12, r1
    2e26:	d1 2c       	mov	r13, r1
    2e28:	e1 2c       	mov	r14, r1
    2e2a:	f1 2c       	mov	r15, r1
    2e2c:	03 e0       	ldi	r16, 0x03	; 3
    2e2e:	20 e0       	ldi	r18, 0x00	; 0
    2e30:	30 e0       	ldi	r19, 0x00	; 0
    2e32:	45 e5       	ldi	r20, 0x55	; 85
    2e34:	50 e0       	ldi	r21, 0x00	; 0
    2e36:	6d e1       	ldi	r22, 0x1D	; 29
    2e38:	70 e2       	ldi	r23, 0x20	; 32
    2e3a:	80 e1       	ldi	r24, 0x10	; 16
    2e3c:	98 e1       	ldi	r25, 0x18	; 24
    2e3e:	a7 db       	rcall	.-2226   	; 0x258e <xTaskGenericCreate>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    2e40:	01 c0       	rjmp	.+2      	; 0x2e44 <xTimerCreateTimerTask+0x40>
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    2e42:	80 e0       	ldi	r24, 0x00	; 0
    2e44:	0f 91       	pop	r16
    2e46:	ff 90       	pop	r15
    2e48:	ef 90       	pop	r14
    2e4a:	df 90       	pop	r13
    2e4c:	cf 90       	pop	r12
    2e4e:	bf 90       	pop	r11
    2e50:	af 90       	pop	r10
    2e52:	08 95       	ret

00002e54 <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    2e54:	8f 92       	push	r8
    2e56:	9f 92       	push	r9
    2e58:	bf 92       	push	r11
    2e5a:	cf 92       	push	r12
    2e5c:	df 92       	push	r13
    2e5e:	ef 92       	push	r14
    2e60:	ff 92       	push	r15
    2e62:	0f 93       	push	r16
    2e64:	1f 93       	push	r17
    2e66:	cf 93       	push	r28
    2e68:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    2e6a:	61 15       	cp	r22, r1
    2e6c:	71 05       	cpc	r23, r1
    2e6e:	c9 f0       	breq	.+50     	; 0x2ea2 <xTimerCreate+0x4e>
    2e70:	69 01       	movw	r12, r18
    2e72:	b4 2e       	mov	r11, r20
    2e74:	7b 01       	movw	r14, r22
    2e76:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    2e78:	83 e1       	ldi	r24, 0x13	; 19
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	ae d8       	rcall	.-3748   	; 0x1fda <pvPortMalloc>
    2e7e:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    2e80:	89 2b       	or	r24, r25
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    2e82:	89 f0       	breq	.+34     	; 0x2ea6 <xTimerCreate+0x52>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    2e84:	97 df       	rcall	.-210    	; 0x2db4 <prvCheckForValidListAndQueue>
    2e86:	88 82       	st	Y, r8
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2e88:	99 82       	std	Y+1, r9	; 0x01
    2e8a:	ec 86       	std	Y+12, r14	; 0x0c
			pxNewTimer->uxAutoReload = uxAutoReload;
    2e8c:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->pvTimerID = pvTimerID;
    2e8e:	be 86       	std	Y+14, r11	; 0x0e
    2e90:	cf 86       	std	Y+15, r12	; 0x0f
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2e92:	d8 8a       	std	Y+16, r13	; 0x10
    2e94:	09 8b       	std	Y+17, r16	; 0x11
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2e96:	1a 8b       	std	Y+18, r17	; 0x12
    2e98:	ce 01       	movw	r24, r28
    2e9a:	02 96       	adiw	r24, 0x02	; 2
    2e9c:	0e 94 03 0e 	call	0x1c06	; 0x1c06 <vListInitialiseItem>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2ea0:	02 c0       	rjmp	.+4      	; 0x2ea6 <xTimerCreate+0x52>
    2ea2:	c0 e0       	ldi	r28, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2ea4:	d0 e0       	ldi	r29, 0x00	; 0
    2ea6:	ce 01       	movw	r24, r28
    2ea8:	df 91       	pop	r29
    2eaa:	cf 91       	pop	r28
    2eac:	1f 91       	pop	r17
    2eae:	0f 91       	pop	r16
    2eb0:	ff 90       	pop	r15
    2eb2:	ef 90       	pop	r14
    2eb4:	df 90       	pop	r13
    2eb6:	cf 90       	pop	r12
    2eb8:	bf 90       	pop	r11
    2eba:	9f 90       	pop	r9
    2ebc:	8f 90       	pop	r8
    2ebe:	08 95       	ret

00002ec0 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2ec0:	0f 93       	push	r16
    2ec2:	1f 93       	push	r17
    2ec4:	cf 93       	push	r28
    2ec6:	df 93       	push	r29
    2ec8:	cd b7       	in	r28, 0x3d	; 61
    2eca:	de b7       	in	r29, 0x3e	; 62
    2ecc:	25 97       	sbiw	r28, 0x05	; 5
    2ece:	cd bf       	out	0x3d, r28	; 61
    2ed0:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2ed2:	e0 91 a0 22 	lds	r30, 0x22A0	; 0x8022a0 <xTimerQueue>
    2ed6:	f0 91 a1 22 	lds	r31, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
    2eda:	30 97       	sbiw	r30, 0x00	; 0
    2edc:	51 f1       	breq	.+84     	; 0x2f32 <xTimerGenericCommand+0x72>
    2ede:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2ee0:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2ee2:	4a 83       	std	Y+2, r20	; 0x02
    2ee4:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2ee6:	8c 83       	std	Y+4, r24	; 0x04
    2ee8:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2eea:	66 30       	cpi	r22, 0x06	; 6
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2eec:	d4 f4       	brge	.+52     	; 0x2f22 <xTimerGenericCommand+0x62>
    2eee:	25 df       	rcall	.-438    	; 0x2d3a <xTaskGetSchedulerState>
    2ef0:	82 30       	cpi	r24, 0x02	; 2
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2ef2:	59 f4       	brne	.+22     	; 0x2f0a <xTimerGenericCommand+0x4a>
    2ef4:	20 e0       	ldi	r18, 0x00	; 0
    2ef6:	a8 01       	movw	r20, r16
    2ef8:	be 01       	movw	r22, r28
    2efa:	6f 5f       	subi	r22, 0xFF	; 255
    2efc:	7f 4f       	sbci	r23, 0xFF	; 255
    2efe:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xTimerQueue>
    2f02:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
    2f06:	92 d9       	rcall	.-3292   	; 0x222c <xQueueGenericSend>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2f08:	15 c0       	rjmp	.+42     	; 0x2f34 <xTimerGenericCommand+0x74>
    2f0a:	20 e0       	ldi	r18, 0x00	; 0
    2f0c:	40 e0       	ldi	r20, 0x00	; 0
    2f0e:	50 e0       	ldi	r21, 0x00	; 0
    2f10:	be 01       	movw	r22, r28
    2f12:	6f 5f       	subi	r22, 0xFF	; 255
    2f14:	7f 4f       	sbci	r23, 0xFF	; 255
    2f16:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xTimerQueue>
    2f1a:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
    2f1e:	86 d9       	rcall	.-3316   	; 0x222c <xQueueGenericSend>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2f20:	09 c0       	rjmp	.+18     	; 0x2f34 <xTimerGenericCommand+0x74>
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	ad 01       	movw	r20, r26
    2f26:	be 01       	movw	r22, r28
    2f28:	6f 5f       	subi	r22, 0xFF	; 255
    2f2a:	7f 4f       	sbci	r23, 0xFF	; 255
    2f2c:	cf 01       	movw	r24, r30
    2f2e:	0b da       	rcall	.-3050   	; 0x2346 <xQueueGenericSendFromISR>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2f30:	01 c0       	rjmp	.+2      	; 0x2f34 <xTimerGenericCommand+0x74>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2f32:	80 e0       	ldi	r24, 0x00	; 0
    2f34:	25 96       	adiw	r28, 0x05	; 5
    2f36:	cd bf       	out	0x3d, r28	; 61
    2f38:	de bf       	out	0x3e, r29	; 62
    2f3a:	df 91       	pop	r29
    2f3c:	cf 91       	pop	r28
    2f3e:	1f 91       	pop	r17
    2f40:	0f 91       	pop	r16
    2f42:	08 95       	ret

00002f44 <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2f44:	af 92       	push	r10
    2f46:	bf 92       	push	r11
    2f48:	cf 92       	push	r12
    2f4a:	df 92       	push	r13
    2f4c:	ef 92       	push	r14
    2f4e:	ff 92       	push	r15
    2f50:	0f 93       	push	r16
    2f52:	1f 93       	push	r17
    2f54:	cf 93       	push	r28
    2f56:	df 93       	push	r29
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2f58:	6c 01       	movw	r12, r24
    2f5a:	53 dc       	rcall	.-1882   	; 0x2802 <xTaskGetTickCount>

	if( xTimeNow < xLastTime )
    2f5c:	7c 01       	movw	r14, r24
    2f5e:	80 91 9e 22 	lds	r24, 0x229E	; 0x80229e <xLastTime.4459>
    2f62:	90 91 9f 22 	lds	r25, 0x229F	; 0x80229f <xLastTime.4459+0x1>
    2f66:	e8 16       	cp	r14, r24
    2f68:	f9 06       	cpc	r15, r25
    2f6a:	08 f0       	brcs	.+2      	; 0x2f6e <prvSampleTimeNow+0x2a>
    2f6c:	47 c0       	rjmp	.+142    	; 0x2ffc <prvSampleTimeNow+0xb8>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f6e:	2f c0       	rjmp	.+94     	; 0x2fce <prvSampleTimeNow+0x8a>
    2f70:	05 80       	ldd	r0, Z+5	; 0x05
    2f72:	f6 81       	ldd	r31, Z+6	; 0x06
    2f74:	e0 2d       	mov	r30, r0
    2f76:	a0 80       	ld	r10, Z

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2f78:	b1 80       	ldd	r11, Z+1	; 0x01
    2f7a:	c6 81       	ldd	r28, Z+6	; 0x06
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2f7c:	d7 81       	ldd	r29, Z+7	; 0x07
    2f7e:	8e 01       	movw	r16, r28
    2f80:	0e 5f       	subi	r16, 0xFE	; 254
    2f82:	1f 4f       	sbci	r17, 0xFF	; 255
    2f84:	c8 01       	movw	r24, r16
    2f86:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2f8a:	e9 89       	ldd	r30, Y+17	; 0x11
    2f8c:	fa 89       	ldd	r31, Y+18	; 0x12
    2f8e:	ce 01       	movw	r24, r28

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2f90:	19 95       	eicall
    2f92:	8e 85       	ldd	r24, Y+14	; 0x0e
    2f94:	81 30       	cpi	r24, 0x01	; 1
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2f96:	d9 f4       	brne	.+54     	; 0x2fce <prvSampleTimeNow+0x8a>
    2f98:	8c 85       	ldd	r24, Y+12	; 0x0c
    2f9a:	9d 85       	ldd	r25, Y+13	; 0x0d
    2f9c:	8a 0d       	add	r24, r10
			if( xReloadTime > xNextExpireTime )
    2f9e:	9b 1d       	adc	r25, r11
    2fa0:	a8 16       	cp	r10, r24
    2fa2:	b9 06       	cpc	r11, r25
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2fa4:	60 f4       	brcc	.+24     	; 0x2fbe <prvSampleTimeNow+0x7a>
    2fa6:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2fa8:	9b 83       	std	Y+3, r25	; 0x03
    2faa:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2fac:	d9 87       	std	Y+9, r29	; 0x09
    2fae:	b8 01       	movw	r22, r16
    2fb0:	80 91 a4 22 	lds	r24, 0x22A4	; 0x8022a4 <pxCurrentTimerList>
    2fb4:	90 91 a5 22 	lds	r25, 0x22A5	; 0x8022a5 <pxCurrentTimerList+0x1>
    2fb8:	0e 94 28 0e 	call	0x1c50	; 0x1c50 <vListInsert>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2fbc:	08 c0       	rjmp	.+16     	; 0x2fce <prvSampleTimeNow+0x8a>
    2fbe:	00 e0       	ldi	r16, 0x00	; 0
    2fc0:	10 e0       	ldi	r17, 0x00	; 0
    2fc2:	20 e0       	ldi	r18, 0x00	; 0
    2fc4:	30 e0       	ldi	r19, 0x00	; 0
    2fc6:	a5 01       	movw	r20, r10
    2fc8:	60 e0       	ldi	r22, 0x00	; 0
    2fca:	ce 01       	movw	r24, r28

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2fcc:	79 df       	rcall	.-270    	; 0x2ec0 <xTimerGenericCommand>
    2fce:	e0 91 a4 22 	lds	r30, 0x22A4	; 0x8022a4 <pxCurrentTimerList>
    2fd2:	f0 91 a5 22 	lds	r31, 0x22A5	; 0x8022a5 <pxCurrentTimerList+0x1>
    2fd6:	80 81       	ld	r24, Z
    2fd8:	81 11       	cpse	r24, r1
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2fda:	ca cf       	rjmp	.-108    	; 0x2f70 <prvSampleTimeNow+0x2c>
    2fdc:	80 91 a2 22 	lds	r24, 0x22A2	; 0x8022a2 <pxOverflowTimerList>
    2fe0:	90 91 a3 22 	lds	r25, 0x22A3	; 0x8022a3 <pxOverflowTimerList+0x1>
    2fe4:	80 93 a4 22 	sts	0x22A4, r24	; 0x8022a4 <pxCurrentTimerList>
    2fe8:	90 93 a5 22 	sts	0x22A5, r25	; 0x8022a5 <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    2fec:	e0 93 a2 22 	sts	0x22A2, r30	; 0x8022a2 <pxOverflowTimerList>
    2ff0:	f0 93 a3 22 	sts	0x22A3, r31	; 0x8022a3 <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2ff4:	81 e0       	ldi	r24, 0x01	; 1
    2ff6:	f6 01       	movw	r30, r12
    2ff8:	80 83       	st	Z, r24
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    2ffa:	02 c0       	rjmp	.+4      	; 0x3000 <prvSampleTimeNow+0xbc>
    2ffc:	f6 01       	movw	r30, r12
	}

	xLastTime = xTimeNow;
    2ffe:	10 82       	st	Z, r1
    3000:	e0 92 9e 22 	sts	0x229E, r14	; 0x80229e <xLastTime.4459>
    3004:	f0 92 9f 22 	sts	0x229F, r15	; 0x80229f <xLastTime.4459+0x1>

	return xTimeNow;
}
    3008:	c7 01       	movw	r24, r14
    300a:	df 91       	pop	r29
    300c:	cf 91       	pop	r28
    300e:	1f 91       	pop	r17
    3010:	0f 91       	pop	r16
    3012:	ff 90       	pop	r15
    3014:	ef 90       	pop	r14
    3016:	df 90       	pop	r13
    3018:	cf 90       	pop	r12
    301a:	bf 90       	pop	r11
    301c:	af 90       	pop	r10
    301e:	08 95       	ret

00003020 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3020:	cf 93       	push	r28
    3022:	df 93       	push	r29
    3024:	00 d0       	rcall	.+0      	; 0x3026 <prvTimerTask+0x6>
    3026:	00 d0       	rcall	.+0      	; 0x3028 <prvTimerTask+0x8>
    3028:	cd b7       	in	r28, 0x3d	; 61
    302a:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    302c:	ce 01       	movw	r24, r28
    302e:	01 96       	adiw	r24, 0x01	; 1
    3030:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    3032:	e8 2e       	mov	r14, r24
    3034:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3036:	e0 91 a4 22 	lds	r30, 0x22A4	; 0x8022a4 <pxCurrentTimerList>
    303a:	f0 91 a5 22 	lds	r31, 0x22A5	; 0x8022a5 <pxCurrentTimerList+0x1>
	if( *pxListWasEmpty == pdFALSE )
    303e:	80 81       	ld	r24, Z
    3040:	88 23       	and	r24, r24
    3042:	09 f4       	brne	.+2      	; 0x3046 <prvTimerTask+0x26>
    3044:	b6 c0       	rjmp	.+364    	; 0x31b2 <prvTimerTask+0x192>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3046:	05 80       	ldd	r0, Z+5	; 0x05
    3048:	f6 81       	ldd	r31, Z+6	; 0x06
    304a:	e0 2d       	mov	r30, r0
    304c:	c0 80       	ld	r12, Z
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    304e:	d1 80       	ldd	r13, Z+1	; 0x01
    3050:	d2 db       	rcall	.-2140   	; 0x27f6 <vTaskSuspendAll>
    3052:	c5 01       	movw	r24, r10
		if( xTimerListsWereSwitched == pdFALSE )
    3054:	77 df       	rcall	.-274    	; 0x2f44 <prvSampleTimeNow>
    3056:	8c 01       	movw	r16, r24
    3058:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    305a:	81 11       	cpse	r24, r1
    305c:	42 c0       	rjmp	.+132    	; 0x30e2 <prvTimerTask+0xc2>
			{
				( void ) xTaskResumeAll();
    305e:	0c 15       	cp	r16, r12
    3060:	1d 05       	cpc	r17, r13
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3062:	80 f1       	brcs	.+96     	; 0x30c4 <prvTimerTask+0xa4>
    3064:	ab dc       	rcall	.-1706   	; 0x29bc <xTaskResumeAll>
    3066:	e0 91 a4 22 	lds	r30, 0x22A4	; 0x8022a4 <pxCurrentTimerList>
    306a:	f0 91 a5 22 	lds	r31, 0x22A5	; 0x8022a5 <pxCurrentTimerList+0x1>
    306e:	05 80       	ldd	r0, Z+5	; 0x05
    3070:	f6 81       	ldd	r31, Z+6	; 0x06
    3072:	e0 2d       	mov	r30, r0

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3074:	86 80       	ldd	r8, Z+6	; 0x06
    3076:	97 80       	ldd	r9, Z+7	; 0x07
    3078:	c4 01       	movw	r24, r8
    307a:	02 96       	adiw	r24, 0x02	; 2
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    307c:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <uxListRemove>
    3080:	d4 01       	movw	r26, r8
    3082:	1e 96       	adiw	r26, 0x0e	; 14
    3084:	8c 91       	ld	r24, X
    3086:	1e 97       	sbiw	r26, 0x0e	; 14
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3088:	81 30       	cpi	r24, 0x01	; 1
    308a:	a1 f4       	brne	.+40     	; 0x30b4 <prvTimerTask+0x94>
    308c:	1c 96       	adiw	r26, 0x0c	; 12
    308e:	6d 91       	ld	r22, X+
    3090:	7c 91       	ld	r23, X
    3092:	1d 97       	sbiw	r26, 0x0d	; 13
    3094:	6c 0d       	add	r22, r12
    3096:	7d 1d       	adc	r23, r13
    3098:	96 01       	movw	r18, r12
    309a:	a8 01       	movw	r20, r16
    309c:	c4 01       	movw	r24, r8
    309e:	5b de       	rcall	.-842    	; 0x2d56 <prvInsertTimerInActiveList>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    30a0:	81 30       	cpi	r24, 0x01	; 1
    30a2:	41 f4       	brne	.+16     	; 0x30b4 <prvTimerTask+0x94>
    30a4:	00 e0       	ldi	r16, 0x00	; 0
    30a6:	10 e0       	ldi	r17, 0x00	; 0
    30a8:	20 e0       	ldi	r18, 0x00	; 0
    30aa:	30 e0       	ldi	r19, 0x00	; 0
    30ac:	a6 01       	movw	r20, r12
    30ae:	60 e0       	ldi	r22, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    30b0:	c4 01       	movw	r24, r8
    30b2:	06 df       	rcall	.-500    	; 0x2ec0 <xTimerGenericCommand>
    30b4:	d4 01       	movw	r26, r8
    30b6:	51 96       	adiw	r26, 0x11	; 17
    30b8:	ed 91       	ld	r30, X+
    30ba:	fc 91       	ld	r31, X
    30bc:	52 97       	sbiw	r26, 0x12	; 18
    30be:	c4 01       	movw	r24, r8
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    30c0:	19 95       	eicall
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    30c2:	6a c0       	rjmp	.+212    	; 0x3198 <prvTimerTask+0x178>
    30c4:	40 e0       	ldi	r20, 0x00	; 0
    30c6:	b6 01       	movw	r22, r12
    30c8:	60 1b       	sub	r22, r16
    30ca:	71 0b       	sbc	r23, r17
    30cc:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xTimerQueue>

				if( xTaskResumeAll() == pdFALSE )
    30d0:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    30d4:	05 da       	rcall	.-3062   	; 0x24e0 <vQueueWaitForMessageRestricted>
    30d6:	72 dc       	rcall	.-1820   	; 0x29bc <xTaskResumeAll>
    30d8:	81 11       	cpse	r24, r1
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    30da:	5e c0       	rjmp	.+188    	; 0x3198 <prvTimerTask+0x178>
    30dc:	0e 94 3b 0f 	call	0x1e76	; 0x1e76 <vPortYield>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    30e0:	5b c0       	rjmp	.+182    	; 0x3198 <prvTimerTask+0x178>
    30e2:	6c dc       	rcall	.-1832   	; 0x29bc <xTaskResumeAll>
    30e4:	59 c0       	rjmp	.+178    	; 0x3198 <prvTimerTask+0x178>
    30e6:	89 81       	ldd	r24, Y+1	; 0x01
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    30e8:	88 23       	and	r24, r24
    30ea:	0c f4       	brge	.+2      	; 0x30ee <prvTimerTask+0xce>

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    30ec:	55 c0       	rjmp	.+170    	; 0x3198 <prvTimerTask+0x178>
    30ee:	cc 80       	ldd	r12, Y+4	; 0x04
    30f0:	dd 80       	ldd	r13, Y+5	; 0x05
    30f2:	f6 01       	movw	r30, r12
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    30f4:	82 85       	ldd	r24, Z+10	; 0x0a
    30f6:	93 85       	ldd	r25, Z+11	; 0x0b
    30f8:	89 2b       	or	r24, r25
    30fa:	21 f0       	breq	.+8      	; 0x3104 <prvTimerTask+0xe4>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    30fc:	c6 01       	movw	r24, r12
    30fe:	02 96       	adiw	r24, 0x02	; 2
    3100:	0e 94 59 0e 	call	0x1cb2	; 0x1cb2 <uxListRemove>
    3104:	ce 01       	movw	r24, r28

			switch( xMessage.xMessageID )
    3106:	06 96       	adiw	r24, 0x06	; 6
    3108:	1d df       	rcall	.-454    	; 0x2f44 <prvSampleTimeNow>
    310a:	ac 01       	movw	r20, r24
    310c:	89 81       	ldd	r24, Y+1	; 0x01
    310e:	08 2e       	mov	r0, r24
    3110:	00 0c       	add	r0, r0
    3112:	99 0b       	sbc	r25, r25
    3114:	aa 0b       	sbc	r26, r26
    3116:	bb 0b       	sbc	r27, r27
    3118:	8a 30       	cpi	r24, 0x0A	; 10
    311a:	91 05       	cpc	r25, r1
    311c:	08 f0       	brcs	.+2      	; 0x3120 <prvTimerTask+0x100>
    311e:	3c c0       	rjmp	.+120    	; 0x3198 <prvTimerTask+0x178>
    3120:	fc 01       	movw	r30, r24
    3122:	88 27       	eor	r24, r24
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    3124:	e2 50       	subi	r30, 0x02	; 2
    3126:	ff 4f       	sbci	r31, 0xFF	; 255
    3128:	8f 4f       	sbci	r24, 0xFF	; 255
    312a:	bd c2       	rjmp	.+1402   	; 0x36a6 <__tablejump2__>
    312c:	2a 81       	ldd	r18, Y+2	; 0x02
    312e:	3b 81       	ldd	r19, Y+3	; 0x03
    3130:	d6 01       	movw	r26, r12
    3132:	1c 96       	adiw	r26, 0x0c	; 12
    3134:	6d 91       	ld	r22, X+
    3136:	7c 91       	ld	r23, X
    3138:	1d 97       	sbiw	r26, 0x0d	; 13
    313a:	62 0f       	add	r22, r18
    313c:	73 1f       	adc	r23, r19
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    313e:	c6 01       	movw	r24, r12
    3140:	0a de       	rcall	.-1004   	; 0x2d56 <prvInsertTimerInActiveList>
    3142:	81 30       	cpi	r24, 0x01	; 1
    3144:	49 f5       	brne	.+82     	; 0x3198 <prvTimerTask+0x178>
    3146:	d6 01       	movw	r26, r12
    3148:	51 96       	adiw	r26, 0x11	; 17
    314a:	ed 91       	ld	r30, X+
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    314c:	fc 91       	ld	r31, X
    314e:	52 97       	sbiw	r26, 0x12	; 18
    3150:	c6 01       	movw	r24, r12
    3152:	19 95       	eicall
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3154:	f6 01       	movw	r30, r12
    3156:	86 85       	ldd	r24, Z+14	; 0x0e
    3158:	81 30       	cpi	r24, 0x01	; 1
    315a:	f1 f4       	brne	.+60     	; 0x3198 <prvTimerTask+0x178>
    315c:	4a 81       	ldd	r20, Y+2	; 0x02
    315e:	5b 81       	ldd	r21, Y+3	; 0x03
    3160:	84 85       	ldd	r24, Z+12	; 0x0c
    3162:	95 85       	ldd	r25, Z+13	; 0x0d
    3164:	48 0f       	add	r20, r24
    3166:	59 1f       	adc	r21, r25
    3168:	00 e0       	ldi	r16, 0x00	; 0
    316a:	10 e0       	ldi	r17, 0x00	; 0
    316c:	20 e0       	ldi	r18, 0x00	; 0
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    316e:	30 e0       	ldi	r19, 0x00	; 0
    3170:	60 e0       	ldi	r22, 0x00	; 0
    3172:	c6 01       	movw	r24, r12
    3174:	a5 de       	rcall	.-694    	; 0x2ec0 <xTimerGenericCommand>
    3176:	10 c0       	rjmp	.+32     	; 0x3198 <prvTimerTask+0x178>
    3178:	6a 81       	ldd	r22, Y+2	; 0x02
    317a:	7b 81       	ldd	r23, Y+3	; 0x03
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    317c:	d6 01       	movw	r26, r12
    317e:	1c 96       	adiw	r26, 0x0c	; 12
    3180:	6d 93       	st	X+, r22
    3182:	7c 93       	st	X, r23
    3184:	1d 97       	sbiw	r26, 0x0d	; 13
    3186:	64 0f       	add	r22, r20
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    3188:	75 1f       	adc	r23, r21
    318a:	9a 01       	movw	r18, r20
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    318c:	c6 01       	movw	r24, r12
    318e:	e3 dd       	rcall	.-1082   	; 0x2d56 <prvInsertTimerInActiveList>
    3190:	03 c0       	rjmp	.+6      	; 0x3198 <prvTimerTask+0x178>
    3192:	c6 01       	movw	r24, r12
    3194:	0e 94 fa 0f 	call	0x1ff4	; 0x1ff4 <vPortFree>
    3198:	20 e0       	ldi	r18, 0x00	; 0
    319a:	40 e0       	ldi	r20, 0x00	; 0
    319c:	50 e0       	ldi	r21, 0x00	; 0
    319e:	6e 2d       	mov	r22, r14
    31a0:	7f 2d       	mov	r23, r15
    31a2:	80 91 a0 22 	lds	r24, 0x22A0	; 0x8022a0 <xTimerQueue>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    31a6:	90 91 a1 22 	lds	r25, 0x22A1	; 0x8022a1 <xTimerQueue+0x1>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    31aa:	03 d9       	rcall	.-3578   	; 0x23b2 <xQueueGenericReceive>
    31ac:	81 11       	cpse	r24, r1
    31ae:	9b cf       	rjmp	.-202    	; 0x30e6 <prvTimerTask+0xc6>
		if( xTimerListsWereSwitched == pdFALSE )
    31b0:	42 cf       	rjmp	.-380    	; 0x3036 <prvTimerTask+0x16>
    31b2:	21 db       	rcall	.-2494   	; 0x27f6 <vTaskSuspendAll>
    31b4:	c5 01       	movw	r24, r10
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    31b6:	c6 de       	rcall	.-628    	; 0x2f44 <prvSampleTimeNow>
    31b8:	8c 01       	movw	r16, r24
    31ba:	89 81       	ldd	r24, Y+1	; 0x01
    31bc:	81 11       	cpse	r24, r1
    31be:	91 cf       	rjmp	.-222    	; 0x30e2 <prvTimerTask+0xc2>
    31c0:	e0 91 a2 22 	lds	r30, 0x22A2	; 0x8022a2 <pxOverflowTimerList>
    31c4:	f0 91 a3 22 	lds	r31, 0x22A3	; 0x8022a3 <pxOverflowTimerList+0x1>
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    31c8:	41 e0       	ldi	r20, 0x01	; 1
    31ca:	80 81       	ld	r24, Z
    31cc:	81 11       	cpse	r24, r1
    31ce:	40 e0       	ldi	r20, 0x00	; 0
    31d0:	c1 2c       	mov	r12, r1
    31d2:	d1 2c       	mov	r13, r1
    31d4:	78 cf       	rjmp	.-272    	; 0x30c6 <prvTimerTask+0xa6>

000031d6 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    31d6:	cf 93       	push	r28
    31d8:	df 93       	push	r29
    31da:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    31dc:	20 e0       	ldi	r18, 0x00	; 0
    31de:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    31e0:	c6 2f       	mov	r28, r22
    31e2:	d0 e0       	ldi	r29, 0x00	; 0
    31e4:	de 01       	movw	r26, r28
    31e6:	02 2e       	mov	r0, r18
    31e8:	02 c0       	rjmp	.+4      	; 0x31ee <ioport_configure_port_pin+0x18>
    31ea:	b5 95       	asr	r27
    31ec:	a7 95       	ror	r26
    31ee:	0a 94       	dec	r0
    31f0:	e2 f7       	brpl	.-8      	; 0x31ea <ioport_configure_port_pin+0x14>
    31f2:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    31f4:	50 8b       	std	Z+16, r21	; 0x10
    31f6:	2f 5f       	subi	r18, 0xFF	; 255
    31f8:	3f 4f       	sbci	r19, 0xFF	; 255
    31fa:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    31fc:	28 30       	cpi	r18, 0x08	; 8
    31fe:	31 05       	cpc	r19, r1
    3200:	89 f7       	brne	.-30     	; 0x31e4 <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    3202:	40 ff       	sbrs	r20, 0
    3204:	0a c0       	rjmp	.+20     	; 0x321a <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    3206:	41 ff       	sbrs	r20, 1
    3208:	03 c0       	rjmp	.+6      	; 0x3210 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    320a:	fc 01       	movw	r30, r24
    320c:	65 83       	std	Z+5, r22	; 0x05
    320e:	02 c0       	rjmp	.+4      	; 0x3214 <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    3210:	fc 01       	movw	r30, r24
    3212:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    3214:	fc 01       	movw	r30, r24
    3216:	61 83       	std	Z+1, r22	; 0x01
    3218:	02 c0       	rjmp	.+4      	; 0x321e <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    321a:	fc 01       	movw	r30, r24
    321c:	62 83       	std	Z+2, r22	; 0x02
	}
}
    321e:	df 91       	pop	r29
    3220:	cf 91       	pop	r28
    3222:	08 95       	ret

00003224 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    3224:	43 e0       	ldi	r20, 0x03	; 3
    3226:	50 e0       	ldi	r21, 0x00	; 0
    3228:	61 e0       	ldi	r22, 0x01	; 1
    322a:	80 ee       	ldi	r24, 0xE0	; 224
    322c:	97 e0       	ldi	r25, 0x07	; 7
    322e:	d3 df       	rcall	.-90     	; 0x31d6 <ioport_configure_port_pin>
    3230:	43 e0       	ldi	r20, 0x03	; 3
    3232:	50 e0       	ldi	r21, 0x00	; 0
    3234:	62 e0       	ldi	r22, 0x02	; 2
    3236:	80 ee       	ldi	r24, 0xE0	; 224
    3238:	97 e0       	ldi	r25, 0x07	; 7
    323a:	cd df       	rcall	.-102    	; 0x31d6 <ioport_configure_port_pin>
    323c:	43 e0       	ldi	r20, 0x03	; 3
    323e:	50 e0       	ldi	r21, 0x00	; 0
    3240:	60 e1       	ldi	r22, 0x10	; 16
    3242:	80 e6       	ldi	r24, 0x60	; 96
    3244:	96 e0       	ldi	r25, 0x06	; 6
    3246:	c7 df       	rcall	.-114    	; 0x31d6 <ioport_configure_port_pin>
    3248:	41 e0       	ldi	r20, 0x01	; 1
    324a:	50 e4       	ldi	r21, 0x40	; 64
    324c:	60 e2       	ldi	r22, 0x20	; 32
    324e:	80 e6       	ldi	r24, 0x60	; 96
    3250:	96 e0       	ldi	r25, 0x06	; 6
    3252:	c1 df       	rcall	.-126    	; 0x31d6 <ioport_configure_port_pin>
    3254:	40 e0       	ldi	r20, 0x00	; 0
    3256:	5b e1       	ldi	r21, 0x1B	; 27
    3258:	60 e2       	ldi	r22, 0x20	; 32
    325a:	80 e8       	ldi	r24, 0x80	; 128
    325c:	96 e0       	ldi	r25, 0x06	; 6
    325e:	bb df       	rcall	.-138    	; 0x31d6 <ioport_configure_port_pin>
    3260:	40 e0       	ldi	r20, 0x00	; 0
    3262:	5b e1       	ldi	r21, 0x1B	; 27
    3264:	62 e0       	ldi	r22, 0x02	; 2
    3266:	80 ea       	ldi	r24, 0xA0	; 160
    3268:	96 e0       	ldi	r25, 0x06	; 6
    326a:	b5 df       	rcall	.-150    	; 0x31d6 <ioport_configure_port_pin>
    326c:	40 e0       	ldi	r20, 0x00	; 0
    326e:	5b e1       	ldi	r21, 0x1B	; 27
    3270:	64 e0       	ldi	r22, 0x04	; 4
    3272:	80 ea       	ldi	r24, 0xA0	; 160
    3274:	96 e0       	ldi	r25, 0x06	; 6
    3276:	af df       	rcall	.-162    	; 0x31d6 <ioport_configure_port_pin>
    3278:	43 e0       	ldi	r20, 0x03	; 3
    327a:	50 e0       	ldi	r21, 0x00	; 0
    327c:	62 e0       	ldi	r22, 0x02	; 2
    327e:	80 e6       	ldi	r24, 0x60	; 96
    3280:	96 e0       	ldi	r25, 0x06	; 6
    3282:	a9 df       	rcall	.-174    	; 0x31d6 <ioport_configure_port_pin>
    3284:	43 e0       	ldi	r20, 0x03	; 3
    3286:	50 e0       	ldi	r21, 0x00	; 0
    3288:	68 e0       	ldi	r22, 0x08	; 8
    328a:	80 e6       	ldi	r24, 0x60	; 96
    328c:	96 e0       	ldi	r25, 0x06	; 6
    328e:	a3 df       	rcall	.-186    	; 0x31d6 <ioport_configure_port_pin>
    3290:	43 e0       	ldi	r20, 0x03	; 3
    3292:	50 e0       	ldi	r21, 0x00	; 0
    3294:	68 e0       	ldi	r22, 0x08	; 8
    3296:	80 ea       	ldi	r24, 0xA0	; 160
    3298:	96 e0       	ldi	r25, 0x06	; 6
    329a:	9d df       	rcall	.-198    	; 0x31d6 <ioport_configure_port_pin>
    329c:	43 e0       	ldi	r20, 0x03	; 3
    329e:	50 e0       	ldi	r21, 0x00	; 0
    32a0:	61 e0       	ldi	r22, 0x01	; 1
    32a2:	80 e6       	ldi	r24, 0x60	; 96
    32a4:	96 e0       	ldi	r25, 0x06	; 6
    32a6:	97 df       	rcall	.-210    	; 0x31d6 <ioport_configure_port_pin>
    32a8:	43 e0       	ldi	r20, 0x03	; 3
    32aa:	50 e0       	ldi	r21, 0x00	; 0
    32ac:	68 e0       	ldi	r22, 0x08	; 8
    32ae:	80 e0       	ldi	r24, 0x00	; 0
    32b0:	96 e0       	ldi	r25, 0x06	; 6
    32b2:	91 df       	rcall	.-222    	; 0x31d6 <ioport_configure_port_pin>
    32b4:	41 e0       	ldi	r20, 0x01	; 1
    32b6:	50 e0       	ldi	r21, 0x00	; 0
    32b8:	60 e1       	ldi	r22, 0x10	; 16
    32ba:	80 e8       	ldi	r24, 0x80	; 128
    32bc:	96 e0       	ldi	r25, 0x06	; 6
    32be:	8b df       	rcall	.-234    	; 0x31d6 <ioport_configure_port_pin>
    32c0:	43 e0       	ldi	r20, 0x03	; 3
    32c2:	50 e0       	ldi	r21, 0x00	; 0
    32c4:	62 e0       	ldi	r22, 0x02	; 2
    32c6:	80 e6       	ldi	r24, 0x60	; 96
    32c8:	96 e0       	ldi	r25, 0x06	; 6
    32ca:	85 df       	rcall	.-246    	; 0x31d6 <ioport_configure_port_pin>
    32cc:	43 e0       	ldi	r20, 0x03	; 3
    32ce:	50 e0       	ldi	r21, 0x00	; 0
    32d0:	68 e0       	ldi	r22, 0x08	; 8
    32d2:	80 e6       	ldi	r24, 0x60	; 96
    32d4:	96 e0       	ldi	r25, 0x06	; 6
    32d6:	7f df       	rcall	.-258    	; 0x31d6 <ioport_configure_port_pin>
    32d8:	40 e0       	ldi	r20, 0x00	; 0
    32da:	50 e0       	ldi	r21, 0x00	; 0
    32dc:	64 e0       	ldi	r22, 0x04	; 4
    32de:	80 e6       	ldi	r24, 0x60	; 96
    32e0:	96 e0       	ldi	r25, 0x06	; 6
    32e2:	79 df       	rcall	.-270    	; 0x31d6 <ioport_configure_port_pin>
    32e4:	43 e0       	ldi	r20, 0x03	; 3
    32e6:	50 e0       	ldi	r21, 0x00	; 0
    32e8:	60 e1       	ldi	r22, 0x10	; 16
    32ea:	80 ea       	ldi	r24, 0xA0	; 160
    32ec:	96 e0       	ldi	r25, 0x06	; 6
    32ee:	73 df       	rcall	.-282    	; 0x31d6 <ioport_configure_port_pin>
    32f0:	40 e0       	ldi	r20, 0x00	; 0
    32f2:	50 e0       	ldi	r21, 0x00	; 0
    32f4:	61 e0       	ldi	r22, 0x01	; 1
    32f6:	80 e0       	ldi	r24, 0x00	; 0
    32f8:	96 e0       	ldi	r25, 0x06	; 6
    32fa:	6d df       	rcall	.-294    	; 0x31d6 <ioport_configure_port_pin>
    32fc:	40 e0       	ldi	r20, 0x00	; 0
    32fe:	50 e0       	ldi	r21, 0x00	; 0
    3300:	64 e0       	ldi	r22, 0x04	; 4
    3302:	80 e0       	ldi	r24, 0x00	; 0
    3304:	96 e0       	ldi	r25, 0x06	; 6
    3306:	67 df       	rcall	.-306    	; 0x31d6 <ioport_configure_port_pin>
    3308:	40 e0       	ldi	r20, 0x00	; 0
    330a:	50 e0       	ldi	r21, 0x00	; 0
    330c:	62 e0       	ldi	r22, 0x02	; 2
    330e:	80 e2       	ldi	r24, 0x20	; 32
    3310:	96 e0       	ldi	r25, 0x06	; 6
    3312:	61 df       	rcall	.-318    	; 0x31d6 <ioport_configure_port_pin>
    3314:	43 e0       	ldi	r20, 0x03	; 3
    3316:	50 e0       	ldi	r21, 0x00	; 0
    3318:	68 e0       	ldi	r22, 0x08	; 8
    331a:	80 e4       	ldi	r24, 0x40	; 64
    331c:	96 e0       	ldi	r25, 0x06	; 6
    331e:	5b df       	rcall	.-330    	; 0x31d6 <ioport_configure_port_pin>
    3320:	40 e0       	ldi	r20, 0x00	; 0
    3322:	50 e0       	ldi	r21, 0x00	; 0
    3324:	64 e0       	ldi	r22, 0x04	; 4
    3326:	80 e4       	ldi	r24, 0x40	; 64
    3328:	96 e0       	ldi	r25, 0x06	; 6
    332a:	55 df       	rcall	.-342    	; 0x31d6 <ioport_configure_port_pin>
    332c:	43 e0       	ldi	r20, 0x03	; 3
    332e:	50 e0       	ldi	r21, 0x00	; 0
    3330:	68 e0       	ldi	r22, 0x08	; 8
    3332:	80 e6       	ldi	r24, 0x60	; 96
    3334:	96 e0       	ldi	r25, 0x06	; 6
    3336:	4f df       	rcall	.-354    	; 0x31d6 <ioport_configure_port_pin>
    3338:	40 e0       	ldi	r20, 0x00	; 0
    333a:	50 e0       	ldi	r21, 0x00	; 0
    333c:	64 e0       	ldi	r22, 0x04	; 4
    333e:	80 e6       	ldi	r24, 0x60	; 96
    3340:	96 e0       	ldi	r25, 0x06	; 6
    3342:	49 df       	rcall	.-366    	; 0x31d6 <ioport_configure_port_pin>
    3344:	43 e0       	ldi	r20, 0x03	; 3
    3346:	50 e0       	ldi	r21, 0x00	; 0
    3348:	68 e0       	ldi	r22, 0x08	; 8
    334a:	80 e8       	ldi	r24, 0x80	; 128
    334c:	96 e0       	ldi	r25, 0x06	; 6
    334e:	43 df       	rcall	.-378    	; 0x31d6 <ioport_configure_port_pin>
    3350:	40 e0       	ldi	r20, 0x00	; 0
    3352:	50 e0       	ldi	r21, 0x00	; 0
    3354:	64 e0       	ldi	r22, 0x04	; 4
    3356:	80 e8       	ldi	r24, 0x80	; 128
    3358:	96 e0       	ldi	r25, 0x06	; 6
    335a:	3d cf       	rjmp	.-390    	; 0x31d6 <ioport_configure_port_pin>
    335c:	08 95       	ret

0000335e <vTimerCallback>:
	
	/* Set Period */
	TCC0.PER = 1000;

	/* Set Compare Register value*/
	TCC0.CCA = 375;
    335e:	80 91 1c 23 	lds	r24, 0x231C	; 0x80231c <increment>
    3362:	90 91 1d 23 	lds	r25, 0x231D	; 0x80231d <increment+0x1>
    3366:	a0 91 1e 23 	lds	r26, 0x231E	; 0x80231e <increment+0x2>
    336a:	b0 91 1f 23 	lds	r27, 0x231F	; 0x80231f <increment+0x3>
    336e:	01 96       	adiw	r24, 0x01	; 1
    3370:	a1 1d       	adc	r26, r1
    3372:	b1 1d       	adc	r27, r1
    3374:	80 93 1c 23 	sts	0x231C, r24	; 0x80231c <increment>
    3378:	90 93 1d 23 	sts	0x231D, r25	; 0x80231d <increment+0x1>
    337c:	a0 93 1e 23 	sts	0x231E, r26	; 0x80231e <increment+0x2>
    3380:	b0 93 1f 23 	sts	0x231F, r27	; 0x80231f <increment+0x3>
    3384:	08 95       	ret

00003386 <setUpSerial>:
    3386:	10 92 a7 08 	sts	0x08A7, r1	; 0x8008a7 <__TEXT_REGION_LENGTH__+0x7008a7>
    338a:	8c e0       	ldi	r24, 0x0C	; 12
    338c:	80 93 a6 08 	sts	0x08A6, r24	; 0x8008a6 <__TEXT_REGION_LENGTH__+0x7008a6>
    3390:	10 92 a3 08 	sts	0x08A3, r1	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7008a3>
    3394:	83 e0       	ldi	r24, 0x03	; 3
    3396:	80 93 a5 08 	sts	0x08A5, r24	; 0x8008a5 <__TEXT_REGION_LENGTH__+0x7008a5>
    339a:	88 e1       	ldi	r24, 0x18	; 24
    339c:	80 93 a4 08 	sts	0x08A4, r24	; 0x8008a4 <__TEXT_REGION_LENGTH__+0x7008a4>
    33a0:	08 95       	ret

000033a2 <sendChar>:
    33a2:	e1 ea       	ldi	r30, 0xA1	; 161
    33a4:	f8 e0       	ldi	r31, 0x08	; 8
    33a6:	90 81       	ld	r25, Z
    33a8:	95 ff       	sbrs	r25, 5
    33aa:	fd cf       	rjmp	.-6      	; 0x33a6 <sendChar+0x4>
    33ac:	80 93 a0 08 	sts	0x08A0, r24	; 0x8008a0 <__TEXT_REGION_LENGTH__+0x7008a0>
    33b0:	08 95       	ret

000033b2 <sendString>:
    33b2:	cf 93       	push	r28
    33b4:	df 93       	push	r29
    33b6:	fc 01       	movw	r30, r24
    33b8:	60 81       	ld	r22, Z
    33ba:	66 23       	and	r22, r22
    33bc:	49 f0       	breq	.+18     	; 0x33d0 <sendString+0x1e>
    33be:	ec 01       	movw	r28, r24
    33c0:	21 96       	adiw	r28, 0x01	; 1
    33c2:	80 ea       	ldi	r24, 0xA0	; 160
    33c4:	98 e0       	ldi	r25, 0x08	; 8
    33c6:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <usart_putchar>
    33ca:	69 91       	ld	r22, Y+
    33cc:	61 11       	cpse	r22, r1
    33ce:	f9 cf       	rjmp	.-14     	; 0x33c2 <sendString+0x10>
    33d0:	df 91       	pop	r29
    33d2:	cf 91       	pop	r28
    33d4:	08 95       	ret

000033d6 <receiveString>:
    33d6:	cf 93       	push	r28
    33d8:	df 93       	push	r29
    33da:	c8 eb       	ldi	r28, 0xB8	; 184
    33dc:	d2 e2       	ldi	r29, 0x22	; 34
    33de:	80 ea       	ldi	r24, 0xA0	; 160
    33e0:	98 e0       	ldi	r25, 0x08	; 8
    33e2:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <usart_getchar>
    33e6:	8a 30       	cpi	r24, 0x0A	; 10
    33e8:	11 f0       	breq	.+4      	; 0x33ee <receiveString+0x18>
    33ea:	89 93       	st	Y+, r24
    33ec:	f8 cf       	rjmp	.-16     	; 0x33de <receiveString+0x8>
    33ee:	68 eb       	ldi	r22, 0xB8	; 184
    33f0:	72 e2       	ldi	r23, 0x22	; 34
    33f2:	80 91 16 20 	lds	r24, 0x2016	; 0x802016 <str1>
    33f6:	90 91 17 20 	lds	r25, 0x2017	; 0x802017 <str1+0x1>
    33fa:	87 d2       	rcall	.+1294   	; 0x390a <strcmp>
    33fc:	89 2b       	or	r24, r25
    33fe:	21 f4       	brne	.+8      	; 0x3408 <receiveString+0x32>
    3400:	81 e0       	ldi	r24, 0x01	; 1
    3402:	80 93 25 06 	sts	0x0625, r24	; 0x800625 <__TEXT_REGION_LENGTH__+0x700625>
    3406:	10 c0       	rjmp	.+32     	; 0x3428 <receiveString+0x52>
    3408:	68 eb       	ldi	r22, 0xB8	; 184
    340a:	72 e2       	ldi	r23, 0x22	; 34
    340c:	80 91 14 20 	lds	r24, 0x2014	; 0x802014 <str2>
    3410:	90 91 15 20 	lds	r25, 0x2015	; 0x802015 <str2+0x1>
    3414:	7a d2       	rcall	.+1268   	; 0x390a <strcmp>
    3416:	89 2b       	or	r24, r25
    3418:	21 f4       	brne	.+8      	; 0x3422 <receiveString+0x4c>
    341a:	81 e0       	ldi	r24, 0x01	; 1
    341c:	80 93 25 06 	sts	0x0625, r24	; 0x800625 <__TEXT_REGION_LENGTH__+0x700625>
    3420:	03 c0       	rjmp	.+6      	; 0x3428 <receiveString+0x52>
    3422:	81 e0       	ldi	r24, 0x01	; 1
    3424:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <__TEXT_REGION_LENGTH__+0x700626>
    3428:	df 91       	pop	r29
    342a:	cf 91       	pop	r28
    342c:	08 95       	ret

0000342e <sendStringAndChar>:
    342e:	c0 ea       	ldi	r28, 0xA0	; 160
    3430:	d6 e0       	ldi	r29, 0x06	; 6
    3432:	00 e6       	ldi	r16, 0x60	; 96
    3434:	16 e0       	ldi	r17, 0x06	; 6
    3436:	68 94       	set
    3438:	ee 24       	eor	r14, r14
    343a:	e5 f8       	bld	r14, 5
    343c:	68 94       	set
    343e:	ff 24       	eor	r15, r15
    3440:	f4 f8       	bld	r15, 4
    3442:	88 85       	ldd	r24, Y+8	; 0x08
    3444:	81 fd       	sbrc	r24, 1
    3446:	0a c0       	rjmp	.+20     	; 0x345c <sendStringAndChar+0x2e>
    3448:	88 85       	ldd	r24, Y+8	; 0x08
    344a:	82 ff       	sbrs	r24, 2
    344c:	07 c0       	rjmp	.+14     	; 0x345c <sendStringAndChar+0x2e>
    344e:	f8 01       	movw	r30, r16
    3450:	f6 82       	std	Z+6, r15	; 0x06
    3452:	e5 82       	std	Z+5, r14	; 0x05
    3454:	85 e2       	ldi	r24, 0x25	; 37
    3456:	90 e2       	ldi	r25, 0x20	; 32
    3458:	ac df       	rcall	.-168    	; 0x33b2 <sendString>
    345a:	0b c0       	rjmp	.+22     	; 0x3472 <sendStringAndChar+0x44>
    345c:	88 85       	ldd	r24, Y+8	; 0x08
    345e:	82 fd       	sbrc	r24, 2
    3460:	08 c0       	rjmp	.+16     	; 0x3472 <sendStringAndChar+0x44>
    3462:	88 85       	ldd	r24, Y+8	; 0x08
    3464:	81 ff       	sbrs	r24, 1
    3466:	05 c0       	rjmp	.+10     	; 0x3472 <sendStringAndChar+0x44>
    3468:	f8 01       	movw	r30, r16
    346a:	e6 82       	std	Z+6, r14	; 0x06
    346c:	f5 82       	std	Z+5, r15	; 0x05
    346e:	81 e3       	ldi	r24, 0x31	; 49
    3470:	98 df       	rcall	.-208    	; 0x33a2 <sendChar>
    3472:	b1 df       	rcall	.-158    	; 0x33d6 <receiveString>
    3474:	26 e0       	ldi	r18, 0x06	; 6
    3476:	30 e2       	ldi	r19, 0x20	; 32
    3478:	40 e0       	ldi	r20, 0x00	; 0
    347a:	60 e0       	ldi	r22, 0x00	; 0
    347c:	88 eb       	ldi	r24, 0xB8	; 184
    347e:	92 e2       	ldi	r25, 0x22	; 34
    3480:	0e 94 7f 06 	call	0xcfe	; 0xcfe <gfx_mono_draw_string>
    3484:	85 e0       	ldi	r24, 0x05	; 5
    3486:	90 e0       	ldi	r25, 0x00	; 0
    3488:	16 db       	rcall	.-2516   	; 0x2ab6 <vTaskDelay>
    348a:	db cf       	rjmp	.-74     	; 0x3442 <sendStringAndChar+0x14>

0000348c <main>:
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
	return result;
}

int main (void)
{
    348c:	8f 92       	push	r8
    348e:	9f 92       	push	r9
    3490:	af 92       	push	r10
    3492:	bf 92       	push	r11
    3494:	cf 92       	push	r12
    3496:	df 92       	push	r13
    3498:	ef 92       	push	r14
    349a:	ff 92       	push	r15
    349c:	0f 93       	push	r16
    349e:	1f 93       	push	r17
    34a0:	cf 93       	push	r28
    34a2:	df 93       	push	r29
    34a4:	cd b7       	in	r28, 0x3d	; 61
    34a6:	de b7       	in	r29, 0x3e	; 62
    34a8:	2b 97       	sbiw	r28, 0x0b	; 11
    34aa:	cd bf       	out	0x3d, r28	; 61
	// Insert system clock initialization code here (sysclk_init()).

	
	board_init();
    34ac:	de bf       	out	0x3e, r29	; 62
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    34ae:	ba de       	rcall	.-652    	; 0x3224 <board_init>
    34b0:	87 e0       	ldi	r24, 0x07	; 7
    34b2:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7000a2>
	pmic_init();
	
	sysclk_init();
    34b6:	0e 94 3d 04 	call	0x87a	; 0x87a <sysclk_init>
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    34ba:	be 01       	movw	r22, r28
    34bc:	6f 5f       	subi	r22, 0xFF	; 255
    34be:	7f 4f       	sbci	r23, 0xFF	; 255
    34c0:	80 e0       	ldi	r24, 0x00	; 0
    34c2:	92 e0       	ldi	r25, 0x02	; 2
    34c4:	0e 94 39 09 	call	0x1272	; 0x1272 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    34c8:	ae 01       	movw	r20, r28
    34ca:	48 5f       	subi	r20, 0xF8	; 248
    34cc:	5f 4f       	sbci	r21, 0xFF	; 255
    34ce:	61 e0       	ldi	r22, 0x01	; 1
    34d0:	80 e0       	ldi	r24, 0x00	; 0
    34d2:	92 e0       	ldi	r25, 0x02	; 2
    34d4:	0e 94 95 09 	call	0x132a	; 0x132a <adcch_read_configuration>
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    34d8:	9a 81       	ldd	r25, Y+2	; 0x02
    34da:	8b 81       	ldd	r24, Y+3	; 0x03
    34dc:	8f 78       	andi	r24, 0x8F	; 143
    34de:	80 61       	ori	r24, 0x10	; 16
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    34e0:	8b 83       	std	Y+3, r24	; 0x03
    34e2:	89 2f       	mov	r24, r25
    34e4:	81 7e       	andi	r24, 0xE1	; 225
		conf->evctrl = ADC_EVACT_NONE_gc;
    34e6:	8a 83       	std	Y+2, r24	; 0x02
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    34e8:	1c 82       	std	Y+4, r1	; 0x04
    34ea:	68 94       	set
    34ec:	ff 24       	eor	r15, r15
    34ee:	f1 f8       	bld	r15, 1
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    34f0:	fd 82       	std	Y+5, r15	; 0x05
    34f2:	11 e0       	ldi	r17, 0x01	; 1
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    34f4:	18 87       	std	Y+8, r17	; 0x08
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    34f6:	19 86       	std	Y+9, r1	; 0x09
    34f8:	be 01       	movw	r22, r28
    34fa:	6f 5f       	subi	r22, 0xFF	; 255
    34fc:	7f 4f       	sbci	r23, 0xFF	; 255
    34fe:	80 e0       	ldi	r24, 0x00	; 0
    3500:	92 e0       	ldi	r25, 0x02	; 2
    3502:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    3506:	ae 01       	movw	r20, r28
    3508:	48 5f       	subi	r20, 0xF8	; 248
    350a:	5f 4f       	sbci	r21, 0xFF	; 255
    350c:	61 e0       	ldi	r22, 0x01	; 1
    350e:	80 e0       	ldi	r24, 0x00	; 0
    3510:	92 e0       	ldi	r25, 0x02	; 2
    3512:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <adcch_write_configuration>
static void adc_init2(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC2, &adc_conf);
    3516:	be 01       	movw	r22, r28
    3518:	6f 5f       	subi	r22, 0xFF	; 255
    351a:	7f 4f       	sbci	r23, 0xFF	; 255
    351c:	80 e0       	ldi	r24, 0x00	; 0
    351e:	92 e0       	ldi	r25, 0x02	; 2
    3520:	0e 94 39 09 	call	0x1272	; 0x1272 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    3524:	ae 01       	movw	r20, r28
    3526:	48 5f       	subi	r20, 0xF8	; 248
    3528:	5f 4f       	sbci	r21, 0xFF	; 255
    352a:	62 e0       	ldi	r22, 0x02	; 2
    352c:	80 e0       	ldi	r24, 0x00	; 0
    352e:	92 e0       	ldi	r25, 0x02	; 2
    3530:	0e 94 95 09 	call	0x132a	; 0x132a <adcch_read_configuration>
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    3534:	9a 81       	ldd	r25, Y+2	; 0x02
    3536:	8b 81       	ldd	r24, Y+3	; 0x03
    3538:	8f 78       	andi	r24, 0x8F	; 143
    353a:	80 61       	ori	r24, 0x10	; 16
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    353c:	8b 83       	std	Y+3, r24	; 0x03
    353e:	89 2f       	mov	r24, r25
    3540:	81 7e       	andi	r24, 0xE1	; 225
		conf->evctrl = ADC_EVACT_NONE_gc;
    3542:	8a 83       	std	Y+2, r24	; 0x02
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3544:	1c 82       	std	Y+4, r1	; 0x04
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3546:	fd 82       	std	Y+5, r15	; 0x05
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3548:	18 87       	std	Y+8, r17	; 0x08
    354a:	08 e0       	ldi	r16, 0x08	; 8
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN1, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC2, &adc_conf);
    354c:	09 87       	std	Y+9, r16	; 0x09
    354e:	be 01       	movw	r22, r28
    3550:	6f 5f       	subi	r22, 0xFF	; 255
    3552:	7f 4f       	sbci	r23, 0xFF	; 255
    3554:	80 e0       	ldi	r24, 0x00	; 0
    3556:	92 e0       	ldi	r25, 0x02	; 2
    3558:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    355c:	ae 01       	movw	r20, r28
    355e:	48 5f       	subi	r20, 0xF8	; 248
    3560:	5f 4f       	sbci	r21, 0xFF	; 255
    3562:	62 e0       	ldi	r22, 0x02	; 2
    3564:	80 e0       	ldi	r24, 0x00	; 0
    3566:	92 e0       	ldi	r25, 0x02	; 2
    3568:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <adcch_write_configuration>
static void adc_init3(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC3, &adc_conf);
    356c:	be 01       	movw	r22, r28
    356e:	6f 5f       	subi	r22, 0xFF	; 255
    3570:	7f 4f       	sbci	r23, 0xFF	; 255
    3572:	80 e0       	ldi	r24, 0x00	; 0
    3574:	92 e0       	ldi	r25, 0x02	; 2
    3576:	0e 94 39 09 	call	0x1272	; 0x1272 <adc_read_configuration>
	adcch_read_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    357a:	ae 01       	movw	r20, r28
    357c:	48 5f       	subi	r20, 0xF8	; 248
    357e:	5f 4f       	sbci	r21, 0xFF	; 255
    3580:	64 e0       	ldi	r22, 0x04	; 4
    3582:	80 e0       	ldi	r24, 0x00	; 0
    3584:	92 e0       	ldi	r25, 0x02	; 2
    3586:	0e 94 95 09 	call	0x132a	; 0x132a <adcch_read_configuration>
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
	conf->refctrl |= ref;
    358a:	9a 81       	ldd	r25, Y+2	; 0x02
    358c:	8b 81       	ldd	r24, Y+3	; 0x03
    358e:	8f 78       	andi	r24, 0x8F	; 143
    3590:	80 61       	ori	r24, 0x10	; 16
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3592:	8b 83       	std	Y+3, r24	; 0x03
    3594:	89 2f       	mov	r24, r25
    3596:	81 7e       	andi	r24, 0xE1	; 225
		conf->evctrl = ADC_EVACT_NONE_gc;
    3598:	8a 83       	std	Y+2, r24	; 0x02
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    359a:	1c 82       	std	Y+4, r1	; 0x04
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    359c:	fd 82       	std	Y+5, r15	; 0x05
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    359e:	18 87       	std	Y+8, r17	; 0x08
    35a0:	68 94       	set
    35a2:	ff 24       	eor	r15, r15
    35a4:	f4 f8       	bld	r15, 4
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN2, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC3, &adc_conf);
    35a6:	f9 86       	std	Y+9, r15	; 0x09
    35a8:	be 01       	movw	r22, r28
    35aa:	6f 5f       	subi	r22, 0xFF	; 255
    35ac:	7f 4f       	sbci	r23, 0xFF	; 255
    35ae:	80 e0       	ldi	r24, 0x00	; 0
    35b0:	92 e0       	ldi	r25, 0x02	; 2
    35b2:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <adc_write_configuration>
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    35b6:	ae 01       	movw	r20, r28
    35b8:	48 5f       	subi	r20, 0xF8	; 248
    35ba:	5f 4f       	sbci	r21, 0xFF	; 255
    35bc:	64 e0       	ldi	r22, 0x04	; 4
    35be:	80 e0       	ldi	r24, 0x00	; 0
    35c0:	92 e0       	ldi	r25, 0x02	; 2
    35c2:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <adcch_write_configuration>
	sysclk_init();
    
	adc_init();
	adc_init2();
	adc_init3();
	gfx_mono_init();
    35c6:	0e 94 0b 05 	call	0xa16	; 0xa16 <gfx_mono_st7565r_init>
    35ca:	f0 92 85 06 	sts	0x0685, r15	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    //
    gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
   
    PORTC_OUTSET = PIN3_bm; // PC3 as TX
    35ce:	00 93 45 06 	sts	0x0645, r16	; 0x800645 <__TEXT_REGION_LENGTH__+0x700645>
    PORTC_DIRSET = PIN3_bm; //TX pin as output
    35d2:	00 93 41 06 	sts	0x0641, r16	; 0x800641 <__TEXT_REGION_LENGTH__+0x700641>
   
    PORTC_OUTCLR = PIN2_bm; //PC2 as RX
    35d6:	84 e0       	ldi	r24, 0x04	; 4
    35d8:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x700646>
    PORTC_DIRCLR = PIN2_bm; //RX pin as input
   
    setUpSerial();
    35dc:	80 93 42 06 	sts	0x0642, r24	; 0x800642 <__TEXT_REGION_LENGTH__+0x700642>
		.charlength = USART_SERIAL_CHAR_LENGTH,
		.paritytype = USART_SERIAL_PARITY,
		.stopbits = USART_SERIAL_STOP_BIT
	};
	
	usart_init_rs232(USART_SERIAL_EXAMPLE, &USART_SERIAL_OPTIONS);
    35e0:	d2 de       	rcall	.-604    	; 0x3386 <setUpSerial>
    35e2:	6d e0       	ldi	r22, 0x0D	; 13
    35e4:	70 e2       	ldi	r23, 0x20	; 32
    35e6:	80 ea       	ldi	r24, 0xA0	; 160
    35e8:	98 e0       	ldi	r25, 0x08	; 8
    35ea:	0e 94 f9 0a 	call	0x15f2	; 0x15f2 <usart_init_rs232>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    35ee:	10 93 21 06 	sts	0x0621, r17	; 0x800621 <__TEXT_REGION_LENGTH__+0x700621>
	
	ioport_set_pin_dir(J2_PIN0, IOPORT_DIR_OUTPUT);
	
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    35f2:	0f ea       	ldi	r16, 0xAF	; 175
    35f4:	19 e1       	ldi	r17, 0x19	; 25
    35f6:	20 e0       	ldi	r18, 0x00	; 0
    35f8:	30 e0       	ldi	r19, 0x00	; 0
    35fa:	41 e0       	ldi	r20, 0x01	; 1
    35fc:	61 e0       	ldi	r22, 0x01	; 1
    35fe:	70 e0       	ldi	r23, 0x00	; 0
    3600:	8c e2       	ldi	r24, 0x2C	; 44
    3602:	90 e2       	ldi	r25, 0x20	; 32
    3604:	27 dc       	rcall	.-1970   	; 0x2e54 <xTimerCreate>
	
	xTaskCreate(sendStringAndChar,"",500,NULL,1,NULL);
    3606:	4c 01       	movw	r8, r24
    3608:	a1 2c       	mov	r10, r1
    360a:	b1 2c       	mov	r11, r1
    360c:	c1 2c       	mov	r12, r1
    360e:	d1 2c       	mov	r13, r1
    3610:	e1 2c       	mov	r14, r1
    3612:	f1 2c       	mov	r15, r1
    3614:	01 e0       	ldi	r16, 0x01	; 1
    3616:	20 e0       	ldi	r18, 0x00	; 0
    3618:	30 e0       	ldi	r19, 0x00	; 0
    361a:	44 ef       	ldi	r20, 0xF4	; 244
    361c:	51 e0       	ldi	r21, 0x01	; 1
    361e:	6b e2       	ldi	r22, 0x2B	; 43
    3620:	70 e2       	ldi	r23, 0x20	; 32
    3622:	87 e1       	ldi	r24, 0x17	; 23
    3624:	9a e1       	ldi	r25, 0x1A	; 26
	
	xTimerStart(timerPing, 0);
    3626:	0e 94 c7 12 	call	0x258e	; 0x258e <xTaskGenericCreate>
    362a:	eb d8       	rcall	.-3626   	; 0x2802 <xTaskGetTickCount>
    362c:	00 e0       	ldi	r16, 0x00	; 0
    362e:	10 e0       	ldi	r17, 0x00	; 0
    3630:	20 e0       	ldi	r18, 0x00	; 0
    3632:	30 e0       	ldi	r19, 0x00	; 0
    3634:	ac 01       	movw	r20, r24
    3636:	61 e0       	ldi	r22, 0x01	; 1
	
	vTaskStartScheduler();
    3638:	c4 01       	movw	r24, r8
    363a:	42 dc       	rcall	.-1916   	; 0x2ec0 <xTimerGenericCommand>

	// Insert application code here, after the board has been initialized.
}
    363c:	a9 d8       	rcall	.-3758   	; 0x2790 <vTaskStartScheduler>
    363e:	80 e0       	ldi	r24, 0x00	; 0
    3640:	90 e0       	ldi	r25, 0x00	; 0
    3642:	2b 96       	adiw	r28, 0x0b	; 11
    3644:	cd bf       	out	0x3d, r28	; 61
    3646:	de bf       	out	0x3e, r29	; 62
    3648:	df 91       	pop	r29
    364a:	cf 91       	pop	r28
    364c:	1f 91       	pop	r17
    364e:	0f 91       	pop	r16
    3650:	ff 90       	pop	r15
    3652:	ef 90       	pop	r14
    3654:	df 90       	pop	r13
    3656:	cf 90       	pop	r12
    3658:	bf 90       	pop	r11
    365a:	af 90       	pop	r10
    365c:	9f 90       	pop	r9
    365e:	8f 90       	pop	r8
    3660:	08 95       	ret

00003662 <__udivmodsi4>:
    3662:	a1 e2       	ldi	r26, 0x21	; 33
    3664:	1a 2e       	mov	r1, r26
    3666:	aa 1b       	sub	r26, r26
    3668:	bb 1b       	sub	r27, r27
    366a:	fd 01       	movw	r30, r26
    366c:	0d c0       	rjmp	.+26     	; 0x3688 <__udivmodsi4_ep>

0000366e <__udivmodsi4_loop>:
    366e:	aa 1f       	adc	r26, r26
    3670:	bb 1f       	adc	r27, r27
    3672:	ee 1f       	adc	r30, r30
    3674:	ff 1f       	adc	r31, r31
    3676:	a2 17       	cp	r26, r18
    3678:	b3 07       	cpc	r27, r19
    367a:	e4 07       	cpc	r30, r20
    367c:	f5 07       	cpc	r31, r21
    367e:	20 f0       	brcs	.+8      	; 0x3688 <__udivmodsi4_ep>
    3680:	a2 1b       	sub	r26, r18
    3682:	b3 0b       	sbc	r27, r19
    3684:	e4 0b       	sbc	r30, r20
    3686:	f5 0b       	sbc	r31, r21

00003688 <__udivmodsi4_ep>:
    3688:	66 1f       	adc	r22, r22
    368a:	77 1f       	adc	r23, r23
    368c:	88 1f       	adc	r24, r24
    368e:	99 1f       	adc	r25, r25
    3690:	1a 94       	dec	r1
    3692:	69 f7       	brne	.-38     	; 0x366e <__udivmodsi4_loop>
    3694:	60 95       	com	r22
    3696:	70 95       	com	r23
    3698:	80 95       	com	r24
    369a:	90 95       	com	r25
    369c:	9b 01       	movw	r18, r22
    369e:	ac 01       	movw	r20, r24
    36a0:	bd 01       	movw	r22, r26
    36a2:	cf 01       	movw	r24, r30
    36a4:	08 95       	ret

000036a6 <__tablejump2__>:
    36a6:	ee 0f       	add	r30, r30
    36a8:	ff 1f       	adc	r31, r31
    36aa:	88 1f       	adc	r24, r24
    36ac:	8b bf       	out	0x3b, r24	; 59
    36ae:	07 90       	elpm	r0, Z+
    36b0:	f6 91       	elpm	r31, Z
    36b2:	e0 2d       	mov	r30, r0
    36b4:	19 94       	eijmp

000036b6 <malloc>:
    36b6:	0f 93       	push	r16
    36b8:	1f 93       	push	r17
    36ba:	cf 93       	push	r28
    36bc:	df 93       	push	r29
    36be:	82 30       	cpi	r24, 0x02	; 2
    36c0:	91 05       	cpc	r25, r1
    36c2:	10 f4       	brcc	.+4      	; 0x36c8 <malloc+0x12>
    36c4:	82 e0       	ldi	r24, 0x02	; 2
    36c6:	90 e0       	ldi	r25, 0x00	; 0
    36c8:	e0 91 26 23 	lds	r30, 0x2326	; 0x802326 <__flp>
    36cc:	f0 91 27 23 	lds	r31, 0x2327	; 0x802327 <__flp+0x1>
    36d0:	20 e0       	ldi	r18, 0x00	; 0
    36d2:	30 e0       	ldi	r19, 0x00	; 0
    36d4:	a0 e0       	ldi	r26, 0x00	; 0
    36d6:	b0 e0       	ldi	r27, 0x00	; 0
    36d8:	30 97       	sbiw	r30, 0x00	; 0
    36da:	19 f1       	breq	.+70     	; 0x3722 <malloc+0x6c>
    36dc:	40 81       	ld	r20, Z
    36de:	51 81       	ldd	r21, Z+1	; 0x01
    36e0:	02 81       	ldd	r16, Z+2	; 0x02
    36e2:	13 81       	ldd	r17, Z+3	; 0x03
    36e4:	48 17       	cp	r20, r24
    36e6:	59 07       	cpc	r21, r25
    36e8:	c8 f0       	brcs	.+50     	; 0x371c <malloc+0x66>
    36ea:	84 17       	cp	r24, r20
    36ec:	95 07       	cpc	r25, r21
    36ee:	69 f4       	brne	.+26     	; 0x370a <malloc+0x54>
    36f0:	10 97       	sbiw	r26, 0x00	; 0
    36f2:	31 f0       	breq	.+12     	; 0x3700 <malloc+0x4a>
    36f4:	12 96       	adiw	r26, 0x02	; 2
    36f6:	0c 93       	st	X, r16
    36f8:	12 97       	sbiw	r26, 0x02	; 2
    36fa:	13 96       	adiw	r26, 0x03	; 3
    36fc:	1c 93       	st	X, r17
    36fe:	27 c0       	rjmp	.+78     	; 0x374e <malloc+0x98>
    3700:	00 93 26 23 	sts	0x2326, r16	; 0x802326 <__flp>
    3704:	10 93 27 23 	sts	0x2327, r17	; 0x802327 <__flp+0x1>
    3708:	22 c0       	rjmp	.+68     	; 0x374e <malloc+0x98>
    370a:	21 15       	cp	r18, r1
    370c:	31 05       	cpc	r19, r1
    370e:	19 f0       	breq	.+6      	; 0x3716 <malloc+0x60>
    3710:	42 17       	cp	r20, r18
    3712:	53 07       	cpc	r21, r19
    3714:	18 f4       	brcc	.+6      	; 0x371c <malloc+0x66>
    3716:	9a 01       	movw	r18, r20
    3718:	bd 01       	movw	r22, r26
    371a:	ef 01       	movw	r28, r30
    371c:	df 01       	movw	r26, r30
    371e:	f8 01       	movw	r30, r16
    3720:	db cf       	rjmp	.-74     	; 0x36d8 <malloc+0x22>
    3722:	21 15       	cp	r18, r1
    3724:	31 05       	cpc	r19, r1
    3726:	f9 f0       	breq	.+62     	; 0x3766 <malloc+0xb0>
    3728:	28 1b       	sub	r18, r24
    372a:	39 0b       	sbc	r19, r25
    372c:	24 30       	cpi	r18, 0x04	; 4
    372e:	31 05       	cpc	r19, r1
    3730:	80 f4       	brcc	.+32     	; 0x3752 <malloc+0x9c>
    3732:	8a 81       	ldd	r24, Y+2	; 0x02
    3734:	9b 81       	ldd	r25, Y+3	; 0x03
    3736:	61 15       	cp	r22, r1
    3738:	71 05       	cpc	r23, r1
    373a:	21 f0       	breq	.+8      	; 0x3744 <malloc+0x8e>
    373c:	fb 01       	movw	r30, r22
    373e:	82 83       	std	Z+2, r24	; 0x02
    3740:	93 83       	std	Z+3, r25	; 0x03
    3742:	04 c0       	rjmp	.+8      	; 0x374c <malloc+0x96>
    3744:	80 93 26 23 	sts	0x2326, r24	; 0x802326 <__flp>
    3748:	90 93 27 23 	sts	0x2327, r25	; 0x802327 <__flp+0x1>
    374c:	fe 01       	movw	r30, r28
    374e:	32 96       	adiw	r30, 0x02	; 2
    3750:	44 c0       	rjmp	.+136    	; 0x37da <malloc+0x124>
    3752:	fe 01       	movw	r30, r28
    3754:	e2 0f       	add	r30, r18
    3756:	f3 1f       	adc	r31, r19
    3758:	81 93       	st	Z+, r24
    375a:	91 93       	st	Z+, r25
    375c:	22 50       	subi	r18, 0x02	; 2
    375e:	31 09       	sbc	r19, r1
    3760:	28 83       	st	Y, r18
    3762:	39 83       	std	Y+1, r19	; 0x01
    3764:	3a c0       	rjmp	.+116    	; 0x37da <malloc+0x124>
    3766:	20 91 24 23 	lds	r18, 0x2324	; 0x802324 <__brkval>
    376a:	30 91 25 23 	lds	r19, 0x2325	; 0x802325 <__brkval+0x1>
    376e:	23 2b       	or	r18, r19
    3770:	41 f4       	brne	.+16     	; 0x3782 <malloc+0xcc>
    3772:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    3776:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    377a:	20 93 24 23 	sts	0x2324, r18	; 0x802324 <__brkval>
    377e:	30 93 25 23 	sts	0x2325, r19	; 0x802325 <__brkval+0x1>
    3782:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__data_start>
    3786:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__data_start+0x1>
    378a:	21 15       	cp	r18, r1
    378c:	31 05       	cpc	r19, r1
    378e:	41 f4       	brne	.+16     	; 0x37a0 <malloc+0xea>
    3790:	2d b7       	in	r18, 0x3d	; 61
    3792:	3e b7       	in	r19, 0x3e	; 62
    3794:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    3798:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    379c:	24 1b       	sub	r18, r20
    379e:	35 0b       	sbc	r19, r21
    37a0:	e0 91 24 23 	lds	r30, 0x2324	; 0x802324 <__brkval>
    37a4:	f0 91 25 23 	lds	r31, 0x2325	; 0x802325 <__brkval+0x1>
    37a8:	e2 17       	cp	r30, r18
    37aa:	f3 07       	cpc	r31, r19
    37ac:	a0 f4       	brcc	.+40     	; 0x37d6 <malloc+0x120>
    37ae:	2e 1b       	sub	r18, r30
    37b0:	3f 0b       	sbc	r19, r31
    37b2:	28 17       	cp	r18, r24
    37b4:	39 07       	cpc	r19, r25
    37b6:	78 f0       	brcs	.+30     	; 0x37d6 <malloc+0x120>
    37b8:	ac 01       	movw	r20, r24
    37ba:	4e 5f       	subi	r20, 0xFE	; 254
    37bc:	5f 4f       	sbci	r21, 0xFF	; 255
    37be:	24 17       	cp	r18, r20
    37c0:	35 07       	cpc	r19, r21
    37c2:	48 f0       	brcs	.+18     	; 0x37d6 <malloc+0x120>
    37c4:	4e 0f       	add	r20, r30
    37c6:	5f 1f       	adc	r21, r31
    37c8:	40 93 24 23 	sts	0x2324, r20	; 0x802324 <__brkval>
    37cc:	50 93 25 23 	sts	0x2325, r21	; 0x802325 <__brkval+0x1>
    37d0:	81 93       	st	Z+, r24
    37d2:	91 93       	st	Z+, r25
    37d4:	02 c0       	rjmp	.+4      	; 0x37da <malloc+0x124>
    37d6:	e0 e0       	ldi	r30, 0x00	; 0
    37d8:	f0 e0       	ldi	r31, 0x00	; 0
    37da:	cf 01       	movw	r24, r30
    37dc:	df 91       	pop	r29
    37de:	cf 91       	pop	r28
    37e0:	1f 91       	pop	r17
    37e2:	0f 91       	pop	r16
    37e4:	08 95       	ret

000037e6 <free>:
    37e6:	cf 93       	push	r28
    37e8:	df 93       	push	r29
    37ea:	00 97       	sbiw	r24, 0x00	; 0
    37ec:	09 f4       	brne	.+2      	; 0x37f0 <free+0xa>
    37ee:	81 c0       	rjmp	.+258    	; 0x38f2 <free+0x10c>
    37f0:	fc 01       	movw	r30, r24
    37f2:	32 97       	sbiw	r30, 0x02	; 2
    37f4:	12 82       	std	Z+2, r1	; 0x02
    37f6:	13 82       	std	Z+3, r1	; 0x03
    37f8:	a0 91 26 23 	lds	r26, 0x2326	; 0x802326 <__flp>
    37fc:	b0 91 27 23 	lds	r27, 0x2327	; 0x802327 <__flp+0x1>
    3800:	10 97       	sbiw	r26, 0x00	; 0
    3802:	81 f4       	brne	.+32     	; 0x3824 <free+0x3e>
    3804:	20 81       	ld	r18, Z
    3806:	31 81       	ldd	r19, Z+1	; 0x01
    3808:	82 0f       	add	r24, r18
    380a:	93 1f       	adc	r25, r19
    380c:	20 91 24 23 	lds	r18, 0x2324	; 0x802324 <__brkval>
    3810:	30 91 25 23 	lds	r19, 0x2325	; 0x802325 <__brkval+0x1>
    3814:	28 17       	cp	r18, r24
    3816:	39 07       	cpc	r19, r25
    3818:	51 f5       	brne	.+84     	; 0x386e <free+0x88>
    381a:	e0 93 24 23 	sts	0x2324, r30	; 0x802324 <__brkval>
    381e:	f0 93 25 23 	sts	0x2325, r31	; 0x802325 <__brkval+0x1>
    3822:	67 c0       	rjmp	.+206    	; 0x38f2 <free+0x10c>
    3824:	ed 01       	movw	r28, r26
    3826:	20 e0       	ldi	r18, 0x00	; 0
    3828:	30 e0       	ldi	r19, 0x00	; 0
    382a:	ce 17       	cp	r28, r30
    382c:	df 07       	cpc	r29, r31
    382e:	40 f4       	brcc	.+16     	; 0x3840 <free+0x5a>
    3830:	4a 81       	ldd	r20, Y+2	; 0x02
    3832:	5b 81       	ldd	r21, Y+3	; 0x03
    3834:	9e 01       	movw	r18, r28
    3836:	41 15       	cp	r20, r1
    3838:	51 05       	cpc	r21, r1
    383a:	f1 f0       	breq	.+60     	; 0x3878 <free+0x92>
    383c:	ea 01       	movw	r28, r20
    383e:	f5 cf       	rjmp	.-22     	; 0x382a <free+0x44>
    3840:	c2 83       	std	Z+2, r28	; 0x02
    3842:	d3 83       	std	Z+3, r29	; 0x03
    3844:	40 81       	ld	r20, Z
    3846:	51 81       	ldd	r21, Z+1	; 0x01
    3848:	84 0f       	add	r24, r20
    384a:	95 1f       	adc	r25, r21
    384c:	c8 17       	cp	r28, r24
    384e:	d9 07       	cpc	r29, r25
    3850:	59 f4       	brne	.+22     	; 0x3868 <free+0x82>
    3852:	88 81       	ld	r24, Y
    3854:	99 81       	ldd	r25, Y+1	; 0x01
    3856:	84 0f       	add	r24, r20
    3858:	95 1f       	adc	r25, r21
    385a:	02 96       	adiw	r24, 0x02	; 2
    385c:	80 83       	st	Z, r24
    385e:	91 83       	std	Z+1, r25	; 0x01
    3860:	8a 81       	ldd	r24, Y+2	; 0x02
    3862:	9b 81       	ldd	r25, Y+3	; 0x03
    3864:	82 83       	std	Z+2, r24	; 0x02
    3866:	93 83       	std	Z+3, r25	; 0x03
    3868:	21 15       	cp	r18, r1
    386a:	31 05       	cpc	r19, r1
    386c:	29 f4       	brne	.+10     	; 0x3878 <free+0x92>
    386e:	e0 93 26 23 	sts	0x2326, r30	; 0x802326 <__flp>
    3872:	f0 93 27 23 	sts	0x2327, r31	; 0x802327 <__flp+0x1>
    3876:	3d c0       	rjmp	.+122    	; 0x38f2 <free+0x10c>
    3878:	e9 01       	movw	r28, r18
    387a:	ea 83       	std	Y+2, r30	; 0x02
    387c:	fb 83       	std	Y+3, r31	; 0x03
    387e:	49 91       	ld	r20, Y+
    3880:	59 91       	ld	r21, Y+
    3882:	c4 0f       	add	r28, r20
    3884:	d5 1f       	adc	r29, r21
    3886:	ec 17       	cp	r30, r28
    3888:	fd 07       	cpc	r31, r29
    388a:	61 f4       	brne	.+24     	; 0x38a4 <free+0xbe>
    388c:	80 81       	ld	r24, Z
    388e:	91 81       	ldd	r25, Z+1	; 0x01
    3890:	84 0f       	add	r24, r20
    3892:	95 1f       	adc	r25, r21
    3894:	02 96       	adiw	r24, 0x02	; 2
    3896:	e9 01       	movw	r28, r18
    3898:	88 83       	st	Y, r24
    389a:	99 83       	std	Y+1, r25	; 0x01
    389c:	82 81       	ldd	r24, Z+2	; 0x02
    389e:	93 81       	ldd	r25, Z+3	; 0x03
    38a0:	8a 83       	std	Y+2, r24	; 0x02
    38a2:	9b 83       	std	Y+3, r25	; 0x03
    38a4:	e0 e0       	ldi	r30, 0x00	; 0
    38a6:	f0 e0       	ldi	r31, 0x00	; 0
    38a8:	12 96       	adiw	r26, 0x02	; 2
    38aa:	8d 91       	ld	r24, X+
    38ac:	9c 91       	ld	r25, X
    38ae:	13 97       	sbiw	r26, 0x03	; 3
    38b0:	00 97       	sbiw	r24, 0x00	; 0
    38b2:	19 f0       	breq	.+6      	; 0x38ba <free+0xd4>
    38b4:	fd 01       	movw	r30, r26
    38b6:	dc 01       	movw	r26, r24
    38b8:	f7 cf       	rjmp	.-18     	; 0x38a8 <free+0xc2>
    38ba:	8d 91       	ld	r24, X+
    38bc:	9c 91       	ld	r25, X
    38be:	11 97       	sbiw	r26, 0x01	; 1
    38c0:	9d 01       	movw	r18, r26
    38c2:	2e 5f       	subi	r18, 0xFE	; 254
    38c4:	3f 4f       	sbci	r19, 0xFF	; 255
    38c6:	82 0f       	add	r24, r18
    38c8:	93 1f       	adc	r25, r19
    38ca:	20 91 24 23 	lds	r18, 0x2324	; 0x802324 <__brkval>
    38ce:	30 91 25 23 	lds	r19, 0x2325	; 0x802325 <__brkval+0x1>
    38d2:	28 17       	cp	r18, r24
    38d4:	39 07       	cpc	r19, r25
    38d6:	69 f4       	brne	.+26     	; 0x38f2 <free+0x10c>
    38d8:	30 97       	sbiw	r30, 0x00	; 0
    38da:	29 f4       	brne	.+10     	; 0x38e6 <free+0x100>
    38dc:	10 92 26 23 	sts	0x2326, r1	; 0x802326 <__flp>
    38e0:	10 92 27 23 	sts	0x2327, r1	; 0x802327 <__flp+0x1>
    38e4:	02 c0       	rjmp	.+4      	; 0x38ea <free+0x104>
    38e6:	12 82       	std	Z+2, r1	; 0x02
    38e8:	13 82       	std	Z+3, r1	; 0x03
    38ea:	a0 93 24 23 	sts	0x2324, r26	; 0x802324 <__brkval>
    38ee:	b0 93 25 23 	sts	0x2325, r27	; 0x802325 <__brkval+0x1>
    38f2:	df 91       	pop	r29
    38f4:	cf 91       	pop	r28
    38f6:	08 95       	ret

000038f8 <memcpy>:
    38f8:	fb 01       	movw	r30, r22
    38fa:	dc 01       	movw	r26, r24
    38fc:	02 c0       	rjmp	.+4      	; 0x3902 <memcpy+0xa>
    38fe:	01 90       	ld	r0, Z+
    3900:	0d 92       	st	X+, r0
    3902:	41 50       	subi	r20, 0x01	; 1
    3904:	50 40       	sbci	r21, 0x00	; 0
    3906:	d8 f7       	brcc	.-10     	; 0x38fe <memcpy+0x6>
    3908:	08 95       	ret

0000390a <strcmp>:
    390a:	fb 01       	movw	r30, r22
    390c:	dc 01       	movw	r26, r24
    390e:	8d 91       	ld	r24, X+
    3910:	01 90       	ld	r0, Z+
    3912:	80 19       	sub	r24, r0
    3914:	01 10       	cpse	r0, r1
    3916:	d9 f3       	breq	.-10     	; 0x390e <strcmp+0x4>
    3918:	99 0b       	sbc	r25, r25
    391a:	08 95       	ret

0000391c <_exit>:
    391c:	f8 94       	cli

0000391e <__stop_program>:
    391e:	ff cf       	rjmp	.-2      	; 0x391e <__stop_program>
