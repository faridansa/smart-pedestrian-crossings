
Praktikum_5_Template.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003b86  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000050  00802000  00003b86  00003c1a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000359  00802050  00802050  00003c6a  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003c6a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  00003cc8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000006c8  00000000  00000000  00003d10  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0001274b  00000000  00000000  000043d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000306e  00000000  00000000  00016b23  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000b55f  00000000  00000000  00019b91  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016c0  00000000  00000000  000250f0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000353fc  00000000  00000000  000267b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000098c9  00000000  00000000  0005bbac  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008b8  00000000  00000000  00065478  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_macro  0000c726  00000000  00000000  00065d30  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 49 0d 	jmp	0x1a92	; 0x1a92 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	d6 c7       	rjmp	.+4012   	; 0x104a <__vector_39>
      9e:	00 00       	nop
      a0:	0c 94 57 08 	jmp	0x10ae	; 0x10ae <__vector_40>
      a4:	0c 94 89 08 	jmp	0x1112	; 0x1112 <__vector_41>
      a8:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_42>
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	ce c6       	rjmp	.+3484   	; 0xeba <__vector_71>
     11e:	00 00       	nop
     120:	fe c6       	rjmp	.+3580   	; 0xf1e <__vector_72>
     122:	00 00       	nop
     124:	2e c7       	rjmp	.+3676   	; 0xf82 <__vector_73>
     126:	00 00       	nop
     128:	5e c7       	rjmp	.+3772   	; 0xfe6 <__vector_74>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	65 16       	cp	r6, r21
     1fe:	65 16       	cp	r6, r21
     200:	65 16       	cp	r6, r21
     202:	9b 16       	cp	r9, r27
     204:	8b 16       	cp	r8, r27
     206:	98 16       	cp	r9, r24
     208:	65 16       	cp	r6, r21
     20a:	65 16       	cp	r6, r21
     20c:	9b 16       	cp	r9, r27
     20e:	8b 16       	cp	r8, r27

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__trampolines_end+0x21e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__trampolines_end+0x24e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	e6 e8       	ldi	r30, 0x86	; 134
     4ba:	fb e3       	ldi	r31, 0x3B	; 59
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a0 35       	cpi	r26, 0x50	; 80
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	23 e2       	ldi	r18, 0x23	; 35
     4ce:	a0 e5       	ldi	r26, 0x50	; 80
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a9 3a       	cpi	r26, 0xA9	; 169
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 93 18 	call	0x3126	; 0x3126 <main>
     4e0:	0c 94 c1 1d 	jmp	0x3b82	; 0x3b82 <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4e6:	bf 92       	push	r11
     4e8:	cf 92       	push	r12
     4ea:	df 92       	push	r13
     4ec:	ef 92       	push	r14
     4ee:	ff 92       	push	r15
     4f0:	0f 93       	push	r16
     4f2:	1f 93       	push	r17
     4f4:	cf 93       	push	r28
     4f6:	df 93       	push	r29
     4f8:	1f 92       	push	r1
     4fa:	cd b7       	in	r28, 0x3d	; 61
     4fc:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     4fe:	e0 e0       	ldi	r30, 0x00	; 0
     500:	f6 e0       	ldi	r31, 0x06	; 6
     502:	88 e0       	ldi	r24, 0x08	; 8
     504:	86 83       	std	Z+6, r24	; 0x06
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     506:	85 83       	std	Z+5, r24	; 0x05
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     508:	0f 2e       	mov	r0, r31
     50a:	fb e2       	ldi	r31, 0x2B	; 43
     50c:	bf 2e       	mov	r11, r31
     50e:	f0 2d       	mov	r31, r0
     510:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     512:	80 ea       	ldi	r24, 0xA0	; 160
     514:	99 e0       	ldi	r25, 0x09	; 9
     516:	09 d4       	rcall	.+2066   	; 0xd2a <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     518:	c1 2c       	mov	r12, r1
     51a:	d1 2c       	mov	r13, r1
     51c:	76 01       	movw	r14, r12
     51e:	00 e4       	ldi	r16, 0x40	; 64
     520:	12 e4       	ldi	r17, 0x42	; 66
     522:	2f e0       	ldi	r18, 0x0F	; 15
     524:	30 e0       	ldi	r19, 0x00	; 0
     526:	43 e0       	ldi	r20, 0x03	; 3
     528:	be 01       	movw	r22, r28
     52a:	6f 5f       	subi	r22, 0xFF	; 255
     52c:	7f 4f       	sbci	r23, 0xFF	; 255
     52e:	80 ea       	ldi	r24, 0xA0	; 160
     530:	99 e0       	ldi	r25, 0x09	; 9
     532:	2a d4       	rcall	.+2132   	; 0xd88 <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     534:	00 e6       	ldi	r16, 0x60	; 96
     536:	16 e0       	ldi	r17, 0x06	; 6
     538:	ff 24       	eor	r15, r15
     53a:	f3 94       	inc	r15
     53c:	f8 01       	movw	r30, r16
     53e:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     540:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     542:	be 01       	movw	r22, r28
     544:	6f 5f       	subi	r22, 0xFF	; 255
     546:	7f 4f       	sbci	r23, 0xFF	; 255
     548:	80 ea       	ldi	r24, 0xA0	; 160
     54a:	99 e0       	ldi	r25, 0x09	; 9
     54c:	37 d4       	rcall	.+2158   	; 0xdbc <usart_spi_select_device>
     54e:	f8 01       	movw	r30, r16
     550:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     552:	e0 ea       	ldi	r30, 0xA0	; 160
     554:	f9 e0       	ldi	r31, 0x09	; 9
     556:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     558:	85 ff       	sbrs	r24, 5
     55a:	fd cf       	rjmp	.-6      	; 0x556 <st7565r_init+0x70>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     55c:	80 ea       	ldi	r24, 0xA0	; 160
     55e:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     562:	e0 ea       	ldi	r30, 0xA0	; 160
     564:	f9 e0       	ldi	r31, 0x09	; 9
     566:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     568:	86 ff       	sbrs	r24, 6
     56a:	fd cf       	rjmp	.-6      	; 0x566 <st7565r_init+0x80>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     56c:	e0 ea       	ldi	r30, 0xA0	; 160
     56e:	f9 e0       	ldi	r31, 0x09	; 9
     570:	80 e4       	ldi	r24, 0x40	; 64
     572:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     574:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     576:	be 01       	movw	r22, r28
     578:	6f 5f       	subi	r22, 0xFF	; 255
     57a:	7f 4f       	sbci	r23, 0xFF	; 255
     57c:	80 ea       	ldi	r24, 0xA0	; 160
     57e:	99 e0       	ldi	r25, 0x09	; 9
     580:	33 d4       	rcall	.+2150   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     582:	8b e2       	ldi	r24, 0x2B	; 43
     584:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     586:	be 01       	movw	r22, r28
     588:	6f 5f       	subi	r22, 0xFF	; 255
     58a:	7f 4f       	sbci	r23, 0xFF	; 255
     58c:	80 ea       	ldi	r24, 0xA0	; 160
     58e:	99 e0       	ldi	r25, 0x09	; 9
     590:	15 d4       	rcall	.+2090   	; 0xdbc <usart_spi_select_device>
     592:	81 e0       	ldi	r24, 0x01	; 1
     594:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     598:	e0 ea       	ldi	r30, 0xA0	; 160
     59a:	f9 e0       	ldi	r31, 0x09	; 9
     59c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     59e:	85 ff       	sbrs	r24, 5
     5a0:	fd cf       	rjmp	.-6      	; 0x59c <st7565r_init+0xb6>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5a2:	86 ea       	ldi	r24, 0xA6	; 166
     5a4:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5a8:	e0 ea       	ldi	r30, 0xA0	; 160
     5aa:	f9 e0       	ldi	r31, 0x09	; 9
     5ac:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ae:	86 ff       	sbrs	r24, 6
     5b0:	fd cf       	rjmp	.-6      	; 0x5ac <st7565r_init+0xc6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5b2:	e0 ea       	ldi	r30, 0xA0	; 160
     5b4:	f9 e0       	ldi	r31, 0x09	; 9
     5b6:	80 e4       	ldi	r24, 0x40	; 64
     5b8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ba:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5bc:	be 01       	movw	r22, r28
     5be:	6f 5f       	subi	r22, 0xFF	; 255
     5c0:	7f 4f       	sbci	r23, 0xFF	; 255
     5c2:	80 ea       	ldi	r24, 0xA0	; 160
     5c4:	99 e0       	ldi	r25, 0x09	; 9
     5c6:	10 d4       	rcall	.+2080   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5c8:	8b e2       	ldi	r24, 0x2B	; 43
     5ca:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5cc:	be 01       	movw	r22, r28
     5ce:	6f 5f       	subi	r22, 0xFF	; 255
     5d0:	7f 4f       	sbci	r23, 0xFF	; 255
     5d2:	80 ea       	ldi	r24, 0xA0	; 160
     5d4:	99 e0       	ldi	r25, 0x09	; 9
     5d6:	f2 d3       	rcall	.+2020   	; 0xdbc <usart_spi_select_device>
     5d8:	81 e0       	ldi	r24, 0x01	; 1
     5da:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5de:	e0 ea       	ldi	r30, 0xA0	; 160
     5e0:	f9 e0       	ldi	r31, 0x09	; 9
     5e2:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5e4:	85 ff       	sbrs	r24, 5
     5e6:	fd cf       	rjmp	.-6      	; 0x5e2 <st7565r_init+0xfc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5e8:	88 ec       	ldi	r24, 0xC8	; 200
     5ea:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5f4:	86 ff       	sbrs	r24, 6
     5f6:	fd cf       	rjmp	.-6      	; 0x5f2 <st7565r_init+0x10c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5f8:	e0 ea       	ldi	r30, 0xA0	; 160
     5fa:	f9 e0       	ldi	r31, 0x09	; 9
     5fc:	80 e4       	ldi	r24, 0x40	; 64
     5fe:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     600:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     602:	be 01       	movw	r22, r28
     604:	6f 5f       	subi	r22, 0xFF	; 255
     606:	7f 4f       	sbci	r23, 0xFF	; 255
     608:	80 ea       	ldi	r24, 0xA0	; 160
     60a:	99 e0       	ldi	r25, 0x09	; 9
     60c:	ed d3       	rcall	.+2010   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     60e:	8b e2       	ldi	r24, 0x2B	; 43
     610:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     612:	be 01       	movw	r22, r28
     614:	6f 5f       	subi	r22, 0xFF	; 255
     616:	7f 4f       	sbci	r23, 0xFF	; 255
     618:	80 ea       	ldi	r24, 0xA0	; 160
     61a:	99 e0       	ldi	r25, 0x09	; 9
     61c:	cf d3       	rcall	.+1950   	; 0xdbc <usart_spi_select_device>
     61e:	81 e0       	ldi	r24, 0x01	; 1
     620:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     624:	e0 ea       	ldi	r30, 0xA0	; 160
     626:	f9 e0       	ldi	r31, 0x09	; 9
     628:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     62a:	85 ff       	sbrs	r24, 5
     62c:	fd cf       	rjmp	.-6      	; 0x628 <st7565r_init+0x142>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     62e:	82 ea       	ldi	r24, 0xA2	; 162
     630:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     634:	e0 ea       	ldi	r30, 0xA0	; 160
     636:	f9 e0       	ldi	r31, 0x09	; 9
     638:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     63a:	86 ff       	sbrs	r24, 6
     63c:	fd cf       	rjmp	.-6      	; 0x638 <st7565r_init+0x152>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     63e:	e0 ea       	ldi	r30, 0xA0	; 160
     640:	f9 e0       	ldi	r31, 0x09	; 9
     642:	80 e4       	ldi	r24, 0x40	; 64
     644:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     646:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     648:	be 01       	movw	r22, r28
     64a:	6f 5f       	subi	r22, 0xFF	; 255
     64c:	7f 4f       	sbci	r23, 0xFF	; 255
     64e:	80 ea       	ldi	r24, 0xA0	; 160
     650:	99 e0       	ldi	r25, 0x09	; 9
     652:	ca d3       	rcall	.+1940   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     654:	8b e2       	ldi	r24, 0x2B	; 43
     656:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     658:	be 01       	movw	r22, r28
     65a:	6f 5f       	subi	r22, 0xFF	; 255
     65c:	7f 4f       	sbci	r23, 0xFF	; 255
     65e:	80 ea       	ldi	r24, 0xA0	; 160
     660:	99 e0       	ldi	r25, 0x09	; 9
     662:	ac d3       	rcall	.+1880   	; 0xdbc <usart_spi_select_device>
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     66a:	e0 ea       	ldi	r30, 0xA0	; 160
     66c:	f9 e0       	ldi	r31, 0x09	; 9
     66e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     670:	85 ff       	sbrs	r24, 5
     672:	fd cf       	rjmp	.-6      	; 0x66e <st7565r_init+0x188>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     674:	8f e2       	ldi	r24, 0x2F	; 47
     676:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     67a:	e0 ea       	ldi	r30, 0xA0	; 160
     67c:	f9 e0       	ldi	r31, 0x09	; 9
     67e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     680:	86 ff       	sbrs	r24, 6
     682:	fd cf       	rjmp	.-6      	; 0x67e <st7565r_init+0x198>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     684:	e0 ea       	ldi	r30, 0xA0	; 160
     686:	f9 e0       	ldi	r31, 0x09	; 9
     688:	80 e4       	ldi	r24, 0x40	; 64
     68a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68e:	be 01       	movw	r22, r28
     690:	6f 5f       	subi	r22, 0xFF	; 255
     692:	7f 4f       	sbci	r23, 0xFF	; 255
     694:	80 ea       	ldi	r24, 0xA0	; 160
     696:	99 e0       	ldi	r25, 0x09	; 9
     698:	a7 d3       	rcall	.+1870   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	89 d3       	rcall	.+1810   	; 0xdbc <usart_spi_select_device>
     6aa:	81 e0       	ldi	r24, 0x01	; 1
     6ac:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b0:	e0 ea       	ldi	r30, 0xA0	; 160
     6b2:	f9 e0       	ldi	r31, 0x09	; 9
     6b4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b6:	85 ff       	sbrs	r24, 5
     6b8:	fd cf       	rjmp	.-6      	; 0x6b4 <st7565r_init+0x1ce>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6ba:	88 ef       	ldi	r24, 0xF8	; 248
     6bc:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c0:	e0 ea       	ldi	r30, 0xA0	; 160
     6c2:	f9 e0       	ldi	r31, 0x09	; 9
     6c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c6:	86 ff       	sbrs	r24, 6
     6c8:	fd cf       	rjmp	.-6      	; 0x6c4 <st7565r_init+0x1de>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6ca:	e0 ea       	ldi	r30, 0xA0	; 160
     6cc:	f9 e0       	ldi	r31, 0x09	; 9
     6ce:	80 e4       	ldi	r24, 0x40	; 64
     6d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d4:	be 01       	movw	r22, r28
     6d6:	6f 5f       	subi	r22, 0xFF	; 255
     6d8:	7f 4f       	sbci	r23, 0xFF	; 255
     6da:	80 ea       	ldi	r24, 0xA0	; 160
     6dc:	99 e0       	ldi	r25, 0x09	; 9
     6de:	84 d3       	rcall	.+1800   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e0:	8b e2       	ldi	r24, 0x2B	; 43
     6e2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e4:	be 01       	movw	r22, r28
     6e6:	6f 5f       	subi	r22, 0xFF	; 255
     6e8:	7f 4f       	sbci	r23, 0xFF	; 255
     6ea:	80 ea       	ldi	r24, 0xA0	; 160
     6ec:	99 e0       	ldi	r25, 0x09	; 9
     6ee:	66 d3       	rcall	.+1740   	; 0xdbc <usart_spi_select_device>
     6f0:	81 e0       	ldi	r24, 0x01	; 1
     6f2:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6f6:	e0 ea       	ldi	r30, 0xA0	; 160
     6f8:	f9 e0       	ldi	r31, 0x09	; 9
     6fa:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6fc:	85 ff       	sbrs	r24, 5
     6fe:	fd cf       	rjmp	.-6      	; 0x6fa <st7565r_init+0x214>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     700:	10 92 a0 09 	sts	0x09A0, r1
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     704:	e0 ea       	ldi	r30, 0xA0	; 160
     706:	f9 e0       	ldi	r31, 0x09	; 9
     708:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     70a:	86 ff       	sbrs	r24, 6
     70c:	fd cf       	rjmp	.-6      	; 0x708 <st7565r_init+0x222>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     70e:	e0 ea       	ldi	r30, 0xA0	; 160
     710:	f9 e0       	ldi	r31, 0x09	; 9
     712:	80 e4       	ldi	r24, 0x40	; 64
     714:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     716:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     718:	be 01       	movw	r22, r28
     71a:	6f 5f       	subi	r22, 0xFF	; 255
     71c:	7f 4f       	sbci	r23, 0xFF	; 255
     71e:	80 ea       	ldi	r24, 0xA0	; 160
     720:	99 e0       	ldi	r25, 0x09	; 9
     722:	62 d3       	rcall	.+1732   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     724:	8b e2       	ldi	r24, 0x2B	; 43
     726:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     728:	be 01       	movw	r22, r28
     72a:	6f 5f       	subi	r22, 0xFF	; 255
     72c:	7f 4f       	sbci	r23, 0xFF	; 255
     72e:	80 ea       	ldi	r24, 0xA0	; 160
     730:	99 e0       	ldi	r25, 0x09	; 9
     732:	44 d3       	rcall	.+1672   	; 0xdbc <usart_spi_select_device>
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     73a:	e0 ea       	ldi	r30, 0xA0	; 160
     73c:	f9 e0       	ldi	r31, 0x09	; 9
     73e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     740:	85 ff       	sbrs	r24, 5
     742:	fd cf       	rjmp	.-6      	; 0x73e <st7565r_init+0x258>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     744:	81 e2       	ldi	r24, 0x21	; 33
     746:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     74a:	e0 ea       	ldi	r30, 0xA0	; 160
     74c:	f9 e0       	ldi	r31, 0x09	; 9
     74e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     750:	86 ff       	sbrs	r24, 6
     752:	fd cf       	rjmp	.-6      	; 0x74e <st7565r_init+0x268>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	80 e4       	ldi	r24, 0x40	; 64
     75a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     75c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     75e:	be 01       	movw	r22, r28
     760:	6f 5f       	subi	r22, 0xFF	; 255
     762:	7f 4f       	sbci	r23, 0xFF	; 255
     764:	80 ea       	ldi	r24, 0xA0	; 160
     766:	99 e0       	ldi	r25, 0x09	; 9
     768:	3f d3       	rcall	.+1662   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     76a:	8b e2       	ldi	r24, 0x2B	; 43
     76c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     76e:	be 01       	movw	r22, r28
     770:	6f 5f       	subi	r22, 0xFF	; 255
     772:	7f 4f       	sbci	r23, 0xFF	; 255
     774:	80 ea       	ldi	r24, 0xA0	; 160
     776:	99 e0       	ldi	r25, 0x09	; 9
     778:	21 d3       	rcall	.+1602   	; 0xdbc <usart_spi_select_device>
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     780:	e0 ea       	ldi	r30, 0xA0	; 160
     782:	f9 e0       	ldi	r31, 0x09	; 9
     784:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     786:	85 ff       	sbrs	r24, 5
     788:	fd cf       	rjmp	.-6      	; 0x784 <st7565r_init+0x29e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     78a:	81 e8       	ldi	r24, 0x81	; 129
     78c:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     790:	e0 ea       	ldi	r30, 0xA0	; 160
     792:	f9 e0       	ldi	r31, 0x09	; 9
     794:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     796:	86 ff       	sbrs	r24, 6
     798:	fd cf       	rjmp	.-6      	; 0x794 <st7565r_init+0x2ae>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     79a:	e0 ea       	ldi	r30, 0xA0	; 160
     79c:	f9 e0       	ldi	r31, 0x09	; 9
     79e:	80 e4       	ldi	r24, 0x40	; 64
     7a0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7a2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7a4:	be 01       	movw	r22, r28
     7a6:	6f 5f       	subi	r22, 0xFF	; 255
     7a8:	7f 4f       	sbci	r23, 0xFF	; 255
     7aa:	80 ea       	ldi	r24, 0xA0	; 160
     7ac:	99 e0       	ldi	r25, 0x09	; 9
     7ae:	1c d3       	rcall	.+1592   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7b0:	8b e2       	ldi	r24, 0x2B	; 43
     7b2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7b4:	be 01       	movw	r22, r28
     7b6:	6f 5f       	subi	r22, 0xFF	; 255
     7b8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ba:	80 ea       	ldi	r24, 0xA0	; 160
     7bc:	99 e0       	ldi	r25, 0x09	; 9
     7be:	fe d2       	rcall	.+1532   	; 0xdbc <usart_spi_select_device>
     7c0:	81 e0       	ldi	r24, 0x01	; 1
     7c2:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7c6:	e0 ea       	ldi	r30, 0xA0	; 160
     7c8:	f9 e0       	ldi	r31, 0x09	; 9
     7ca:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7cc:	85 ff       	sbrs	r24, 5
     7ce:	fd cf       	rjmp	.-6      	; 0x7ca <st7565r_init+0x2e4>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7d0:	81 e2       	ldi	r24, 0x21	; 33
     7d2:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7d6:	e0 ea       	ldi	r30, 0xA0	; 160
     7d8:	f9 e0       	ldi	r31, 0x09	; 9
     7da:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7dc:	86 ff       	sbrs	r24, 6
     7de:	fd cf       	rjmp	.-6      	; 0x7da <st7565r_init+0x2f4>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7e0:	e0 ea       	ldi	r30, 0xA0	; 160
     7e2:	f9 e0       	ldi	r31, 0x09	; 9
     7e4:	80 e4       	ldi	r24, 0x40	; 64
     7e6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7e8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7ea:	be 01       	movw	r22, r28
     7ec:	6f 5f       	subi	r22, 0xFF	; 255
     7ee:	7f 4f       	sbci	r23, 0xFF	; 255
     7f0:	80 ea       	ldi	r24, 0xA0	; 160
     7f2:	99 e0       	ldi	r25, 0x09	; 9
     7f4:	f9 d2       	rcall	.+1522   	; 0xde8 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7f6:	8b e2       	ldi	r24, 0x2B	; 43
     7f8:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7fa:	be 01       	movw	r22, r28
     7fc:	6f 5f       	subi	r22, 0xFF	; 255
     7fe:	7f 4f       	sbci	r23, 0xFF	; 255
     800:	80 ea       	ldi	r24, 0xA0	; 160
     802:	99 e0       	ldi	r25, 0x09	; 9
     804:	db d2       	rcall	.+1462   	; 0xdbc <usart_spi_select_device>
     806:	81 e0       	ldi	r24, 0x01	; 1
     808:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     80c:	e0 ea       	ldi	r30, 0xA0	; 160
     80e:	f9 e0       	ldi	r31, 0x09	; 9
     810:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     812:	85 ff       	sbrs	r24, 5
     814:	fd cf       	rjmp	.-6      	; 0x810 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     816:	8f ea       	ldi	r24, 0xAF	; 175
     818:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     81c:	e0 ea       	ldi	r30, 0xA0	; 160
     81e:	f9 e0       	ldi	r31, 0x09	; 9
     820:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     822:	86 ff       	sbrs	r24, 6
     824:	fd cf       	rjmp	.-6      	; 0x820 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     826:	e0 ea       	ldi	r30, 0xA0	; 160
     828:	f9 e0       	ldi	r31, 0x09	; 9
     82a:	80 e4       	ldi	r24, 0x40	; 64
     82c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     82e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     830:	be 01       	movw	r22, r28
     832:	6f 5f       	subi	r22, 0xFF	; 255
     834:	7f 4f       	sbci	r23, 0xFF	; 255
     836:	80 ea       	ldi	r24, 0xA0	; 160
     838:	99 e0       	ldi	r25, 0x09	; 9
     83a:	d6 d2       	rcall	.+1452   	; 0xde8 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     83c:	0f 90       	pop	r0
     83e:	df 91       	pop	r29
     840:	cf 91       	pop	r28
     842:	1f 91       	pop	r17
     844:	0f 91       	pop	r16
     846:	ff 90       	pop	r15
     848:	ef 90       	pop	r14
     84a:	df 90       	pop	r13
     84c:	cf 90       	pop	r12
     84e:	bf 90       	pop	r11
     850:	08 95       	ret

00000852 <sysclk_enable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     852:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     854:	f8 94       	cli

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
     856:	e8 2f       	mov	r30, r24
     858:	f0 e0       	ldi	r31, 0x00	; 0
     85a:	e0 59       	subi	r30, 0x90	; 144
     85c:	ff 4f       	sbci	r31, 0xFF	; 255
     85e:	60 95       	com	r22
     860:	80 81       	ld	r24, Z
     862:	68 23       	and	r22, r24
     864:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     866:	9f bf       	out	0x3f, r25	; 63
     868:	08 95       	ret

0000086a <sysclk_disable_module>:

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     86a:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     86c:	f8 94       	cli

void sysclk_disable_module(enum sysclk_port_id port, uint8_t id)
{
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) |= id;
     86e:	e8 2f       	mov	r30, r24
     870:	f0 e0       	ldi	r31, 0x00	; 0
     872:	e0 59       	subi	r30, 0x90	; 144
     874:	ff 4f       	sbci	r31, 0xFF	; 255
     876:	80 81       	ld	r24, Z
     878:	68 2b       	or	r22, r24
     87a:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     87c:	9f bf       	out	0x3f, r25	; 63
     87e:	08 95       	ret

00000880 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     880:	ff 92       	push	r15
     882:	0f 93       	push	r16
     884:	1f 93       	push	r17
     886:	cf 93       	push	r28
     888:	df 93       	push	r29
     88a:	1f 92       	push	r1
     88c:	cd b7       	in	r28, 0x3d	; 61
     88e:	de b7       	in	r29, 0x3e	; 62
     890:	08 2f       	mov	r16, r24
     892:	f6 2e       	mov	r15, r22
     894:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     896:	22 d1       	rcall	.+580    	; 0xadc <gfx_mono_framebuffer_put_byte>
 * \param address the page address
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
     898:	0f 70       	andi	r16, 0x0F	; 15
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     89a:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     89c:	8b e2       	ldi	r24, 0x2B	; 43
     89e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8a0:	be 01       	movw	r22, r28
     8a2:	6f 5f       	subi	r22, 0xFF	; 255
     8a4:	7f 4f       	sbci	r23, 0xFF	; 255
     8a6:	80 ea       	ldi	r24, 0xA0	; 160
     8a8:	99 e0       	ldi	r25, 0x09	; 9
     8aa:	88 d2       	rcall	.+1296   	; 0xdbc <usart_spi_select_device>
     8ac:	81 e0       	ldi	r24, 0x01	; 1
     8ae:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8b2:	e0 ea       	ldi	r30, 0xA0	; 160
     8b4:	f9 e0       	ldi	r31, 0x09	; 9
     8b6:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8b8:	95 ff       	sbrs	r25, 5
     8ba:	fd cf       	rjmp	.-6      	; 0x8b6 <gfx_mono_st7565r_put_byte+0x36>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8bc:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8c0:	e0 ea       	ldi	r30, 0xA0	; 160
     8c2:	f9 e0       	ldi	r31, 0x09	; 9
     8c4:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8c6:	86 ff       	sbrs	r24, 6
     8c8:	fd cf       	rjmp	.-6      	; 0x8c4 <gfx_mono_st7565r_put_byte+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     8ca:	e0 ea       	ldi	r30, 0xA0	; 160
     8cc:	f9 e0       	ldi	r31, 0x09	; 9
     8ce:	80 e4       	ldi	r24, 0x40	; 64
     8d0:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     8d2:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     8d4:	be 01       	movw	r22, r28
     8d6:	6f 5f       	subi	r22, 0xFF	; 255
     8d8:	7f 4f       	sbci	r23, 0xFF	; 255
     8da:	80 ea       	ldi	r24, 0xA0	; 160
     8dc:	99 e0       	ldi	r25, 0x09	; 9
     8de:	84 d2       	rcall	.+1288   	; 0xde8 <usart_spi_deselect_device>
 * \param address the column address
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
     8e0:	0f 2d       	mov	r16, r15
     8e2:	0f 77       	andi	r16, 0x7F	; 127
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     8e4:	02 95       	swap	r16
     8e6:	0f 70       	andi	r16, 0x0F	; 15
     8e8:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8ea:	8b e2       	ldi	r24, 0x2B	; 43
     8ec:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8ee:	be 01       	movw	r22, r28
     8f0:	6f 5f       	subi	r22, 0xFF	; 255
     8f2:	7f 4f       	sbci	r23, 0xFF	; 255
     8f4:	80 ea       	ldi	r24, 0xA0	; 160
     8f6:	99 e0       	ldi	r25, 0x09	; 9
     8f8:	61 d2       	rcall	.+1218   	; 0xdbc <usart_spi_select_device>
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     900:	e0 ea       	ldi	r30, 0xA0	; 160
     902:	f9 e0       	ldi	r31, 0x09	; 9
     904:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     906:	85 ff       	sbrs	r24, 5
     908:	fd cf       	rjmp	.-6      	; 0x904 <gfx_mono_st7565r_put_byte+0x84>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     90a:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     90e:	e0 ea       	ldi	r30, 0xA0	; 160
     910:	f9 e0       	ldi	r31, 0x09	; 9
     912:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     914:	86 ff       	sbrs	r24, 6
     916:	fd cf       	rjmp	.-6      	; 0x912 <gfx_mono_st7565r_put_byte+0x92>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     918:	e0 ea       	ldi	r30, 0xA0	; 160
     91a:	f9 e0       	ldi	r31, 0x09	; 9
     91c:	80 e4       	ldi	r24, 0x40	; 64
     91e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     920:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     922:	be 01       	movw	r22, r28
     924:	6f 5f       	subi	r22, 0xFF	; 255
     926:	7f 4f       	sbci	r23, 0xFF	; 255
     928:	80 ea       	ldi	r24, 0xA0	; 160
     92a:	99 e0       	ldi	r25, 0x09	; 9
     92c:	5d d2       	rcall	.+1210   	; 0xde8 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     92e:	0f 2d       	mov	r16, r15
     930:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     932:	8b e2       	ldi	r24, 0x2B	; 43
     934:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     936:	be 01       	movw	r22, r28
     938:	6f 5f       	subi	r22, 0xFF	; 255
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	80 ea       	ldi	r24, 0xA0	; 160
     93e:	99 e0       	ldi	r25, 0x09	; 9
     940:	3d d2       	rcall	.+1146   	; 0xdbc <usart_spi_select_device>
     942:	81 e0       	ldi	r24, 0x01	; 1
     944:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     948:	e0 ea       	ldi	r30, 0xA0	; 160
     94a:	f9 e0       	ldi	r31, 0x09	; 9
     94c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     94e:	85 ff       	sbrs	r24, 5
     950:	fd cf       	rjmp	.-6      	; 0x94c <gfx_mono_st7565r_put_byte+0xcc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     952:	00 93 a0 09 	sts	0x09A0, r16
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     956:	e0 ea       	ldi	r30, 0xA0	; 160
     958:	f9 e0       	ldi	r31, 0x09	; 9
     95a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     95c:	86 ff       	sbrs	r24, 6
     95e:	fd cf       	rjmp	.-6      	; 0x95a <gfx_mono_st7565r_put_byte+0xda>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     960:	e0 ea       	ldi	r30, 0xA0	; 160
     962:	f9 e0       	ldi	r31, 0x09	; 9
     964:	80 e4       	ldi	r24, 0x40	; 64
     966:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     968:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     96a:	be 01       	movw	r22, r28
     96c:	6f 5f       	subi	r22, 0xFF	; 255
     96e:	7f 4f       	sbci	r23, 0xFF	; 255
     970:	80 ea       	ldi	r24, 0xA0	; 160
     972:	99 e0       	ldi	r25, 0x09	; 9
     974:	39 d2       	rcall	.+1138   	; 0xde8 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     976:	8b e2       	ldi	r24, 0x2B	; 43
     978:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     97a:	be 01       	movw	r22, r28
     97c:	6f 5f       	subi	r22, 0xFF	; 255
     97e:	7f 4f       	sbci	r23, 0xFF	; 255
     980:	80 ea       	ldi	r24, 0xA0	; 160
     982:	99 e0       	ldi	r25, 0x09	; 9
     984:	1b d2       	rcall	.+1078   	; 0xdbc <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     986:	81 e0       	ldi	r24, 0x01	; 1
     988:	80 93 65 06 	sts	0x0665, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     98c:	e0 ea       	ldi	r30, 0xA0	; 160
     98e:	f9 e0       	ldi	r31, 0x09	; 9
     990:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     992:	85 ff       	sbrs	r24, 5
     994:	fd cf       	rjmp	.-6      	; 0x990 <gfx_mono_st7565r_put_byte+0x110>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     996:	10 93 a0 09 	sts	0x09A0, r17
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     99a:	e0 ea       	ldi	r30, 0xA0	; 160
     99c:	f9 e0       	ldi	r31, 0x09	; 9
     99e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9a0:	86 ff       	sbrs	r24, 6
     9a2:	fd cf       	rjmp	.-6      	; 0x99e <gfx_mono_st7565r_put_byte+0x11e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a4:	e0 ea       	ldi	r30, 0xA0	; 160
     9a6:	f9 e0       	ldi	r31, 0x09	; 9
     9a8:	80 e4       	ldi	r24, 0x40	; 64
     9aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9ac:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9ae:	81 e0       	ldi	r24, 0x01	; 1
     9b0:	80 93 66 06 	sts	0x0666, r24
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9b4:	be 01       	movw	r22, r28
     9b6:	6f 5f       	subi	r22, 0xFF	; 255
     9b8:	7f 4f       	sbci	r23, 0xFF	; 255
     9ba:	80 ea       	ldi	r24, 0xA0	; 160
     9bc:	99 e0       	ldi	r25, 0x09	; 9
     9be:	14 d2       	rcall	.+1064   	; 0xde8 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     9c0:	0f 90       	pop	r0
     9c2:	df 91       	pop	r29
     9c4:	cf 91       	pop	r28
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	ff 90       	pop	r15
     9cc:	08 95       	ret

000009ce <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	1f 92       	push	r1
     9d8:	cd b7       	in	r28, 0x3d	; 61
     9da:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     9dc:	80 e5       	ldi	r24, 0x50	; 80
     9de:	90 e2       	ldi	r25, 0x20	; 32
     9e0:	78 d0       	rcall	.+240    	; 0xad2 <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     9e2:	81 dd       	rcall	.-1278   	; 0x4e6 <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9e4:	8b e2       	ldi	r24, 0x2B	; 43
     9e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9e8:	be 01       	movw	r22, r28
     9ea:	6f 5f       	subi	r22, 0xFF	; 255
     9ec:	7f 4f       	sbci	r23, 0xFF	; 255
     9ee:	80 ea       	ldi	r24, 0xA0	; 160
     9f0:	99 e0       	ldi	r25, 0x09	; 9
     9f2:	e4 d1       	rcall	.+968    	; 0xdbc <usart_spi_select_device>
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	80 93 66 06 	sts	0x0666, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9fa:	e0 ea       	ldi	r30, 0xA0	; 160
     9fc:	f9 e0       	ldi	r31, 0x09	; 9
     9fe:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a00:	85 ff       	sbrs	r24, 5
     a02:	fd cf       	rjmp	.-6      	; 0x9fe <gfx_mono_st7565r_init+0x30>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a04:	80 e4       	ldi	r24, 0x40	; 64
     a06:	80 93 a0 09 	sts	0x09A0, r24
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a0a:	e0 ea       	ldi	r30, 0xA0	; 160
     a0c:	f9 e0       	ldi	r31, 0x09	; 9
     a0e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a10:	86 ff       	sbrs	r24, 6
     a12:	fd cf       	rjmp	.-6      	; 0xa0e <gfx_mono_st7565r_init+0x40>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a14:	e0 ea       	ldi	r30, 0xA0	; 160
     a16:	f9 e0       	ldi	r31, 0x09	; 9
     a18:	80 e4       	ldi	r24, 0x40	; 64
     a1a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a1c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a1e:	be 01       	movw	r22, r28
     a20:	6f 5f       	subi	r22, 0xFF	; 255
     a22:	7f 4f       	sbci	r23, 0xFF	; 255
     a24:	80 ea       	ldi	r24, 0xA0	; 160
     a26:	99 e0       	ldi	r25, 0x09	; 9
     a28:	df d1       	rcall	.+958    	; 0xde8 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a2a:	00 e0       	ldi	r16, 0x00	; 0
     a2c:	0a c0       	rjmp	.+20     	; 0xa42 <gfx_mono_st7565r_init+0x74>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a2e:	40 e0       	ldi	r20, 0x00	; 0
     a30:	61 2f       	mov	r22, r17
     a32:	80 2f       	mov	r24, r16
     a34:	25 df       	rcall	.-438    	; 0x880 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a36:	1f 5f       	subi	r17, 0xFF	; 255
     a38:	10 38       	cpi	r17, 0x80	; 128
     a3a:	c9 f7       	brne	.-14     	; 0xa2e <gfx_mono_st7565r_init+0x60>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a3c:	0f 5f       	subi	r16, 0xFF	; 255
     a3e:	04 30       	cpi	r16, 0x04	; 4
     a40:	11 f0       	breq	.+4      	; 0xa46 <gfx_mono_st7565r_init+0x78>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a42:	10 e0       	ldi	r17, 0x00	; 0
     a44:	f4 cf       	rjmp	.-24     	; 0xa2e <gfx_mono_st7565r_init+0x60>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a46:	0f 90       	pop	r0
     a48:	df 91       	pop	r29
     a4a:	cf 91       	pop	r28
     a4c:	1f 91       	pop	r17
     a4e:	0f 91       	pop	r16
     a50:	08 95       	ret

00000a52 <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a52:	ff 92       	push	r15
     a54:	0f 93       	push	r16
     a56:	1f 93       	push	r17
     a58:	cf 93       	push	r28
     a5a:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     a5c:	88 23       	and	r24, r24
     a5e:	8c f1       	brlt	.+98     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a60:	60 32       	cpi	r22, 0x20	; 32
     a62:	78 f5       	brcc	.+94     	; 0xac2 <gfx_mono_st7565r_draw_pixel+0x70>
     a64:	d4 2f       	mov	r29, r20
     a66:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     a68:	f6 2e       	mov	r15, r22
     a6a:	f6 94       	lsr	r15
     a6c:	f6 94       	lsr	r15
     a6e:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     a70:	2f 2d       	mov	r18, r15
     a72:	30 e0       	ldi	r19, 0x00	; 0
     a74:	31 95       	neg	r19
     a76:	21 95       	neg	r18
     a78:	31 09       	sbc	r19, r1
     a7a:	22 0f       	add	r18, r18
     a7c:	33 1f       	adc	r19, r19
     a7e:	22 0f       	add	r18, r18
     a80:	33 1f       	adc	r19, r19
     a82:	22 0f       	add	r18, r18
     a84:	33 1f       	adc	r19, r19
     a86:	26 0f       	add	r18, r22
     a88:	31 1d       	adc	r19, r1
     a8a:	61 e0       	ldi	r22, 0x01	; 1
     a8c:	70 e0       	ldi	r23, 0x00	; 0
     a8e:	8b 01       	movw	r16, r22
     a90:	02 c0       	rjmp	.+4      	; 0xa96 <gfx_mono_st7565r_draw_pixel+0x44>
     a92:	00 0f       	add	r16, r16
     a94:	11 1f       	adc	r17, r17
     a96:	2a 95       	dec	r18
     a98:	e2 f7       	brpl	.-8      	; 0xa92 <gfx_mono_st7565r_draw_pixel+0x40>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     a9a:	68 2f       	mov	r22, r24
     a9c:	8f 2d       	mov	r24, r15
     a9e:	2c d0       	rcall	.+88     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     aa0:	d1 30       	cpi	r29, 0x01	; 1
     aa2:	21 f0       	breq	.+8      	; 0xaac <gfx_mono_st7565r_draw_pixel+0x5a>
     aa4:	28 f0       	brcs	.+10     	; 0xab0 <gfx_mono_st7565r_draw_pixel+0x5e>
     aa6:	d2 30       	cpi	r29, 0x02	; 2
     aa8:	39 f0       	breq	.+14     	; 0xab8 <gfx_mono_st7565r_draw_pixel+0x66>
     aaa:	07 c0       	rjmp	.+14     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aac:	80 2b       	or	r24, r16
		break;
     aae:	05 c0       	rjmp	.+10     	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     ab0:	60 2f       	mov	r22, r16
     ab2:	60 95       	com	r22
     ab4:	86 23       	and	r24, r22
		break;
     ab6:	01 c0       	rjmp	.+2      	; 0xaba <gfx_mono_st7565r_draw_pixel+0x68>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     ab8:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     aba:	48 2f       	mov	r20, r24
     abc:	6c 2f       	mov	r22, r28
     abe:	8f 2d       	mov	r24, r15
     ac0:	df de       	rcall	.-578    	; 0x880 <gfx_mono_st7565r_put_byte>
}
     ac2:	df 91       	pop	r29
     ac4:	cf 91       	pop	r28
     ac6:	1f 91       	pop	r17
     ac8:	0f 91       	pop	r16
     aca:	ff 90       	pop	r15
     acc:	08 95       	ret

00000ace <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ace:	14 c0       	rjmp	.+40     	; 0xaf8 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     ad0:	08 95       	ret

00000ad2 <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
     ad2:	80 93 50 22 	sts	0x2250, r24
     ad6:	90 93 51 22 	sts	0x2251, r25
     ada:	08 95       	ret

00000adc <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
     adc:	20 e8       	ldi	r18, 0x80	; 128
     ade:	82 9f       	mul	r24, r18
     ae0:	c0 01       	movw	r24, r0
     ae2:	11 24       	eor	r1, r1
     ae4:	86 0f       	add	r24, r22
     ae6:	91 1d       	adc	r25, r1
     ae8:	e0 91 50 22 	lds	r30, 0x2250
     aec:	f0 91 51 22 	lds	r31, 0x2251
     af0:	e8 0f       	add	r30, r24
     af2:	f9 1f       	adc	r31, r25
     af4:	40 83       	st	Z, r20
     af6:	08 95       	ret

00000af8 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
     af8:	20 e8       	ldi	r18, 0x80	; 128
     afa:	82 9f       	mul	r24, r18
     afc:	c0 01       	movw	r24, r0
     afe:	11 24       	eor	r1, r1
     b00:	86 0f       	add	r24, r22
     b02:	91 1d       	adc	r25, r1
     b04:	e0 91 50 22 	lds	r30, 0x2250
     b08:	f0 91 51 22 	lds	r31, 0x2251
     b0c:	e8 0f       	add	r30, r24
     b0e:	f9 1f       	adc	r31, r25
}
     b10:	80 81       	ld	r24, Z
     b12:	08 95       	ret

00000b14 <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
     b14:	ff 92       	push	r15
     b16:	0f 93       	push	r16
     b18:	1f 93       	push	r17
     b1a:	cf 93       	push	r28
     b1c:	df 93       	push	r29
     b1e:	e4 2f       	mov	r30, r20
     b20:	f0 e0       	ldi	r31, 0x00	; 0
     b22:	e8 0f       	add	r30, r24
     b24:	f1 1d       	adc	r31, r1
     b26:	e1 38       	cpi	r30, 0x81	; 129
     b28:	f1 05       	cpc	r31, r1
     b2a:	1c f0       	brlt	.+6      	; 0xb32 <gfx_mono_generic_draw_horizontal_line+0x1e>
     b2c:	c0 e8       	ldi	r28, 0x80	; 128
     b2e:	4c 2f       	mov	r20, r28
     b30:	48 1b       	sub	r20, r24
     b32:	44 23       	and	r20, r20
     b34:	09 f4       	brne	.+2      	; 0xb38 <gfx_mono_generic_draw_horizontal_line+0x24>
     b36:	53 c0       	rjmp	.+166    	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b38:	d6 2f       	mov	r29, r22
     b3a:	d6 95       	lsr	r29
     b3c:	d6 95       	lsr	r29
     b3e:	d6 95       	lsr	r29
     b40:	ed 2f       	mov	r30, r29
     b42:	f0 e0       	ldi	r31, 0x00	; 0
     b44:	f1 95       	neg	r31
     b46:	e1 95       	neg	r30
     b48:	f1 09       	sbc	r31, r1
     b4a:	ee 0f       	add	r30, r30
     b4c:	ff 1f       	adc	r31, r31
     b4e:	ee 0f       	add	r30, r30
     b50:	ff 1f       	adc	r31, r31
     b52:	ee 0f       	add	r30, r30
     b54:	ff 1f       	adc	r31, r31
     b56:	df 01       	movw	r26, r30
     b58:	a6 0f       	add	r26, r22
     b5a:	b1 1d       	adc	r27, r1
     b5c:	bd 01       	movw	r22, r26
     b5e:	e1 e0       	ldi	r30, 0x01	; 1
     b60:	f0 e0       	ldi	r31, 0x00	; 0
     b62:	df 01       	movw	r26, r30
     b64:	02 c0       	rjmp	.+4      	; 0xb6a <gfx_mono_generic_draw_horizontal_line+0x56>
     b66:	aa 0f       	add	r26, r26
     b68:	bb 1f       	adc	r27, r27
     b6a:	6a 95       	dec	r22
     b6c:	e2 f7       	brpl	.-8      	; 0xb66 <gfx_mono_generic_draw_horizontal_line+0x52>
     b6e:	fa 2e       	mov	r15, r26
     b70:	21 30       	cpi	r18, 0x01	; 1
     b72:	21 f0       	breq	.+8      	; 0xb7c <gfx_mono_generic_draw_horizontal_line+0x68>
     b74:	98 f0       	brcs	.+38     	; 0xb9c <gfx_mono_generic_draw_horizontal_line+0x88>
     b76:	22 30       	cpi	r18, 0x02	; 2
     b78:	19 f1       	breq	.+70     	; 0xbc0 <gfx_mono_generic_draw_horizontal_line+0xac>
     b7a:	31 c0       	rjmp	.+98     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b7c:	c4 2f       	mov	r28, r20
     b7e:	1f ef       	ldi	r17, 0xFF	; 255
     b80:	18 0f       	add	r17, r24
     b82:	01 2f       	mov	r16, r17
     b84:	0c 0f       	add	r16, r28
     b86:	60 2f       	mov	r22, r16
     b88:	8d 2f       	mov	r24, r29
     b8a:	a1 df       	rcall	.-190    	; 0xace <gfx_mono_st7565r_get_byte>
     b8c:	48 2f       	mov	r20, r24
     b8e:	4f 29       	or	r20, r15
     b90:	60 2f       	mov	r22, r16
     b92:	8d 2f       	mov	r24, r29
     b94:	75 de       	rcall	.-790    	; 0x880 <gfx_mono_st7565r_put_byte>
     b96:	c1 50       	subi	r28, 0x01	; 1
     b98:	a1 f7       	brne	.-24     	; 0xb82 <gfx_mono_generic_draw_horizontal_line+0x6e>
     b9a:	21 c0       	rjmp	.+66     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     b9c:	c4 2f       	mov	r28, r20
     b9e:	1f ef       	ldi	r17, 0xFF	; 255
     ba0:	18 0f       	add	r17, r24
     ba2:	fa 2e       	mov	r15, r26
     ba4:	f0 94       	com	r15
     ba6:	01 2f       	mov	r16, r17
     ba8:	0c 0f       	add	r16, r28
     baa:	60 2f       	mov	r22, r16
     bac:	8d 2f       	mov	r24, r29
     bae:	8f df       	rcall	.-226    	; 0xace <gfx_mono_st7565r_get_byte>
     bb0:	48 2f       	mov	r20, r24
     bb2:	4f 21       	and	r20, r15
     bb4:	60 2f       	mov	r22, r16
     bb6:	8d 2f       	mov	r24, r29
     bb8:	63 de       	rcall	.-826    	; 0x880 <gfx_mono_st7565r_put_byte>
     bba:	c1 50       	subi	r28, 0x01	; 1
     bbc:	a1 f7       	brne	.-24     	; 0xba6 <gfx_mono_generic_draw_horizontal_line+0x92>
     bbe:	0f c0       	rjmp	.+30     	; 0xbde <gfx_mono_generic_draw_horizontal_line+0xca>
     bc0:	c4 2f       	mov	r28, r20
     bc2:	1f ef       	ldi	r17, 0xFF	; 255
     bc4:	18 0f       	add	r17, r24
     bc6:	01 2f       	mov	r16, r17
     bc8:	0c 0f       	add	r16, r28
     bca:	60 2f       	mov	r22, r16
     bcc:	8d 2f       	mov	r24, r29
     bce:	7f df       	rcall	.-258    	; 0xace <gfx_mono_st7565r_get_byte>
     bd0:	48 2f       	mov	r20, r24
     bd2:	4f 25       	eor	r20, r15
     bd4:	60 2f       	mov	r22, r16
     bd6:	8d 2f       	mov	r24, r29
     bd8:	53 de       	rcall	.-858    	; 0x880 <gfx_mono_st7565r_put_byte>
     bda:	c1 50       	subi	r28, 0x01	; 1
     bdc:	a1 f7       	brne	.-24     	; 0xbc6 <gfx_mono_generic_draw_horizontal_line+0xb2>
     bde:	df 91       	pop	r29
     be0:	cf 91       	pop	r28
     be2:	1f 91       	pop	r17
     be4:	0f 91       	pop	r16
     be6:	ff 90       	pop	r15
     be8:	08 95       	ret

00000bea <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
     bea:	ff 92       	push	r15
     bec:	0f 93       	push	r16
     bee:	1f 93       	push	r17
     bf0:	cf 93       	push	r28
     bf2:	df 93       	push	r29
	if (height == 0) {
     bf4:	22 23       	and	r18, r18
     bf6:	69 f0       	breq	.+26     	; 0xc12 <gfx_mono_generic_draw_filled_rect+0x28>
     bf8:	c2 2f       	mov	r28, r18
     bfa:	f4 2e       	mov	r15, r20
     bfc:	18 2f       	mov	r17, r24
     bfe:	df ef       	ldi	r29, 0xFF	; 255
     c00:	d6 0f       	add	r29, r22
     c02:	6d 2f       	mov	r22, r29
     c04:	6c 0f       	add	r22, r28
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
     c06:	20 2f       	mov	r18, r16
     c08:	4f 2d       	mov	r20, r15
     c0a:	81 2f       	mov	r24, r17
     c0c:	83 df       	rcall	.-250    	; 0xb14 <gfx_mono_generic_draw_horizontal_line>
     c0e:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
     c10:	c1 f7       	brne	.-16     	; 0xc02 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
     c12:	df 91       	pop	r29
     c14:	cf 91       	pop	r28
     c16:	1f 91       	pop	r17
     c18:	0f 91       	pop	r16
     c1a:	ff 90       	pop	r15
     c1c:	08 95       	ret

00000c1e <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
     c1e:	af 92       	push	r10
     c20:	bf 92       	push	r11
     c22:	cf 92       	push	r12
     c24:	df 92       	push	r13
     c26:	ef 92       	push	r14
     c28:	ff 92       	push	r15
     c2a:	0f 93       	push	r16
     c2c:	1f 93       	push	r17
     c2e:	cf 93       	push	r28
     c30:	df 93       	push	r29
     c32:	c8 2f       	mov	r28, r24
     c34:	e6 2e       	mov	r14, r22
     c36:	b4 2e       	mov	r11, r20
     c38:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
     c3a:	00 e0       	ldi	r16, 0x00	; 0
     c3c:	f9 01       	movw	r30, r18
     c3e:	24 81       	ldd	r18, Z+4	; 0x04
     c40:	43 81       	ldd	r20, Z+3	; 0x03
     c42:	6b 2d       	mov	r22, r11
     c44:	8e 2d       	mov	r24, r14
     c46:	d1 df       	rcall	.-94     	; 0xbea <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
     c48:	f6 01       	movw	r30, r12
     c4a:	80 81       	ld	r24, Z
     c4c:	81 11       	cpse	r24, r1
     c4e:	39 c0       	rjmp	.+114    	; 0xcc2 <gfx_mono_draw_char+0xa4>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
     c50:	83 81       	ldd	r24, Z+3	; 0x03
     c52:	28 2f       	mov	r18, r24
     c54:	26 95       	lsr	r18
     c56:	26 95       	lsr	r18
     c58:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
     c5a:	87 70       	andi	r24, 0x07	; 7
     c5c:	09 f0       	breq	.+2      	; 0xc60 <gfx_mono_draw_char+0x42>
		char_row_size++;
     c5e:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
     c60:	f6 01       	movw	r30, r12
     c62:	a4 80       	ldd	r10, Z+4	; 0x04
     c64:	2a 9d       	mul	r18, r10
     c66:	90 01       	movw	r18, r0
     c68:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
     c6a:	8c 2f       	mov	r24, r28
     c6c:	90 e0       	ldi	r25, 0x00	; 0
     c6e:	45 81       	ldd	r20, Z+5	; 0x05
     c70:	84 1b       	sub	r24, r20
     c72:	91 09       	sbc	r25, r1
	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
		char_row_size++;
	}

	glyph_data_offset = char_row_size * font->height *
     c74:	28 9f       	mul	r18, r24
     c76:	a0 01       	movw	r20, r0
     c78:	29 9f       	mul	r18, r25
     c7a:	50 0d       	add	r21, r0
     c7c:	38 9f       	mul	r19, r24
     c7e:	50 0d       	add	r21, r0
     c80:	11 24       	eor	r1, r1
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
     c82:	01 81       	ldd	r16, Z+1	; 0x01
     c84:	12 81       	ldd	r17, Z+2	; 0x02
     c86:	04 0f       	add	r16, r20
     c88:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
     c8a:	f6 01       	movw	r30, r12
     c8c:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
     c8e:	ff 20       	and	r15, r15
     c90:	a1 f0       	breq	.+40     	; 0xcba <gfx_mono_draw_char+0x9c>
     c92:	d0 e0       	ldi	r29, 0x00	; 0
     c94:	c0 e0       	ldi	r28, 0x00	; 0
     c96:	8c 2f       	mov	r24, r28
     c98:	8e 0d       	add	r24, r14
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
     c9a:	9c 2f       	mov	r25, r28
     c9c:	97 70       	andi	r25, 0x07	; 7
     c9e:	21 f4       	brne	.+8      	; 0xca8 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
     ca0:	f8 01       	movw	r30, r16
     ca2:	d4 91       	lpm	r29, Z
				glyph_data++;
     ca4:	0f 5f       	subi	r16, 0xFF	; 255
     ca6:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
     ca8:	dd 23       	and	r29, r29
     caa:	1c f4       	brge	.+6      	; 0xcb2 <gfx_mono_draw_char+0x94>
				gfx_mono_draw_pixel(inc_x, inc_y,
     cac:	41 e0       	ldi	r20, 0x01	; 1
     cae:	6b 2d       	mov	r22, r11
     cb0:	d0 de       	rcall	.-608    	; 0xa52 <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
     cb2:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
     cb4:	cf 5f       	subi	r28, 0xFF	; 255
     cb6:	cf 11       	cpse	r28, r15
     cb8:	ee cf       	rjmp	.-36     	; 0xc96 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
     cba:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
     cbc:	aa 94       	dec	r10
	} while (rows_left > 0);
     cbe:	a1 10       	cpse	r10, r1
     cc0:	e4 cf       	rjmp	.-56     	; 0xc8a <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
     cc2:	df 91       	pop	r29
     cc4:	cf 91       	pop	r28
     cc6:	1f 91       	pop	r17
     cc8:	0f 91       	pop	r16
     cca:	ff 90       	pop	r15
     ccc:	ef 90       	pop	r14
     cce:	df 90       	pop	r13
     cd0:	cf 90       	pop	r12
     cd2:	bf 90       	pop	r11
     cd4:	af 90       	pop	r10
     cd6:	08 95       	ret

00000cd8 <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
     cd8:	df 92       	push	r13
     cda:	ef 92       	push	r14
     cdc:	ff 92       	push	r15
     cde:	0f 93       	push	r16
     ce0:	1f 93       	push	r17
     ce2:	cf 93       	push	r28
     ce4:	df 93       	push	r29
     ce6:	04 2f       	mov	r16, r20
     ce8:	79 01       	movw	r14, r18
     cea:	ec 01       	movw	r28, r24
     cec:	16 2f       	mov	r17, r22

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cee:	d6 2e       	mov	r13, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
     cf0:	89 91       	ld	r24, Y+
     cf2:	8a 30       	cpi	r24, 0x0A	; 10
     cf4:	31 f4       	brne	.+12     	; 0xd02 <gfx_mono_draw_string+0x2a>
     cf6:	f7 01       	movw	r30, r14
     cf8:	84 81       	ldd	r24, Z+4	; 0x04
     cfa:	8f 5f       	subi	r24, 0xFF	; 255
			x = start_of_string_position_x;
			y += font->height + 1;
     cfc:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
     cfe:	1d 2d       	mov	r17, r13
     d00:	09 c0       	rjmp	.+18     	; 0xd14 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
     d02:	8d 30       	cpi	r24, 0x0D	; 13
     d04:	39 f0       	breq	.+14     	; 0xd14 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
     d06:	97 01       	movw	r18, r14
     d08:	40 2f       	mov	r20, r16
     d0a:	61 2f       	mov	r22, r17
     d0c:	88 df       	rcall	.-240    	; 0xc1e <gfx_mono_draw_char>
			x += font->width;
     d0e:	f7 01       	movw	r30, r14
     d10:	83 81       	ldd	r24, Z+3	; 0x03
     d12:	18 0f       	add	r17, r24
		}
	} while (*(++str));
     d14:	88 81       	ld	r24, Y
     d16:	81 11       	cpse	r24, r1
     d18:	eb cf       	rjmp	.-42     	; 0xcf0 <gfx_mono_draw_string+0x18>
}
     d1a:	df 91       	pop	r29
     d1c:	cf 91       	pop	r28
     d1e:	1f 91       	pop	r17
     d20:	0f 91       	pop	r16
     d22:	ff 90       	pop	r15
     d24:	ef 90       	pop	r14
     d26:	df 90       	pop	r13
     d28:	08 95       	ret

00000d2a <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
     d2a:	80 3a       	cpi	r24, 0xA0	; 160
     d2c:	28 e0       	ldi	r18, 0x08	; 8
     d2e:	92 07       	cpc	r25, r18
     d30:	21 f4       	brne	.+8      	; 0xd3a <usart_spi_init+0x10>
     d32:	60 e1       	ldi	r22, 0x10	; 16
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	8d cd       	rjmp	.-1254   	; 0x852 <sysclk_enable_module>
     d38:	08 95       	ret
     d3a:	80 3b       	cpi	r24, 0xB0	; 176
     d3c:	28 e0       	ldi	r18, 0x08	; 8
     d3e:	92 07       	cpc	r25, r18
     d40:	21 f4       	brne	.+8      	; 0xd4a <usart_spi_init+0x20>
     d42:	60 e2       	ldi	r22, 0x20	; 32
     d44:	83 e0       	ldi	r24, 0x03	; 3
     d46:	85 cd       	rjmp	.-1270   	; 0x852 <sysclk_enable_module>
     d48:	08 95       	ret
     d4a:	80 3a       	cpi	r24, 0xA0	; 160
     d4c:	29 e0       	ldi	r18, 0x09	; 9
     d4e:	92 07       	cpc	r25, r18
     d50:	21 f4       	brne	.+8      	; 0xd5a <usart_spi_init+0x30>
     d52:	60 e1       	ldi	r22, 0x10	; 16
     d54:	84 e0       	ldi	r24, 0x04	; 4
     d56:	7d cd       	rjmp	.-1286   	; 0x852 <sysclk_enable_module>
     d58:	08 95       	ret
     d5a:	80 3b       	cpi	r24, 0xB0	; 176
     d5c:	29 e0       	ldi	r18, 0x09	; 9
     d5e:	92 07       	cpc	r25, r18
     d60:	21 f4       	brne	.+8      	; 0xd6a <usart_spi_init+0x40>
     d62:	60 e2       	ldi	r22, 0x20	; 32
     d64:	84 e0       	ldi	r24, 0x04	; 4
     d66:	75 cd       	rjmp	.-1302   	; 0x852 <sysclk_enable_module>
     d68:	08 95       	ret
     d6a:	80 3a       	cpi	r24, 0xA0	; 160
     d6c:	2a e0       	ldi	r18, 0x0A	; 10
     d6e:	92 07       	cpc	r25, r18
     d70:	21 f4       	brne	.+8      	; 0xd7a <usart_spi_init+0x50>
     d72:	60 e1       	ldi	r22, 0x10	; 16
     d74:	85 e0       	ldi	r24, 0x05	; 5
     d76:	6d cd       	rjmp	.-1318   	; 0x852 <sysclk_enable_module>
     d78:	08 95       	ret
     d7a:	80 3a       	cpi	r24, 0xA0	; 160
     d7c:	9b 40       	sbci	r25, 0x0B	; 11
     d7e:	19 f4       	brne	.+6      	; 0xd86 <usart_spi_init+0x5c>
     d80:	60 e1       	ldi	r22, 0x10	; 16
     d82:	86 e0       	ldi	r24, 0x06	; 6
     d84:	66 cd       	rjmp	.-1332   	; 0x852 <sysclk_enable_module>
     d86:	08 95       	ret

00000d88 <usart_spi_setup_device>:
     d88:	0f 93       	push	r16
     d8a:	1f 93       	push	r17
     d8c:	cf 93       	push	r28
     d8e:	df 93       	push	r29
     d90:	00 d0       	rcall	.+0      	; 0xd92 <usart_spi_setup_device+0xa>
     d92:	00 d0       	rcall	.+0      	; 0xd94 <usart_spi_setup_device+0xc>
     d94:	cd b7       	in	r28, 0x3d	; 61
     d96:	de b7       	in	r29, 0x3e	; 62
     d98:	09 83       	std	Y+1, r16	; 0x01
     d9a:	1a 83       	std	Y+2, r17	; 0x02
     d9c:	2b 83       	std	Y+3, r18	; 0x03
     d9e:	3c 83       	std	Y+4, r19	; 0x04
     da0:	4d 83       	std	Y+5, r20	; 0x05
     da2:	1e 82       	std	Y+6, r1	; 0x06
     da4:	be 01       	movw	r22, r28
     da6:	6f 5f       	subi	r22, 0xFF	; 255
     da8:	7f 4f       	sbci	r23, 0xFF	; 255
     daa:	38 d3       	rcall	.+1648   	; 0x141c <usart_init_spi>
     dac:	26 96       	adiw	r28, 0x06	; 6
     dae:	cd bf       	out	0x3d, r28	; 61
     db0:	de bf       	out	0x3e, r29	; 62
     db2:	df 91       	pop	r29
     db4:	cf 91       	pop	r28
     db6:	1f 91       	pop	r17
     db8:	0f 91       	pop	r16
     dba:	08 95       	ret

00000dbc <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
     dbc:	fb 01       	movw	r30, r22
     dbe:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dc0:	e8 2f       	mov	r30, r24
     dc2:	e6 95       	lsr	r30
     dc4:	e6 95       	lsr	r30
     dc6:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     dc8:	40 e2       	ldi	r20, 0x20	; 32
     dca:	e4 9f       	mul	r30, r20
     dcc:	f0 01       	movw	r30, r0
     dce:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dd0:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dd2:	87 70       	andi	r24, 0x07	; 7
     dd4:	21 e0       	ldi	r18, 0x01	; 1
     dd6:	30 e0       	ldi	r19, 0x00	; 0
     dd8:	a9 01       	movw	r20, r18
     dda:	02 c0       	rjmp	.+4      	; 0xde0 <usart_spi_select_device+0x24>
     ddc:	44 0f       	add	r20, r20
     dde:	55 1f       	adc	r21, r21
     de0:	8a 95       	dec	r24
     de2:	e2 f7       	brpl	.-8      	; 0xddc <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     de4:	46 83       	std	Z+6, r20	; 0x06
     de6:	08 95       	ret

00000de8 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
     de8:	fb 01       	movw	r30, r22
     dea:	80 81       	ld	r24, Z
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
     dec:	e8 2f       	mov	r30, r24
     dee:	e6 95       	lsr	r30
     df0:	e6 95       	lsr	r30
     df2:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
     df4:	40 e2       	ldi	r20, 0x20	; 32
     df6:	e4 9f       	mul	r30, r20
     df8:	f0 01       	movw	r30, r0
     dfa:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     dfc:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     dfe:	87 70       	andi	r24, 0x07	; 7
     e00:	21 e0       	ldi	r18, 0x01	; 1
     e02:	30 e0       	ldi	r19, 0x00	; 0
     e04:	a9 01       	movw	r20, r18
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <usart_spi_deselect_device+0x24>
     e08:	44 0f       	add	r20, r20
     e0a:	55 1f       	adc	r21, r21
     e0c:	8a 95       	dec	r24
     e0e:	e2 f7       	brpl	.-8      	; 0xe08 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     e10:	45 83       	std	Z+5, r20	; 0x05
     e12:	08 95       	ret

00000e14 <adc_enable_clock>:
void adc_enable_clock(ADC_t *adc);

void adc_enable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e14:	81 15       	cp	r24, r1
     e16:	22 e0       	ldi	r18, 0x02	; 2
     e18:	92 07       	cpc	r25, r18
     e1a:	61 f4       	brne	.+24     	; 0xe34 <adc_enable_clock+0x20>
		Assert(adca_enable_count < 0xff);
		if (!adca_enable_count++) {
     e1c:	80 91 53 22 	lds	r24, 0x2253
     e20:	91 e0       	ldi	r25, 0x01	; 1
     e22:	98 0f       	add	r25, r24
     e24:	90 93 53 22 	sts	0x2253, r25
     e28:	81 11       	cpse	r24, r1
     e2a:	12 c0       	rjmp	.+36     	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e2c:	62 e0       	ldi	r22, 0x02	; 2
     e2e:	81 e0       	ldi	r24, 0x01	; 1
     e30:	10 cd       	rjmp	.-1504   	; 0x852 <sysclk_enable_module>
     e32:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e34:	80 34       	cpi	r24, 0x40	; 64
     e36:	92 40       	sbci	r25, 0x02	; 2
     e38:	59 f4       	brne	.+22     	; 0xe50 <adc_enable_clock+0x3c>
		Assert(adcb_enable_count < 0xff);
		if (!adcb_enable_count++) {
     e3a:	80 91 52 22 	lds	r24, 0x2252
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	98 0f       	add	r25, r24
     e42:	90 93 52 22 	sts	0x2252, r25
     e46:	81 11       	cpse	r24, r1
     e48:	03 c0       	rjmp	.+6      	; 0xe50 <adc_enable_clock+0x3c>
			sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e4a:	62 e0       	ldi	r22, 0x02	; 2
     e4c:	82 e0       	ldi	r24, 0x02	; 2
     e4e:	01 cd       	rjmp	.-1534   	; 0x852 <sysclk_enable_module>
     e50:	08 95       	ret

00000e52 <adc_disable_clock>:
void adc_disable_clock(ADC_t *adc);

void adc_disable_clock(ADC_t *adc)
{
#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)(&ADCA)) {
     e52:	81 15       	cp	r24, r1
     e54:	22 e0       	ldi	r18, 0x02	; 2
     e56:	92 07       	cpc	r25, r18
     e58:	59 f4       	brne	.+22     	; 0xe70 <adc_disable_clock+0x1e>
		Assert(adca_enable_count);
		if (!--adca_enable_count) {
     e5a:	80 91 53 22 	lds	r24, 0x2253
     e5e:	81 50       	subi	r24, 0x01	; 1
     e60:	80 93 53 22 	sts	0x2253, r24
     e64:	81 11       	cpse	r24, r1
     e66:	11 c0       	rjmp	.+34     	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     e68:	62 e0       	ldi	r22, 0x02	; 2
     e6a:	81 e0       	ldi	r24, 0x01	; 1
     e6c:	fe cc       	rjmp	.-1540   	; 0x86a <sysclk_disable_module>
     e6e:	08 95       	ret
		}
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)(&ADCB)) {
     e70:	80 34       	cpi	r24, 0x40	; 64
     e72:	92 40       	sbci	r25, 0x02	; 2
     e74:	51 f4       	brne	.+20     	; 0xe8a <adc_disable_clock+0x38>
		Assert(adcb_enable_count);
		if (!--adcb_enable_count) {
     e76:	80 91 52 22 	lds	r24, 0x2252
     e7a:	81 50       	subi	r24, 0x01	; 1
     e7c:	80 93 52 22 	sts	0x2252, r24
     e80:	81 11       	cpse	r24, r1
     e82:	03 c0       	rjmp	.+6      	; 0xe8a <adc_disable_clock+0x38>
			sysclk_disable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     e84:	62 e0       	ldi	r22, 0x02	; 2
     e86:	82 e0       	ldi	r24, 0x02	; 2
     e88:	f0 cc       	rjmp	.-1568   	; 0x86a <sysclk_disable_module>
     e8a:	08 95       	ret

00000e8c <adc_enable>:
 * a conversion. For most XMEGA devices the start-up time is specified
 * to be a maximum of 24 ADC clock cycles. Please verify the start-up time for
 * the device in use.
 */
void adc_enable(ADC_t *adc)
{
     e8c:	1f 93       	push	r17
     e8e:	cf 93       	push	r28
     e90:	df 93       	push	r29
     e92:	ec 01       	movw	r28, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     e94:	1f b7       	in	r17, 0x3f	; 63
	cpu_irq_disable();
     e96:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();
	adc_enable_clock(adc);
     e98:	bd df       	rcall	.-134    	; 0xe14 <adc_enable_clock>
	adc->CTRLA |= ADC_ENABLE_bm;
     e9a:	88 81       	ld	r24, Y
     e9c:	81 60       	ori	r24, 0x01	; 1
     e9e:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     ea0:	1f bf       	out	0x3f, r17	; 63

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
     ea2:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
     ea4:	f8 94       	cli
	Assert(sleepmgr_locks[mode] < 0xff);

	// Enter a critical section
	flags = cpu_irq_save();

	++sleepmgr_locks[mode];
     ea6:	eb e9       	ldi	r30, 0x9B	; 155
     ea8:	f3 e2       	ldi	r31, 0x23	; 35
     eaa:	81 81       	ldd	r24, Z+1	; 0x01
     eac:	8f 5f       	subi	r24, 0xFF	; 255
     eae:	81 83       	std	Z+1, r24	; 0x01
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     eb0:	9f bf       	out	0x3f, r25	; 63
	cpu_irq_restore(flags);

	sleepmgr_lock_mode(SLEEPMGR_IDLE);
}
     eb2:	df 91       	pop	r29
     eb4:	cf 91       	pop	r28
     eb6:	1f 91       	pop	r17
     eb8:	08 95       	ret

00000eba <__vector_71>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH0_vect)
{
     eba:	1f 92       	push	r1
     ebc:	0f 92       	push	r0
     ebe:	0f b6       	in	r0, 0x3f	; 63
     ec0:	0f 92       	push	r0
     ec2:	11 24       	eor	r1, r1
     ec4:	0b b6       	in	r0, 0x3b	; 59
     ec6:	0f 92       	push	r0
     ec8:	2f 93       	push	r18
     eca:	3f 93       	push	r19
     ecc:	4f 93       	push	r20
     ece:	5f 93       	push	r21
     ed0:	6f 93       	push	r22
     ed2:	7f 93       	push	r23
     ed4:	8f 93       	push	r24
     ed6:	9f 93       	push	r25
     ed8:	af 93       	push	r26
     eda:	bf 93       	push	r27
     edc:	ef 93       	push	r30
     ede:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH0, adc_get_result(&ADCA, ADC_CH0));
     ee0:	40 91 24 02 	lds	r20, 0x0224
     ee4:	50 91 25 02 	lds	r21, 0x0225
     ee8:	e0 91 a3 23 	lds	r30, 0x23A3
     eec:	f0 91 a4 23 	lds	r31, 0x23A4
     ef0:	61 e0       	ldi	r22, 0x01	; 1
     ef2:	80 e0       	ldi	r24, 0x00	; 0
     ef4:	92 e0       	ldi	r25, 0x02	; 2
     ef6:	19 95       	eicall
}
     ef8:	ff 91       	pop	r31
     efa:	ef 91       	pop	r30
     efc:	bf 91       	pop	r27
     efe:	af 91       	pop	r26
     f00:	9f 91       	pop	r25
     f02:	8f 91       	pop	r24
     f04:	7f 91       	pop	r23
     f06:	6f 91       	pop	r22
     f08:	5f 91       	pop	r21
     f0a:	4f 91       	pop	r20
     f0c:	3f 91       	pop	r19
     f0e:	2f 91       	pop	r18
     f10:	0f 90       	pop	r0
     f12:	0b be       	out	0x3b, r0	; 59
     f14:	0f 90       	pop	r0
     f16:	0f be       	out	0x3f, r0	; 63
     f18:	0f 90       	pop	r0
     f1a:	1f 90       	pop	r1
     f1c:	18 95       	reti

00000f1e <__vector_72>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH1_vect)
{
     f1e:	1f 92       	push	r1
     f20:	0f 92       	push	r0
     f22:	0f b6       	in	r0, 0x3f	; 63
     f24:	0f 92       	push	r0
     f26:	11 24       	eor	r1, r1
     f28:	0b b6       	in	r0, 0x3b	; 59
     f2a:	0f 92       	push	r0
     f2c:	2f 93       	push	r18
     f2e:	3f 93       	push	r19
     f30:	4f 93       	push	r20
     f32:	5f 93       	push	r21
     f34:	6f 93       	push	r22
     f36:	7f 93       	push	r23
     f38:	8f 93       	push	r24
     f3a:	9f 93       	push	r25
     f3c:	af 93       	push	r26
     f3e:	bf 93       	push	r27
     f40:	ef 93       	push	r30
     f42:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH1, adc_get_result(&ADCA, ADC_CH1));
     f44:	40 91 2c 02 	lds	r20, 0x022C
     f48:	50 91 2d 02 	lds	r21, 0x022D
     f4c:	e0 91 a3 23 	lds	r30, 0x23A3
     f50:	f0 91 a4 23 	lds	r31, 0x23A4
     f54:	62 e0       	ldi	r22, 0x02	; 2
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	92 e0       	ldi	r25, 0x02	; 2
     f5a:	19 95       	eicall
}
     f5c:	ff 91       	pop	r31
     f5e:	ef 91       	pop	r30
     f60:	bf 91       	pop	r27
     f62:	af 91       	pop	r26
     f64:	9f 91       	pop	r25
     f66:	8f 91       	pop	r24
     f68:	7f 91       	pop	r23
     f6a:	6f 91       	pop	r22
     f6c:	5f 91       	pop	r21
     f6e:	4f 91       	pop	r20
     f70:	3f 91       	pop	r19
     f72:	2f 91       	pop	r18
     f74:	0f 90       	pop	r0
     f76:	0b be       	out	0x3b, r0	; 59
     f78:	0f 90       	pop	r0
     f7a:	0f be       	out	0x3f, r0	; 63
     f7c:	0f 90       	pop	r0
     f7e:	1f 90       	pop	r1
     f80:	18 95       	reti

00000f82 <__vector_73>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH2_vect)
{
     f82:	1f 92       	push	r1
     f84:	0f 92       	push	r0
     f86:	0f b6       	in	r0, 0x3f	; 63
     f88:	0f 92       	push	r0
     f8a:	11 24       	eor	r1, r1
     f8c:	0b b6       	in	r0, 0x3b	; 59
     f8e:	0f 92       	push	r0
     f90:	2f 93       	push	r18
     f92:	3f 93       	push	r19
     f94:	4f 93       	push	r20
     f96:	5f 93       	push	r21
     f98:	6f 93       	push	r22
     f9a:	7f 93       	push	r23
     f9c:	8f 93       	push	r24
     f9e:	9f 93       	push	r25
     fa0:	af 93       	push	r26
     fa2:	bf 93       	push	r27
     fa4:	ef 93       	push	r30
     fa6:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH2, adc_get_result(&ADCA, ADC_CH2));
     fa8:	40 91 34 02 	lds	r20, 0x0234
     fac:	50 91 35 02 	lds	r21, 0x0235
     fb0:	e0 91 a3 23 	lds	r30, 0x23A3
     fb4:	f0 91 a4 23 	lds	r31, 0x23A4
     fb8:	64 e0       	ldi	r22, 0x04	; 4
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	92 e0       	ldi	r25, 0x02	; 2
     fbe:	19 95       	eicall
}
     fc0:	ff 91       	pop	r31
     fc2:	ef 91       	pop	r30
     fc4:	bf 91       	pop	r27
     fc6:	af 91       	pop	r26
     fc8:	9f 91       	pop	r25
     fca:	8f 91       	pop	r24
     fcc:	7f 91       	pop	r23
     fce:	6f 91       	pop	r22
     fd0:	5f 91       	pop	r21
     fd2:	4f 91       	pop	r20
     fd4:	3f 91       	pop	r19
     fd6:	2f 91       	pop	r18
     fd8:	0f 90       	pop	r0
     fda:	0b be       	out	0x3b, r0	; 59
     fdc:	0f 90       	pop	r0
     fde:	0f be       	out	0x3f, r0	; 63
     fe0:	0f 90       	pop	r0
     fe2:	1f 90       	pop	r1
     fe4:	18 95       	reti

00000fe6 <__vector_74>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCA_CH3_vect)
{
     fe6:	1f 92       	push	r1
     fe8:	0f 92       	push	r0
     fea:	0f b6       	in	r0, 0x3f	; 63
     fec:	0f 92       	push	r0
     fee:	11 24       	eor	r1, r1
     ff0:	0b b6       	in	r0, 0x3b	; 59
     ff2:	0f 92       	push	r0
     ff4:	2f 93       	push	r18
     ff6:	3f 93       	push	r19
     ff8:	4f 93       	push	r20
     ffa:	5f 93       	push	r21
     ffc:	6f 93       	push	r22
     ffe:	7f 93       	push	r23
    1000:	8f 93       	push	r24
    1002:	9f 93       	push	r25
    1004:	af 93       	push	r26
    1006:	bf 93       	push	r27
    1008:	ef 93       	push	r30
    100a:	ff 93       	push	r31
	adca_callback(&ADCA, ADC_CH3, adc_get_result(&ADCA, ADC_CH3));
    100c:	40 91 3c 02 	lds	r20, 0x023C
    1010:	50 91 3d 02 	lds	r21, 0x023D
    1014:	e0 91 a3 23 	lds	r30, 0x23A3
    1018:	f0 91 a4 23 	lds	r31, 0x23A4
    101c:	68 e0       	ldi	r22, 0x08	; 8
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	92 e0       	ldi	r25, 0x02	; 2
    1022:	19 95       	eicall
}
    1024:	ff 91       	pop	r31
    1026:	ef 91       	pop	r30
    1028:	bf 91       	pop	r27
    102a:	af 91       	pop	r26
    102c:	9f 91       	pop	r25
    102e:	8f 91       	pop	r24
    1030:	7f 91       	pop	r23
    1032:	6f 91       	pop	r22
    1034:	5f 91       	pop	r21
    1036:	4f 91       	pop	r20
    1038:	3f 91       	pop	r19
    103a:	2f 91       	pop	r18
    103c:	0f 90       	pop	r0
    103e:	0b be       	out	0x3b, r0	; 59
    1040:	0f 90       	pop	r0
    1042:	0f be       	out	0x3f, r0	; 63
    1044:	0f 90       	pop	r0
    1046:	1f 90       	pop	r1
    1048:	18 95       	reti

0000104a <__vector_39>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH0_vect)
{
    104a:	1f 92       	push	r1
    104c:	0f 92       	push	r0
    104e:	0f b6       	in	r0, 0x3f	; 63
    1050:	0f 92       	push	r0
    1052:	11 24       	eor	r1, r1
    1054:	0b b6       	in	r0, 0x3b	; 59
    1056:	0f 92       	push	r0
    1058:	2f 93       	push	r18
    105a:	3f 93       	push	r19
    105c:	4f 93       	push	r20
    105e:	5f 93       	push	r21
    1060:	6f 93       	push	r22
    1062:	7f 93       	push	r23
    1064:	8f 93       	push	r24
    1066:	9f 93       	push	r25
    1068:	af 93       	push	r26
    106a:	bf 93       	push	r27
    106c:	ef 93       	push	r30
    106e:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH0, adc_get_result(&ADCB, ADC_CH0));
    1070:	40 91 64 02 	lds	r20, 0x0264
    1074:	50 91 65 02 	lds	r21, 0x0265
    1078:	e0 91 a1 23 	lds	r30, 0x23A1
    107c:	f0 91 a2 23 	lds	r31, 0x23A2
    1080:	61 e0       	ldi	r22, 0x01	; 1
    1082:	80 e4       	ldi	r24, 0x40	; 64
    1084:	92 e0       	ldi	r25, 0x02	; 2
    1086:	19 95       	eicall
}
    1088:	ff 91       	pop	r31
    108a:	ef 91       	pop	r30
    108c:	bf 91       	pop	r27
    108e:	af 91       	pop	r26
    1090:	9f 91       	pop	r25
    1092:	8f 91       	pop	r24
    1094:	7f 91       	pop	r23
    1096:	6f 91       	pop	r22
    1098:	5f 91       	pop	r21
    109a:	4f 91       	pop	r20
    109c:	3f 91       	pop	r19
    109e:	2f 91       	pop	r18
    10a0:	0f 90       	pop	r0
    10a2:	0b be       	out	0x3b, r0	; 59
    10a4:	0f 90       	pop	r0
    10a6:	0f be       	out	0x3f, r0	; 63
    10a8:	0f 90       	pop	r0
    10aa:	1f 90       	pop	r1
    10ac:	18 95       	reti

000010ae <__vector_40>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH1_vect)
{
    10ae:	1f 92       	push	r1
    10b0:	0f 92       	push	r0
    10b2:	0f b6       	in	r0, 0x3f	; 63
    10b4:	0f 92       	push	r0
    10b6:	11 24       	eor	r1, r1
    10b8:	0b b6       	in	r0, 0x3b	; 59
    10ba:	0f 92       	push	r0
    10bc:	2f 93       	push	r18
    10be:	3f 93       	push	r19
    10c0:	4f 93       	push	r20
    10c2:	5f 93       	push	r21
    10c4:	6f 93       	push	r22
    10c6:	7f 93       	push	r23
    10c8:	8f 93       	push	r24
    10ca:	9f 93       	push	r25
    10cc:	af 93       	push	r26
    10ce:	bf 93       	push	r27
    10d0:	ef 93       	push	r30
    10d2:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH1, adc_get_result(&ADCB, ADC_CH1));
    10d4:	40 91 6c 02 	lds	r20, 0x026C
    10d8:	50 91 6d 02 	lds	r21, 0x026D
    10dc:	e0 91 a1 23 	lds	r30, 0x23A1
    10e0:	f0 91 a2 23 	lds	r31, 0x23A2
    10e4:	62 e0       	ldi	r22, 0x02	; 2
    10e6:	80 e4       	ldi	r24, 0x40	; 64
    10e8:	92 e0       	ldi	r25, 0x02	; 2
    10ea:	19 95       	eicall
}
    10ec:	ff 91       	pop	r31
    10ee:	ef 91       	pop	r30
    10f0:	bf 91       	pop	r27
    10f2:	af 91       	pop	r26
    10f4:	9f 91       	pop	r25
    10f6:	8f 91       	pop	r24
    10f8:	7f 91       	pop	r23
    10fa:	6f 91       	pop	r22
    10fc:	5f 91       	pop	r21
    10fe:	4f 91       	pop	r20
    1100:	3f 91       	pop	r19
    1102:	2f 91       	pop	r18
    1104:	0f 90       	pop	r0
    1106:	0b be       	out	0x3b, r0	; 59
    1108:	0f 90       	pop	r0
    110a:	0f be       	out	0x3f, r0	; 63
    110c:	0f 90       	pop	r0
    110e:	1f 90       	pop	r1
    1110:	18 95       	reti

00001112 <__vector_41>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH2_vect)
{
    1112:	1f 92       	push	r1
    1114:	0f 92       	push	r0
    1116:	0f b6       	in	r0, 0x3f	; 63
    1118:	0f 92       	push	r0
    111a:	11 24       	eor	r1, r1
    111c:	0b b6       	in	r0, 0x3b	; 59
    111e:	0f 92       	push	r0
    1120:	2f 93       	push	r18
    1122:	3f 93       	push	r19
    1124:	4f 93       	push	r20
    1126:	5f 93       	push	r21
    1128:	6f 93       	push	r22
    112a:	7f 93       	push	r23
    112c:	8f 93       	push	r24
    112e:	9f 93       	push	r25
    1130:	af 93       	push	r26
    1132:	bf 93       	push	r27
    1134:	ef 93       	push	r30
    1136:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH2, adc_get_result(&ADCB, ADC_CH2));
    1138:	40 91 74 02 	lds	r20, 0x0274
    113c:	50 91 75 02 	lds	r21, 0x0275
    1140:	e0 91 a1 23 	lds	r30, 0x23A1
    1144:	f0 91 a2 23 	lds	r31, 0x23A2
    1148:	64 e0       	ldi	r22, 0x04	; 4
    114a:	80 e4       	ldi	r24, 0x40	; 64
    114c:	92 e0       	ldi	r25, 0x02	; 2
    114e:	19 95       	eicall
}
    1150:	ff 91       	pop	r31
    1152:	ef 91       	pop	r30
    1154:	bf 91       	pop	r27
    1156:	af 91       	pop	r26
    1158:	9f 91       	pop	r25
    115a:	8f 91       	pop	r24
    115c:	7f 91       	pop	r23
    115e:	6f 91       	pop	r22
    1160:	5f 91       	pop	r21
    1162:	4f 91       	pop	r20
    1164:	3f 91       	pop	r19
    1166:	2f 91       	pop	r18
    1168:	0f 90       	pop	r0
    116a:	0b be       	out	0x3b, r0	; 59
    116c:	0f 90       	pop	r0
    116e:	0f be       	out	0x3f, r0	; 63
    1170:	0f 90       	pop	r0
    1172:	1f 90       	pop	r1
    1174:	18 95       	reti

00001176 <__vector_42>:
 *
 * Calls the callback function that has been set for the ADC when the channel's
 * interrupt flag is set, if its interrupt has been enabled.
 */
ISR(ADCB_CH3_vect)
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	11 24       	eor	r1, r1
    1180:	0b b6       	in	r0, 0x3b	; 59
    1182:	0f 92       	push	r0
    1184:	2f 93       	push	r18
    1186:	3f 93       	push	r19
    1188:	4f 93       	push	r20
    118a:	5f 93       	push	r21
    118c:	6f 93       	push	r22
    118e:	7f 93       	push	r23
    1190:	8f 93       	push	r24
    1192:	9f 93       	push	r25
    1194:	af 93       	push	r26
    1196:	bf 93       	push	r27
    1198:	ef 93       	push	r30
    119a:	ff 93       	push	r31
	adcb_callback(&ADCB, ADC_CH3, adc_get_result(&ADCB, ADC_CH3));
    119c:	40 91 7c 02 	lds	r20, 0x027C
    11a0:	50 91 7d 02 	lds	r21, 0x027D
    11a4:	e0 91 a1 23 	lds	r30, 0x23A1
    11a8:	f0 91 a2 23 	lds	r31, 0x23A2
    11ac:	68 e0       	ldi	r22, 0x08	; 8
    11ae:	80 e4       	ldi	r24, 0x40	; 64
    11b0:	92 e0       	ldi	r25, 0x02	; 2
    11b2:	19 95       	eicall
}
    11b4:	ff 91       	pop	r31
    11b6:	ef 91       	pop	r30
    11b8:	bf 91       	pop	r27
    11ba:	af 91       	pop	r26
    11bc:	9f 91       	pop	r25
    11be:	8f 91       	pop	r24
    11c0:	7f 91       	pop	r23
    11c2:	6f 91       	pop	r22
    11c4:	5f 91       	pop	r21
    11c6:	4f 91       	pop	r20
    11c8:	3f 91       	pop	r19
    11ca:	2f 91       	pop	r18
    11cc:	0f 90       	pop	r0
    11ce:	0b be       	out	0x3b, r0	; 59
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63
    11d4:	0f 90       	pop	r0
    11d6:	1f 90       	pop	r1
    11d8:	18 95       	reti

000011da <adc_write_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_write_configuration(ADC_t *adc, const struct adc_config *conf)
{
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	ec 01       	movw	r28, r24
    11ea:	8b 01       	movw	r16, r22
	uint16_t cal;
	uint8_t enable;
	irqflags_t flags;

#ifdef ADCA
	if ((uintptr_t)adc == (uintptr_t)&ADCA) {
    11ec:	c1 15       	cp	r28, r1
    11ee:	22 e0       	ldi	r18, 0x02	; 2
    11f0:	d2 07       	cpc	r29, r18
    11f2:	71 f4       	brne	.+28     	; 0x1210 <adc_write_configuration+0x36>
 *
 * \param address Byte offset into the signature row
 */
static inline uint8_t nvm_read_production_signature_row(uint8_t address)
{
	return nvm_read_byte(NVM_CMD_READ_CALIB_ROW_gc, address);
    11f4:	61 e2       	ldi	r22, 0x21	; 33
    11f6:	70 e0       	ldi	r23, 0x00	; 0
    11f8:	82 e0       	ldi	r24, 0x02	; 2
    11fa:	d4 d0       	rcall	.+424    	; 0x13a4 <nvm_read_byte>
	uint16_t data;

	switch (cal) {
#ifdef ADCA
	case ADC_CAL_ADCA:
		data = nvm_read_production_signature_row(ADCACAL1);
    11fc:	e8 2e       	mov	r14, r24
    11fe:	f1 2c       	mov	r15, r1
    1200:	60 e2       	ldi	r22, 0x20	; 32
    1202:	70 e0       	ldi	r23, 0x00	; 0
    1204:	82 e0       	ldi	r24, 0x02	; 2
    1206:	ce d0       	rcall	.+412    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    1208:	fe 2c       	mov	r15, r14
    120a:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCACAL0);
    120c:	e8 2a       	or	r14, r24
    120e:	10 c0       	rjmp	.+32     	; 0x1230 <adc_write_configuration+0x56>
		cal = adc_get_calibration_data(ADC_CAL_ADCA);
	} else
#endif

#ifdef ADCB
	if ((uintptr_t)adc == (uintptr_t)&ADCB) {
    1210:	80 34       	cpi	r24, 0x40	; 64
    1212:	92 40       	sbci	r25, 0x02	; 2
    1214:	51 f5       	brne	.+84     	; 0x126a <adc_write_configuration+0x90>
    1216:	65 e2       	ldi	r22, 0x25	; 37
    1218:	70 e0       	ldi	r23, 0x00	; 0
    121a:	82 e0       	ldi	r24, 0x02	; 2
    121c:	c3 d0       	rcall	.+390    	; 0x13a4 <nvm_read_byte>
		break;
#endif

#ifdef ADCB
	case ADC_CAL_ADCB:
		data = nvm_read_production_signature_row(ADCBCAL1);
    121e:	e8 2e       	mov	r14, r24
    1220:	f1 2c       	mov	r15, r1
    1222:	64 e2       	ldi	r22, 0x24	; 36
    1224:	70 e0       	ldi	r23, 0x00	; 0
    1226:	82 e0       	ldi	r24, 0x02	; 2
    1228:	bd d0       	rcall	.+378    	; 0x13a4 <nvm_read_byte>
		data <<= 8;
    122a:	fe 2c       	mov	r15, r14
    122c:	ee 24       	eor	r14, r14
		data |= nvm_read_production_signature_row(ADCBCAL0);
    122e:	e8 2a       	or	r14, r24

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1230:	df b6       	in	r13, 0x3f	; 63
	cpu_irq_disable();
    1232:	f8 94       	cli
		Assert(0);
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
    1234:	ce 01       	movw	r24, r28
    1236:	ee dd       	rcall	.-1060   	; 0xe14 <adc_enable_clock>
	enable = adc->CTRLA & ADC_ENABLE_bm;
    1238:	88 81       	ld	r24, Y

	adc->CTRLA = ADC_FLUSH_bm;
    123a:	92 e0       	ldi	r25, 0x02	; 2
    123c:	98 83       	st	Y, r25
	adc->CAL = cal;
    123e:	ec 86       	std	Y+12, r14	; 0x0c
    1240:	fd 86       	std	Y+13, r15	; 0x0d
	adc->CMP = conf->cmp;
    1242:	f8 01       	movw	r30, r16
    1244:	25 81       	ldd	r18, Z+5	; 0x05
    1246:	36 81       	ldd	r19, Z+6	; 0x06
    1248:	28 8f       	std	Y+24, r18	; 0x18
    124a:	39 8f       	std	Y+25, r19	; 0x19
	adc->REFCTRL = conf->refctrl;
    124c:	92 81       	ldd	r25, Z+2	; 0x02
    124e:	9a 83       	std	Y+2, r25	; 0x02
	adc->PRESCALER = conf->prescaler;
    1250:	94 81       	ldd	r25, Z+4	; 0x04
    1252:	9c 83       	std	Y+4, r25	; 0x04
	adc->EVCTRL = conf->evctrl;
    1254:	93 81       	ldd	r25, Z+3	; 0x03
    1256:	9b 83       	std	Y+3, r25	; 0x03
	adc->CTRLB = conf->ctrlb;
    1258:	91 81       	ldd	r25, Z+1	; 0x01
    125a:	99 83       	std	Y+1, r25	; 0x01
		return;
	}

	flags = cpu_irq_save();
	adc_enable_clock(adc);
	enable = adc->CTRLA & ADC_ENABLE_bm;
    125c:	81 70       	andi	r24, 0x01	; 1
	adc->REFCTRL = conf->refctrl;
	adc->PRESCALER = conf->prescaler;
	adc->EVCTRL = conf->evctrl;
	adc->CTRLB = conf->ctrlb;

	adc->CTRLA = enable | conf->ctrla;
    125e:	90 81       	ld	r25, Z
    1260:	89 2b       	or	r24, r25
    1262:	88 83       	st	Y, r24

	adc_disable_clock(adc);
    1264:	ce 01       	movw	r24, r28
    1266:	f5 dd       	rcall	.-1046   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1268:	df be       	out	0x3f, r13	; 63

	cpu_irq_restore(flags);
}
    126a:	df 91       	pop	r29
    126c:	cf 91       	pop	r28
    126e:	1f 91       	pop	r17
    1270:	0f 91       	pop	r16
    1272:	ff 90       	pop	r15
    1274:	ef 90       	pop	r14
    1276:	df 90       	pop	r13
    1278:	08 95       	ret

0000127a <adc_read_configuration>:
 *
 * \param adc Pointer to ADC module.
 * \param conf Pointer to ADC module configuration.
 */
void adc_read_configuration(ADC_t *adc, struct adc_config *conf)
{
    127a:	ff 92       	push	r15
    127c:	0f 93       	push	r16
    127e:	1f 93       	push	r17
    1280:	cf 93       	push	r28
    1282:	df 93       	push	r29
    1284:	ec 01       	movw	r28, r24
    1286:	8b 01       	movw	r16, r22

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    1288:	ff b6       	in	r15, 0x3f	; 63
	cpu_irq_disable();
    128a:	f8 94       	cli
	irqflags_t flags = cpu_irq_save();

	adc_enable_clock(adc);
    128c:	c3 dd       	rcall	.-1146   	; 0xe14 <adc_enable_clock>

	conf->ctrla = adc->CTRLA & ADC_DMASEL_gm;
    128e:	88 81       	ld	r24, Y
    1290:	80 7c       	andi	r24, 0xC0	; 192
    1292:	f8 01       	movw	r30, r16
    1294:	80 83       	st	Z, r24

	conf->cmp = adc->CMP;
    1296:	88 8d       	ldd	r24, Y+24	; 0x18
    1298:	99 8d       	ldd	r25, Y+25	; 0x19
    129a:	85 83       	std	Z+5, r24	; 0x05
    129c:	96 83       	std	Z+6, r25	; 0x06
	conf->refctrl = adc->REFCTRL;
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	82 83       	std	Z+2, r24	; 0x02
	conf->prescaler = adc->PRESCALER;
    12a2:	8c 81       	ldd	r24, Y+4	; 0x04
    12a4:	84 83       	std	Z+4, r24	; 0x04
	conf->evctrl = adc->EVCTRL;
    12a6:	8b 81       	ldd	r24, Y+3	; 0x03
    12a8:	83 83       	std	Z+3, r24	; 0x03
	conf->ctrlb = adc->CTRLB;
    12aa:	89 81       	ldd	r24, Y+1	; 0x01
    12ac:	81 83       	std	Z+1, r24	; 0x01

	adc_disable_clock(adc);
    12ae:	ce 01       	movw	r24, r28
    12b0:	d0 dd       	rcall	.-1120   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    12b2:	ff be       	out	0x3f, r15	; 63

	cpu_irq_restore(flags);
}
    12b4:	df 91       	pop	r29
    12b6:	cf 91       	pop	r28
    12b8:	1f 91       	pop	r17
    12ba:	0f 91       	pop	r16
    12bc:	ff 90       	pop	r15
    12be:	08 95       	ret

000012c0 <adcch_write_configuration>:
 * is called if callbacks are enabled and interrupts are enabled in the
 * channel configuration.
 */
void adcch_write_configuration(ADC_t *adc, uint8_t ch_mask,
		const struct adc_channel_config *ch_conf)
{
    12c0:	cf 92       	push	r12
    12c2:	df 92       	push	r13
    12c4:	ef 92       	push	r14
    12c6:	ff 92       	push	r15
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	7c 01       	movw	r14, r24
    12d2:	d6 2e       	mov	r13, r22
    12d4:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12d6:	86 2f       	mov	r24, r22
    12d8:	83 70       	andi	r24, 0x03	; 3
    12da:	29 f4       	brne	.+10     	; 0x12e6 <adcch_write_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    12dc:	96 2f       	mov	r25, r22
    12de:	96 95       	lsr	r25
    12e0:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    12e2:	82 e0       	ldi	r24, 0x02	; 2
    12e4:	02 c0       	rjmp	.+4      	; 0x12ea <adcch_write_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    12e6:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    12e8:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    12ea:	90 ff       	sbrs	r25, 0
		index++;
    12ec:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    12ee:	e7 01       	movw	r28, r14
    12f0:	a0 96       	adiw	r28, 0x20	; 32
    12f2:	98 e0       	ldi	r25, 0x08	; 8
    12f4:	89 9f       	mul	r24, r25
    12f6:	c0 0d       	add	r28, r0
    12f8:	d1 1d       	adc	r29, r1
    12fa:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    12fc:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    12fe:	f8 94       	cli
			return;
		}
	}
#endif

	adc_enable_clock(adc);
    1300:	c7 01       	movw	r24, r14
    1302:	88 dd       	rcall	.-1264   	; 0xe14 <adc_enable_clock>
	adc_ch->CTRL = ch_conf->ctrl;
    1304:	f8 01       	movw	r30, r16
    1306:	80 81       	ld	r24, Z
    1308:	88 83       	st	Y, r24
	adc_ch->INTCTRL = ch_conf->intctrl;
    130a:	82 81       	ldd	r24, Z+2	; 0x02
    130c:	8a 83       	std	Y+2, r24	; 0x02
	adc_ch->MUXCTRL = ch_conf->muxctrl;
    130e:	81 81       	ldd	r24, Z+1	; 0x01
    1310:	89 83       	std	Y+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1312:	d0 fe       	sbrs	r13, 0
    1314:	02 c0       	rjmp	.+4      	; 0x131a <adcch_write_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		adc_ch->SCAN = ch_conf->scan;
    1316:	83 81       	ldd	r24, Z+3	; 0x03
    1318:	8e 83       	std	Y+6, r24	; 0x06
	}
	adc_disable_clock(adc);
    131a:	c7 01       	movw	r24, r14
    131c:	9a dd       	rcall	.-1228   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    131e:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1320:	df 91       	pop	r29
    1322:	cf 91       	pop	r28
    1324:	1f 91       	pop	r17
    1326:	0f 91       	pop	r16
    1328:	ff 90       	pop	r15
    132a:	ef 90       	pop	r14
    132c:	df 90       	pop	r13
    132e:	cf 90       	pop	r12
    1330:	08 95       	ret

00001332 <adcch_read_configuration>:
 * can be given in mask)
 * \param ch_conf Pointer to ADC channel configuration.
 */
void adcch_read_configuration(ADC_t *adc, uint8_t ch_mask,
		struct adc_channel_config *ch_conf)
{
    1332:	cf 92       	push	r12
    1334:	df 92       	push	r13
    1336:	ef 92       	push	r14
    1338:	ff 92       	push	r15
    133a:	0f 93       	push	r16
    133c:	1f 93       	push	r17
    133e:	cf 93       	push	r28
    1340:	df 93       	push	r29
    1342:	7c 01       	movw	r14, r24
    1344:	d6 2e       	mov	r13, r22
    1346:	8a 01       	movw	r16, r20
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1348:	86 2f       	mov	r24, r22
    134a:	83 70       	andi	r24, 0x03	; 3
    134c:	29 f4       	brne	.+10     	; 0x1358 <adcch_read_configuration+0x26>
		index += 2;
		ch_mask >>= 2;
    134e:	96 2f       	mov	r25, r22
    1350:	96 95       	lsr	r25
    1352:	96 95       	lsr	r25
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
		index += 2;
    1354:	82 e0       	ldi	r24, 0x02	; 2
    1356:	02 c0       	rjmp	.+4      	; 0x135c <adcch_read_configuration+0x2a>
		index += 4;
		ch_mask >>= 4;
	}
#endif
#if ADC_NR_OF_CHANNELS > 2
	if (!(ch_mask & 0x03)) {
    1358:	96 2f       	mov	r25, r22
 * \return Pointer to ADC channel
 */
static __always_inline ADC_CH_t *adc_get_channel(
		ADC_t *adc, uint8_t ch_mask)
{
	uint8_t index = 0;
    135a:	80 e0       	ldi	r24, 0x00	; 0
		index += 2;
		ch_mask >>= 2;
	}
#endif
#if ADC_NR_OF_CHANNELS > 1
	if (!(ch_mask & 0x01)) {
    135c:	90 ff       	sbrs	r25, 0
		index++;
    135e:	8f 5f       	subi	r24, 0xFF	; 255
	}
#endif

	return (ADC_CH_t *)(&adc->CH0 + index);
    1360:	e7 01       	movw	r28, r14
    1362:	a0 96       	adiw	r28, 0x20	; 32
    1364:	98 e0       	ldi	r25, 0x08	; 8
    1366:	89 9f       	mul	r24, r25
    1368:	c0 0d       	add	r28, r0
    136a:	d1 1d       	adc	r29, r1
    136c:	11 24       	eor	r1, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    136e:	cf b6       	in	r12, 0x3f	; 63
	cpu_irq_disable();
    1370:	f8 94       	cli

	adc_ch = adc_get_channel(adc, ch_mask);

	flags = cpu_irq_save();

	adc_enable_clock(adc);
    1372:	c7 01       	movw	r24, r14
    1374:	4f dd       	rcall	.-1378   	; 0xe14 <adc_enable_clock>
	ch_conf->ctrl = adc_ch->CTRL;
    1376:	88 81       	ld	r24, Y
    1378:	f8 01       	movw	r30, r16
    137a:	80 83       	st	Z, r24
	ch_conf->intctrl = adc_ch->INTCTRL;
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	82 83       	std	Z+2, r24	; 0x02
	ch_conf->muxctrl = adc_ch->MUXCTRL;
    1380:	89 81       	ldd	r24, Y+1	; 0x01
    1382:	81 83       	std	Z+1, r24	; 0x01
	if (ch_mask & ADC_CH0) {
    1384:	d0 fe       	sbrs	r13, 0
    1386:	02 c0       	rjmp	.+4      	; 0x138c <adcch_read_configuration+0x5a>
		/* USB devices has channel scan available on ADC channel 0 */
		ch_conf->scan = adc_ch->SCAN;
    1388:	8e 81       	ldd	r24, Y+6	; 0x06
    138a:	83 83       	std	Z+3, r24	; 0x03
	}
	adc_disable_clock(adc);
    138c:	c7 01       	movw	r24, r14
    138e:	61 dd       	rcall	.-1342   	; 0xe52 <adc_disable_clock>
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    1390:	cf be       	out	0x3f, r12	; 63

	cpu_irq_restore(flags);
}
    1392:	df 91       	pop	r29
    1394:	cf 91       	pop	r28
    1396:	1f 91       	pop	r17
    1398:	0f 91       	pop	r16
    139a:	ff 90       	pop	r15
    139c:	ef 90       	pop	r14
    139e:	df 90       	pop	r13
    13a0:	cf 90       	pop	r12
    13a2:	08 95       	ret

000013a4 <nvm_read_byte>:
#endif

#ifndef __DOXYGEN__
	PUBLIC_FUNCTION(nvm_read_byte)
#if defined(__GNUC__)
	lds r20, NVM_CMD          ; Store NVM command register
    13a4:	40 91 ca 01 	lds	r20, 0x01CA
	mov ZL, r22               ; Load byte index into low byte of Z.
    13a8:	e6 2f       	mov	r30, r22
	mov ZH, r23               ; Load high byte into Z.
    13aa:	f7 2f       	mov	r31, r23
	sts NVM_CMD, r24          ; Load prepared command into NVM Command register.
    13ac:	80 93 ca 01 	sts	0x01CA, r24
	lpm r24, Z                ; Perform an LPM to read out byte
    13b0:	84 91       	lpm	r24, Z
	sts NVM_CMD, r20          ; Restore NVM command register
    13b2:	40 93 ca 01 	sts	0x01CA, r20
	sts NVM_CMD, r16          ; Load prepared command into NVM Command register.
	lpm r16, Z                ; Perform an LPM to read out byte
	sts NVM_CMD, r20          ; Restore NVM command register
#endif

	ret
    13b6:	08 95       	ret

000013b8 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
    13b8:	cf 92       	push	r12
    13ba:	df 92       	push	r13
    13bc:	ef 92       	push	r14
    13be:	ff 92       	push	r15
    13c0:	0f 93       	push	r16
    13c2:	1f 93       	push	r17
    13c4:	cf 93       	push	r28
    13c6:	df 93       	push	r29
    13c8:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
    13ca:	d9 01       	movw	r26, r18
    13cc:	c8 01       	movw	r24, r16
    13ce:	b6 95       	lsr	r27
    13d0:	a7 95       	ror	r26
    13d2:	97 95       	ror	r25
    13d4:	87 95       	ror	r24
    13d6:	48 17       	cp	r20, r24
    13d8:	59 07       	cpc	r21, r25
    13da:	6a 07       	cpc	r22, r26
    13dc:	7b 07       	cpc	r23, r27
    13de:	78 f4       	brcc	.+30     	; 0x13fe <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
    13e0:	6a 01       	movw	r12, r20
    13e2:	7b 01       	movw	r14, r22
    13e4:	cc 0c       	add	r12, r12
    13e6:	dd 1c       	adc	r13, r13
    13e8:	ee 1c       	adc	r14, r14
    13ea:	ff 1c       	adc	r15, r15
    13ec:	c9 01       	movw	r24, r18
    13ee:	b8 01       	movw	r22, r16
    13f0:	a7 01       	movw	r20, r14
    13f2:	96 01       	movw	r18, r12
    13f4:	0e 94 97 19 	call	0x332e	; 0x332e <__udivmodsi4>
    13f8:	21 50       	subi	r18, 0x01	; 1
    13fa:	31 09       	sbc	r19, r1
    13fc:	02 c0       	rjmp	.+4      	; 0x1402 <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
    13fe:	20 e0       	ldi	r18, 0x00	; 0
    1400:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
    1402:	83 2f       	mov	r24, r19
    1404:	8f 70       	andi	r24, 0x0F	; 15
    1406:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
    1408:	2e 83       	std	Y+6, r18	; 0x06
}
    140a:	df 91       	pop	r29
    140c:	cf 91       	pop	r28
    140e:	1f 91       	pop	r17
    1410:	0f 91       	pop	r16
    1412:	ff 90       	pop	r15
    1414:	ef 90       	pop	r14
    1416:	df 90       	pop	r13
    1418:	cf 90       	pop	r12
    141a:	08 95       	ret

0000141c <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    141c:	ef 92       	push	r14
    141e:	ff 92       	push	r15
    1420:	0f 93       	push	r16
    1422:	1f 93       	push	r17
    1424:	cf 93       	push	r28
    1426:	df 93       	push	r29
    1428:	ec 01       	movw	r28, r24
    142a:	7b 01       	movw	r14, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
    142c:	00 97       	sbiw	r24, 0x00	; 0
    142e:	09 f4       	brne	.+2      	; 0x1432 <usart_init_spi+0x16>
    1430:	7b c1       	rjmp	.+758    	; 0x1728 <usart_init_spi+0x30c>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
    1432:	80 3c       	cpi	r24, 0xC0	; 192
    1434:	91 05       	cpc	r25, r1
    1436:	21 f4       	brne	.+8      	; 0x1440 <usart_init_spi+0x24>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
    1438:	60 e1       	ldi	r22, 0x10	; 16
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	0a da       	rcall	.-3052   	; 0x852 <sysclk_enable_module>
    143e:	74 c1       	rjmp	.+744    	; 0x1728 <usart_init_spi+0x30c>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
    1440:	80 38       	cpi	r24, 0x80	; 128
    1442:	91 40       	sbci	r25, 0x01	; 1
    1444:	21 f4       	brne	.+8      	; 0x144e <usart_init_spi+0x32>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
    1446:	62 e0       	ldi	r22, 0x02	; 2
    1448:	80 e0       	ldi	r24, 0x00	; 0
    144a:	03 da       	rcall	.-3066   	; 0x852 <sysclk_enable_module>
    144c:	6d c1       	rjmp	.+730    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
    144e:	c1 15       	cp	r28, r1
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	d8 07       	cpc	r29, r24
    1454:	21 f4       	brne	.+8      	; 0x145e <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
    1456:	61 e0       	ldi	r22, 0x01	; 1
    1458:	80 e0       	ldi	r24, 0x00	; 0
    145a:	fb d9       	rcall	.-3082   	; 0x852 <sysclk_enable_module>
    145c:	65 c1       	rjmp	.+714    	; 0x1728 <usart_init_spi+0x30c>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
    145e:	c0 38       	cpi	r28, 0x80	; 128
    1460:	e3 e0       	ldi	r30, 0x03	; 3
    1462:	de 07       	cpc	r29, r30
    1464:	21 f4       	brne	.+8      	; 0x146e <usart_init_spi+0x52>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
    1466:	61 e0       	ldi	r22, 0x01	; 1
    1468:	81 e0       	ldi	r24, 0x01	; 1
    146a:	f3 d9       	rcall	.-3098   	; 0x852 <sysclk_enable_module>
    146c:	5d c1       	rjmp	.+698    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
    146e:	c0 39       	cpi	r28, 0x90	; 144
    1470:	f3 e0       	ldi	r31, 0x03	; 3
    1472:	df 07       	cpc	r29, r31
    1474:	21 f4       	brne	.+8      	; 0x147e <usart_init_spi+0x62>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
    1476:	61 e0       	ldi	r22, 0x01	; 1
    1478:	82 e0       	ldi	r24, 0x02	; 2
    147a:	eb d9       	rcall	.-3114   	; 0x852 <sysclk_enable_module>
    147c:	55 c1       	rjmp	.+682    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
    147e:	c1 15       	cp	r28, r1
    1480:	32 e0       	ldi	r19, 0x02	; 2
    1482:	d3 07       	cpc	r29, r19
    1484:	21 f4       	brne	.+8      	; 0x148e <usart_init_spi+0x72>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
    1486:	62 e0       	ldi	r22, 0x02	; 2
    1488:	81 e0       	ldi	r24, 0x01	; 1
    148a:	e3 d9       	rcall	.-3130   	; 0x852 <sysclk_enable_module>
    148c:	4d c1       	rjmp	.+666    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
    148e:	c0 34       	cpi	r28, 0x40	; 64
    1490:	82 e0       	ldi	r24, 0x02	; 2
    1492:	d8 07       	cpc	r29, r24
    1494:	21 f4       	brne	.+8      	; 0x149e <usart_init_spi+0x82>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
    1496:	62 e0       	ldi	r22, 0x02	; 2
    1498:	82 e0       	ldi	r24, 0x02	; 2
    149a:	db d9       	rcall	.-3146   	; 0x852 <sysclk_enable_module>
    149c:	45 c1       	rjmp	.+650    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
    149e:	c0 32       	cpi	r28, 0x20	; 32
    14a0:	e3 e0       	ldi	r30, 0x03	; 3
    14a2:	de 07       	cpc	r29, r30
    14a4:	21 f4       	brne	.+8      	; 0x14ae <usart_init_spi+0x92>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
    14a6:	64 e0       	ldi	r22, 0x04	; 4
    14a8:	82 e0       	ldi	r24, 0x02	; 2
    14aa:	d3 d9       	rcall	.-3162   	; 0x852 <sysclk_enable_module>
    14ac:	3d c1       	rjmp	.+634    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
    14ae:	c1 15       	cp	r28, r1
    14b0:	f8 e0       	ldi	r31, 0x08	; 8
    14b2:	df 07       	cpc	r29, r31
    14b4:	21 f4       	brne	.+8      	; 0x14be <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
    14b6:	61 e0       	ldi	r22, 0x01	; 1
    14b8:	83 e0       	ldi	r24, 0x03	; 3
    14ba:	cb d9       	rcall	.-3178   	; 0x852 <sysclk_enable_module>
    14bc:	35 c1       	rjmp	.+618    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
    14be:	c1 15       	cp	r28, r1
    14c0:	39 e0       	ldi	r19, 0x09	; 9
    14c2:	d3 07       	cpc	r29, r19
    14c4:	21 f4       	brne	.+8      	; 0x14ce <usart_init_spi+0xb2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
    14c6:	61 e0       	ldi	r22, 0x01	; 1
    14c8:	84 e0       	ldi	r24, 0x04	; 4
    14ca:	c3 d9       	rcall	.-3194   	; 0x852 <sysclk_enable_module>
    14cc:	2d c1       	rjmp	.+602    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
    14ce:	c1 15       	cp	r28, r1
    14d0:	8a e0       	ldi	r24, 0x0A	; 10
    14d2:	d8 07       	cpc	r29, r24
    14d4:	21 f4       	brne	.+8      	; 0x14de <usart_init_spi+0xc2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
    14d6:	61 e0       	ldi	r22, 0x01	; 1
    14d8:	85 e0       	ldi	r24, 0x05	; 5
    14da:	bb d9       	rcall	.-3210   	; 0x852 <sysclk_enable_module>
    14dc:	25 c1       	rjmp	.+586    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
    14de:	c1 15       	cp	r28, r1
    14e0:	eb e0       	ldi	r30, 0x0B	; 11
    14e2:	de 07       	cpc	r29, r30
    14e4:	21 f4       	brne	.+8      	; 0x14ee <usart_init_spi+0xd2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
    14e6:	61 e0       	ldi	r22, 0x01	; 1
    14e8:	86 e0       	ldi	r24, 0x06	; 6
    14ea:	b3 d9       	rcall	.-3226   	; 0x852 <sysclk_enable_module>
    14ec:	1d c1       	rjmp	.+570    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
    14ee:	c0 34       	cpi	r28, 0x40	; 64
    14f0:	f8 e0       	ldi	r31, 0x08	; 8
    14f2:	df 07       	cpc	r29, r31
    14f4:	21 f4       	brne	.+8      	; 0x14fe <usart_init_spi+0xe2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
    14f6:	62 e0       	ldi	r22, 0x02	; 2
    14f8:	83 e0       	ldi	r24, 0x03	; 3
    14fa:	ab d9       	rcall	.-3242   	; 0x852 <sysclk_enable_module>
    14fc:	15 c1       	rjmp	.+554    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
    14fe:	c0 34       	cpi	r28, 0x40	; 64
    1500:	39 e0       	ldi	r19, 0x09	; 9
    1502:	d3 07       	cpc	r29, r19
    1504:	21 f4       	brne	.+8      	; 0x150e <usart_init_spi+0xf2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
    1506:	62 e0       	ldi	r22, 0x02	; 2
    1508:	84 e0       	ldi	r24, 0x04	; 4
    150a:	a3 d9       	rcall	.-3258   	; 0x852 <sysclk_enable_module>
    150c:	0d c1       	rjmp	.+538    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
    150e:	c0 34       	cpi	r28, 0x40	; 64
    1510:	8a e0       	ldi	r24, 0x0A	; 10
    1512:	d8 07       	cpc	r29, r24
    1514:	21 f4       	brne	.+8      	; 0x151e <usart_init_spi+0x102>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
    1516:	62 e0       	ldi	r22, 0x02	; 2
    1518:	85 e0       	ldi	r24, 0x05	; 5
    151a:	9b d9       	rcall	.-3274   	; 0x852 <sysclk_enable_module>
    151c:	05 c1       	rjmp	.+522    	; 0x1728 <usart_init_spi+0x30c>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
    151e:	c0 39       	cpi	r28, 0x90	; 144
    1520:	e8 e0       	ldi	r30, 0x08	; 8
    1522:	de 07       	cpc	r29, r30
    1524:	21 f4       	brne	.+8      	; 0x152e <usart_init_spi+0x112>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
    1526:	64 e0       	ldi	r22, 0x04	; 4
    1528:	83 e0       	ldi	r24, 0x03	; 3
    152a:	93 d9       	rcall	.-3290   	; 0x852 <sysclk_enable_module>
    152c:	fd c0       	rjmp	.+506    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
    152e:	c0 39       	cpi	r28, 0x90	; 144
    1530:	f9 e0       	ldi	r31, 0x09	; 9
    1532:	df 07       	cpc	r29, r31
    1534:	21 f4       	brne	.+8      	; 0x153e <usart_init_spi+0x122>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
    1536:	64 e0       	ldi	r22, 0x04	; 4
    1538:	84 e0       	ldi	r24, 0x04	; 4
    153a:	8b d9       	rcall	.-3306   	; 0x852 <sysclk_enable_module>
    153c:	f5 c0       	rjmp	.+490    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
    153e:	c0 39       	cpi	r28, 0x90	; 144
    1540:	3a e0       	ldi	r19, 0x0A	; 10
    1542:	d3 07       	cpc	r29, r19
    1544:	21 f4       	brne	.+8      	; 0x154e <usart_init_spi+0x132>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
    1546:	64 e0       	ldi	r22, 0x04	; 4
    1548:	85 e0       	ldi	r24, 0x05	; 5
    154a:	83 d9       	rcall	.-3322   	; 0x852 <sysclk_enable_module>
    154c:	ed c0       	rjmp	.+474    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
    154e:	c0 39       	cpi	r28, 0x90	; 144
    1550:	8b e0       	ldi	r24, 0x0B	; 11
    1552:	d8 07       	cpc	r29, r24
    1554:	21 f4       	brne	.+8      	; 0x155e <usart_init_spi+0x142>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
    1556:	64 e0       	ldi	r22, 0x04	; 4
    1558:	86 e0       	ldi	r24, 0x06	; 6
    155a:	7b d9       	rcall	.-3338   	; 0x852 <sysclk_enable_module>
    155c:	e5 c0       	rjmp	.+458    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
    155e:	c0 3c       	cpi	r28, 0xC0	; 192
    1560:	e8 e0       	ldi	r30, 0x08	; 8
    1562:	de 07       	cpc	r29, r30
    1564:	21 f4       	brne	.+8      	; 0x156e <usart_init_spi+0x152>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
    1566:	68 e0       	ldi	r22, 0x08	; 8
    1568:	83 e0       	ldi	r24, 0x03	; 3
    156a:	73 d9       	rcall	.-3354   	; 0x852 <sysclk_enable_module>
    156c:	dd c0       	rjmp	.+442    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
    156e:	c0 3c       	cpi	r28, 0xC0	; 192
    1570:	f9 e0       	ldi	r31, 0x09	; 9
    1572:	df 07       	cpc	r29, r31
    1574:	21 f4       	brne	.+8      	; 0x157e <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
    1576:	68 e0       	ldi	r22, 0x08	; 8
    1578:	84 e0       	ldi	r24, 0x04	; 4
    157a:	6b d9       	rcall	.-3370   	; 0x852 <sysclk_enable_module>
    157c:	d5 c0       	rjmp	.+426    	; 0x1728 <usart_init_spi+0x30c>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
    157e:	c0 3a       	cpi	r28, 0xA0	; 160
    1580:	38 e0       	ldi	r19, 0x08	; 8
    1582:	d3 07       	cpc	r29, r19
    1584:	61 f4       	brne	.+24     	; 0x159e <usart_init_spi+0x182>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
    1586:	60 e1       	ldi	r22, 0x10	; 16
    1588:	83 e0       	ldi	r24, 0x03	; 3
    158a:	63 d9       	rcall	.-3386   	; 0x852 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    158c:	e0 ea       	ldi	r30, 0xA0	; 160
    158e:	f8 e0       	ldi	r31, 0x08	; 8
    1590:	84 81       	ldd	r24, Z+4	; 0x04
    1592:	8f 7e       	andi	r24, 0xEF	; 239
    1594:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    1596:	f7 01       	movw	r30, r14
    1598:	24 81       	ldd	r18, Z+4	; 0x04
    159a:	22 50       	subi	r18, 0x02	; 2
    159c:	43 c0       	rjmp	.+134    	; 0x1624 <usart_init_spi+0x208>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
    159e:	c0 3a       	cpi	r28, 0xA0	; 160
    15a0:	f9 e0       	ldi	r31, 0x09	; 9
    15a2:	df 07       	cpc	r29, r31
    15a4:	21 f4       	brne	.+8      	; 0x15ae <usart_init_spi+0x192>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
    15a6:	60 e1       	ldi	r22, 0x10	; 16
    15a8:	84 e0       	ldi	r24, 0x04	; 4
    15aa:	53 d9       	rcall	.-3418   	; 0x852 <sysclk_enable_module>
    15ac:	bd c0       	rjmp	.+378    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
    15ae:	c0 3a       	cpi	r28, 0xA0	; 160
    15b0:	3a e0       	ldi	r19, 0x0A	; 10
    15b2:	d3 07       	cpc	r29, r19
    15b4:	21 f4       	brne	.+8      	; 0x15be <usart_init_spi+0x1a2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
    15b6:	60 e1       	ldi	r22, 0x10	; 16
    15b8:	85 e0       	ldi	r24, 0x05	; 5
    15ba:	4b d9       	rcall	.-3434   	; 0x852 <sysclk_enable_module>
    15bc:	b5 c0       	rjmp	.+362    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
    15be:	c0 3a       	cpi	r28, 0xA0	; 160
    15c0:	8b e0       	ldi	r24, 0x0B	; 11
    15c2:	d8 07       	cpc	r29, r24
    15c4:	21 f4       	brne	.+8      	; 0x15ce <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
    15c6:	60 e1       	ldi	r22, 0x10	; 16
    15c8:	86 e0       	ldi	r24, 0x06	; 6
    15ca:	43 d9       	rcall	.-3450   	; 0x852 <sysclk_enable_module>
    15cc:	ad c0       	rjmp	.+346    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
    15ce:	c0 3b       	cpi	r28, 0xB0	; 176
    15d0:	e8 e0       	ldi	r30, 0x08	; 8
    15d2:	de 07       	cpc	r29, r30
    15d4:	21 f4       	brne	.+8      	; 0x15de <usart_init_spi+0x1c2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
    15d6:	60 e2       	ldi	r22, 0x20	; 32
    15d8:	83 e0       	ldi	r24, 0x03	; 3
    15da:	3b d9       	rcall	.-3466   	; 0x852 <sysclk_enable_module>
    15dc:	a5 c0       	rjmp	.+330    	; 0x1728 <usart_init_spi+0x30c>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
    15de:	c0 3b       	cpi	r28, 0xB0	; 176
    15e0:	f9 e0       	ldi	r31, 0x09	; 9
    15e2:	df 07       	cpc	r29, r31
    15e4:	21 f4       	brne	.+8      	; 0x15ee <usart_init_spi+0x1d2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
    15e6:	60 e2       	ldi	r22, 0x20	; 32
    15e8:	84 e0       	ldi	r24, 0x04	; 4
    15ea:	33 d9       	rcall	.-3482   	; 0x852 <sysclk_enable_module>
    15ec:	9d c0       	rjmp	.+314    	; 0x1728 <usart_init_spi+0x30c>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
    15ee:	c0 38       	cpi	r28, 0x80	; 128
    15f0:	34 e0       	ldi	r19, 0x04	; 4
    15f2:	d3 07       	cpc	r29, r19
    15f4:	21 f4       	brne	.+8      	; 0x15fe <usart_init_spi+0x1e2>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
    15f6:	60 e4       	ldi	r22, 0x40	; 64
    15f8:	83 e0       	ldi	r24, 0x03	; 3
    15fa:	2b d9       	rcall	.-3498   	; 0x852 <sysclk_enable_module>
    15fc:	95 c0       	rjmp	.+298    	; 0x1728 <usart_init_spi+0x30c>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
    15fe:	c0 3a       	cpi	r28, 0xA0	; 160
    1600:	84 e0       	ldi	r24, 0x04	; 4
    1602:	d8 07       	cpc	r29, r24
    1604:	21 f4       	brne	.+8      	; 0x160e <usart_init_spi+0x1f2>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
    1606:	60 e4       	ldi	r22, 0x40	; 64
    1608:	85 e0       	ldi	r24, 0x05	; 5
    160a:	23 d9       	rcall	.-3514   	; 0x852 <sysclk_enable_module>
    160c:	8d c0       	rjmp	.+282    	; 0x1728 <usart_init_spi+0x30c>
    160e:	8c 81       	ldd	r24, Y+4	; 0x04
    1610:	8f 7e       	andi	r24, 0xEF	; 239
    1612:	8c 83       	std	Y+4, r24	; 0x04
    1614:	fb 01       	movw	r30, r22
    1616:	24 81       	ldd	r18, Z+4	; 0x04
    1618:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    161a:	ce 01       	movw	r24, r28
    161c:	c0 3a       	cpi	r28, 0xA0	; 160
    161e:	f8 e0       	ldi	r31, 0x08	; 8
    1620:	df 07       	cpc	r29, r31
    1622:	31 f4       	brne	.+12     	; 0x1630 <usart_init_spi+0x214>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
    1624:	80 91 4e 06 	lds	r24, 0x064E
    1628:	84 fd       	sbrc	r24, 4
    162a:	86 c0       	rjmp	.+268    	; 0x1738 <usart_init_spi+0x31c>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
    162c:	11 e1       	ldi	r17, 0x11	; 17
    162e:	85 c0       	rjmp	.+266    	; 0x173a <usart_init_spi+0x31e>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
    1630:	80 3b       	cpi	r24, 0xB0	; 176
    1632:	38 e0       	ldi	r19, 0x08	; 8
    1634:	93 07       	cpc	r25, r19
    1636:	79 f0       	breq	.+30     	; 0x1656 <usart_init_spi+0x23a>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
    1638:	80 3a       	cpi	r24, 0xA0	; 160
    163a:	e9 e0       	ldi	r30, 0x09	; 9
    163c:	9e 07       	cpc	r25, r30
    163e:	31 f4       	brne	.+12     	; 0x164c <usart_init_spi+0x230>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
    1640:	30 91 6e 06 	lds	r19, 0x066E
    1644:	34 fd       	sbrc	r19, 4
    1646:	7c c0       	rjmp	.+248    	; 0x1740 <usart_init_spi+0x324>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
    1648:	19 e1       	ldi	r17, 0x19	; 25
    164a:	10 c0       	rjmp	.+32     	; 0x166c <usart_init_spi+0x250>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
    164c:	80 3b       	cpi	r24, 0xB0	; 176
    164e:	f9 e0       	ldi	r31, 0x09	; 9
    1650:	9f 07       	cpc	r25, r31
    1652:	a9 f0       	breq	.+42     	; 0x167e <usart_init_spi+0x262>
    1654:	01 c0       	rjmp	.+2      	; 0x1658 <usart_init_spi+0x23c>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1656:	15 e1       	ldi	r17, 0x15	; 21
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
    1658:	80 3a       	cpi	r24, 0xA0	; 160
    165a:	3a e0       	ldi	r19, 0x0A	; 10
    165c:	93 07       	cpc	r25, r19
    165e:	31 f4       	brne	.+12     	; 0x166c <usart_init_spi+0x250>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
    1660:	80 91 8e 06 	lds	r24, 0x068E
    1664:	84 fd       	sbrc	r24, 4
    1666:	6e c0       	rjmp	.+220    	; 0x1744 <usart_init_spi+0x328>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
    1668:	11 e2       	ldi	r17, 0x21	; 33
    166a:	0c c0       	rjmp	.+24     	; 0x1684 <usart_init_spi+0x268>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
    166c:	80 3a       	cpi	r24, 0xA0	; 160
    166e:	9b 40       	sbci	r25, 0x0B	; 11
    1670:	49 f4       	brne	.+18     	; 0x1684 <usart_init_spi+0x268>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
    1672:	80 91 ae 06 	lds	r24, 0x06AE
    1676:	84 fd       	sbrc	r24, 4
    1678:	04 c0       	rjmp	.+8      	; 0x1682 <usart_init_spi+0x266>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
    167a:	19 e2       	ldi	r17, 0x29	; 41
    167c:	03 c0       	rjmp	.+6      	; 0x1684 <usart_init_spi+0x268>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    167e:	1d e1       	ldi	r17, 0x1D	; 29
    1680:	01 c0       	rjmp	.+2      	; 0x1684 <usart_init_spi+0x268>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
    1682:	1d e2       	ldi	r17, 0x2D	; 45
typedef uint8_t ioport_port_t;
typedef uint8_t ioport_port_mask_t;

__always_inline static ioport_port_t arch_ioport_pin_to_port_id(ioport_pin_t pin)
{
	return pin >> 3;
    1684:	e1 2f       	mov	r30, r17
    1686:	e6 95       	lsr	r30
    1688:	e6 95       	lsr	r30
    168a:	e6 95       	lsr	r30
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
	       (port * IOPORT_PORT_OFFSET));
    168c:	30 e2       	ldi	r19, 0x20	; 32
    168e:	e3 9f       	mul	r30, r19
    1690:	f0 01       	movw	r30, r0
    1692:	11 24       	eor	r1, r1
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    1694:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    1696:	17 70       	andi	r17, 0x07	; 7
    1698:	81 e0       	ldi	r24, 0x01	; 1
    169a:	90 e0       	ldi	r25, 0x00	; 0
    169c:	01 2e       	mov	r0, r17
    169e:	02 c0       	rjmp	.+4      	; 0x16a4 <usart_init_spi+0x288>
    16a0:	88 0f       	add	r24, r24
    16a2:	99 1f       	adc	r25, r25
    16a4:	0a 94       	dec	r0
    16a6:	e2 f7       	brpl	.-8      	; 0x16a0 <usart_init_spi+0x284>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
    16a8:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
    16aa:	22 30       	cpi	r18, 0x02	; 2
    16ac:	10 f0       	brcs	.+4      	; 0x16b2 <usart_init_spi+0x296>
    16ae:	40 e0       	ldi	r20, 0x00	; 0
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <usart_init_spi+0x298>
    16b2:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
    16b4:	df 01       	movw	r26, r30
    16b6:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
    16b8:	a1 0f       	add	r26, r17
    16ba:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    16bc:	3f b7       	in	r19, 0x3f	; 63
	cpu_irq_disable();
    16be:	f8 94       	cli
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
    16c0:	2c 91       	ld	r18, X
    16c2:	27 70       	andi	r18, 0x07	; 7
    16c4:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
    16c6:	9c 91       	ld	r25, X
    16c8:	94 2b       	or	r25, r20
    16ca:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    16cc:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    16ce:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
    16d0:	8d 81       	ldd	r24, Y+5	; 0x05
    16d2:	80 6c       	ori	r24, 0xC0	; 192
    16d4:	8d 83       	std	Y+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
    16d6:	f7 01       	movw	r30, r14
    16d8:	84 81       	ldd	r24, Z+4	; 0x04
    16da:	8d 7f       	andi	r24, 0xFD	; 253
    16dc:	81 30       	cpi	r24, 0x01	; 1
    16de:	21 f4       	brne	.+8      	; 0x16e8 <usart_init_spi+0x2cc>
		usart->CTRLC |= USART_UCPHA_bm;
    16e0:	8d 81       	ldd	r24, Y+5	; 0x05
    16e2:	82 60       	ori	r24, 0x02	; 2
    16e4:	8d 83       	std	Y+5, r24	; 0x05
    16e6:	03 c0       	rjmp	.+6      	; 0x16ee <usart_init_spi+0x2d2>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
    16e8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ea:	8d 7f       	andi	r24, 0xFD	; 253
    16ec:	8d 83       	std	Y+5, r24	; 0x05
	}
	if (opt->data_order) {
    16ee:	f7 01       	movw	r30, r14
    16f0:	85 81       	ldd	r24, Z+5	; 0x05
    16f2:	88 23       	and	r24, r24
    16f4:	21 f0       	breq	.+8      	; 0x16fe <usart_init_spi+0x2e2>
		(usart)->CTRLC |= USART_DORD_bm;
    16f6:	8d 81       	ldd	r24, Y+5	; 0x05
    16f8:	84 60       	ori	r24, 0x04	; 4
    16fa:	8d 83       	std	Y+5, r24	; 0x05
    16fc:	03 c0       	rjmp	.+6      	; 0x1704 <usart_init_spi+0x2e8>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
    16fe:	8d 81       	ldd	r24, Y+5	; 0x05
    1700:	8b 7f       	andi	r24, 0xFB	; 251
    1702:	8d 83       	std	Y+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
    1704:	f7 01       	movw	r30, r14
    1706:	40 81       	ld	r20, Z
    1708:	51 81       	ldd	r21, Z+1	; 0x01
    170a:	62 81       	ldd	r22, Z+2	; 0x02
    170c:	73 81       	ldd	r23, Z+3	; 0x03
    170e:	00 e8       	ldi	r16, 0x80	; 128
    1710:	14 e8       	ldi	r17, 0x84	; 132
    1712:	2e e1       	ldi	r18, 0x1E	; 30
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	ce 01       	movw	r24, r28
    1718:	4f de       	rcall	.-866    	; 0x13b8 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
    171a:	8c 81       	ldd	r24, Y+4	; 0x04
    171c:	88 60       	ori	r24, 0x08	; 8
    171e:	8c 83       	std	Y+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
    1720:	8c 81       	ldd	r24, Y+4	; 0x04
    1722:	80 61       	ori	r24, 0x10	; 16
    1724:	8c 83       	std	Y+4, r24	; 0x04
    1726:	10 c0       	rjmp	.+32     	; 0x1748 <usart_init_spi+0x32c>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
    1728:	8c 81       	ldd	r24, Y+4	; 0x04
    172a:	8f 7e       	andi	r24, 0xEF	; 239
    172c:	8c 83       	std	Y+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
    172e:	f7 01       	movw	r30, r14
    1730:	24 81       	ldd	r18, Z+4	; 0x04
    1732:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
    1734:	ce 01       	movw	r24, r28
    1736:	7c cf       	rjmp	.-264    	; 0x1630 <usart_init_spi+0x214>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
    1738:	15 e1       	ldi	r17, 0x15	; 21
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
    173a:	80 ea       	ldi	r24, 0xA0	; 160
    173c:	98 e0       	ldi	r25, 0x08	; 8
    173e:	86 cf       	rjmp	.-244    	; 0x164c <usart_init_spi+0x230>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
    1740:	1d e1       	ldi	r17, 0x1D	; 29
    1742:	94 cf       	rjmp	.-216    	; 0x166c <usart_init_spi+0x250>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
    1744:	15 e2       	ldi	r17, 0x25	; 37
    1746:	9e cf       	rjmp	.-196    	; 0x1684 <usart_init_spi+0x268>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	1f 91       	pop	r17
    174e:	0f 91       	pop	r16
    1750:	ff 90       	pop	r15
    1752:	ef 90       	pop	r14
    1754:	08 95       	ret

00001756 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1756:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1758:	03 96       	adiw	r24, 0x03	; 3
    175a:	81 83       	std	Z+1, r24	; 0x01
    175c:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    175e:	2f ef       	ldi	r18, 0xFF	; 255
    1760:	3f ef       	ldi	r19, 0xFF	; 255
    1762:	23 83       	std	Z+3, r18	; 0x03
    1764:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1766:	85 83       	std	Z+5, r24	; 0x05
    1768:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    176a:	87 83       	std	Z+7, r24	; 0x07
    176c:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    176e:	10 82       	st	Z, r1
    1770:	08 95       	ret

00001772 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1772:	fc 01       	movw	r30, r24
    1774:	10 86       	std	Z+8, r1	; 0x08
    1776:	11 86       	std	Z+9, r1	; 0x09
    1778:	08 95       	ret

0000177a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    177a:	cf 93       	push	r28
    177c:	df 93       	push	r29
    177e:	9c 01       	movw	r18, r24
    1780:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1782:	dc 01       	movw	r26, r24
    1784:	11 96       	adiw	r26, 0x01	; 1
    1786:	cd 91       	ld	r28, X+
    1788:	dc 91       	ld	r29, X
    178a:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    178c:	c2 83       	std	Z+2, r28	; 0x02
    178e:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1790:	8c 81       	ldd	r24, Y+4	; 0x04
    1792:	9d 81       	ldd	r25, Y+5	; 0x05
    1794:	84 83       	std	Z+4, r24	; 0x04
    1796:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1798:	8c 81       	ldd	r24, Y+4	; 0x04
    179a:	9d 81       	ldd	r25, Y+5	; 0x05
    179c:	dc 01       	movw	r26, r24
    179e:	12 96       	adiw	r26, 0x02	; 2
    17a0:	6d 93       	st	X+, r22
    17a2:	7c 93       	st	X, r23
    17a4:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
    17a6:	6c 83       	std	Y+4, r22	; 0x04
    17a8:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    17aa:	20 87       	std	Z+8, r18	; 0x08
    17ac:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
    17ae:	f9 01       	movw	r30, r18
    17b0:	80 81       	ld	r24, Z
    17b2:	8f 5f       	subi	r24, 0xFF	; 255
    17b4:	80 83       	st	Z, r24
}
    17b6:	df 91       	pop	r29
    17b8:	cf 91       	pop	r28
    17ba:	08 95       	ret

000017bc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    17bc:	cf 93       	push	r28
    17be:	df 93       	push	r29
    17c0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    17c2:	48 81       	ld	r20, Y
    17c4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    17c6:	4f 3f       	cpi	r20, 0xFF	; 255
    17c8:	2f ef       	ldi	r18, 0xFF	; 255
    17ca:	52 07       	cpc	r21, r18
    17cc:	21 f4       	brne	.+8      	; 0x17d6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    17ce:	fc 01       	movw	r30, r24
    17d0:	a7 81       	ldd	r26, Z+7	; 0x07
    17d2:	b0 85       	ldd	r27, Z+8	; 0x08
    17d4:	0d c0       	rjmp	.+26     	; 0x17f0 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    17d6:	dc 01       	movw	r26, r24
    17d8:	13 96       	adiw	r26, 0x03	; 3
    17da:	01 c0       	rjmp	.+2      	; 0x17de <vListInsert+0x22>
    17dc:	df 01       	movw	r26, r30
    17de:	12 96       	adiw	r26, 0x02	; 2
    17e0:	ed 91       	ld	r30, X+
    17e2:	fc 91       	ld	r31, X
    17e4:	13 97       	sbiw	r26, 0x03	; 3
    17e6:	20 81       	ld	r18, Z
    17e8:	31 81       	ldd	r19, Z+1	; 0x01
    17ea:	42 17       	cp	r20, r18
    17ec:	53 07       	cpc	r21, r19
    17ee:	b0 f7       	brcc	.-20     	; 0x17dc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    17f0:	12 96       	adiw	r26, 0x02	; 2
    17f2:	ed 91       	ld	r30, X+
    17f4:	fc 91       	ld	r31, X
    17f6:	13 97       	sbiw	r26, 0x03	; 3
    17f8:	ea 83       	std	Y+2, r30	; 0x02
    17fa:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    17fc:	c4 83       	std	Z+4, r28	; 0x04
    17fe:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1800:	ac 83       	std	Y+4, r26	; 0x04
    1802:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1804:	12 96       	adiw	r26, 0x02	; 2
    1806:	cd 93       	st	X+, r28
    1808:	dc 93       	st	X, r29
    180a:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    180c:	88 87       	std	Y+8, r24	; 0x08
    180e:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1810:	fc 01       	movw	r30, r24
    1812:	20 81       	ld	r18, Z
    1814:	2f 5f       	subi	r18, 0xFF	; 255
    1816:	20 83       	st	Z, r18
}
    1818:	df 91       	pop	r29
    181a:	cf 91       	pop	r28
    181c:	08 95       	ret

0000181e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    181e:	cf 93       	push	r28
    1820:	df 93       	push	r29
    1822:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1824:	a0 85       	ldd	r26, Z+8	; 0x08
    1826:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1828:	c2 81       	ldd	r28, Z+2	; 0x02
    182a:	d3 81       	ldd	r29, Z+3	; 0x03
    182c:	84 81       	ldd	r24, Z+4	; 0x04
    182e:	95 81       	ldd	r25, Z+5	; 0x05
    1830:	8c 83       	std	Y+4, r24	; 0x04
    1832:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1834:	c4 81       	ldd	r28, Z+4	; 0x04
    1836:	d5 81       	ldd	r29, Z+5	; 0x05
    1838:	82 81       	ldd	r24, Z+2	; 0x02
    183a:	93 81       	ldd	r25, Z+3	; 0x03
    183c:	8a 83       	std	Y+2, r24	; 0x02
    183e:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1840:	11 96       	adiw	r26, 0x01	; 1
    1842:	cd 91       	ld	r28, X+
    1844:	dc 91       	ld	r29, X
    1846:	12 97       	sbiw	r26, 0x02	; 2
    1848:	ce 17       	cp	r28, r30
    184a:	df 07       	cpc	r29, r31
    184c:	31 f4       	brne	.+12     	; 0x185a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    184e:	8c 81       	ldd	r24, Y+4	; 0x04
    1850:	9d 81       	ldd	r25, Y+5	; 0x05
    1852:	11 96       	adiw	r26, 0x01	; 1
    1854:	8d 93       	st	X+, r24
    1856:	9c 93       	st	X, r25
    1858:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    185a:	10 86       	std	Z+8, r1	; 0x08
    185c:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    185e:	8c 91       	ld	r24, X
    1860:	81 50       	subi	r24, 0x01	; 1
    1862:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1864:	df 91       	pop	r29
    1866:	cf 91       	pop	r28
    1868:	08 95       	ret

0000186a <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    186a:	0f 93       	push	r16
    186c:	1f 93       	push	r17
    186e:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1870:	71 e1       	ldi	r23, 0x11	; 17
    1872:	fc 01       	movw	r30, r24
    1874:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    1876:	31 97       	sbiw	r30, 0x01	; 1
    1878:	62 e2       	ldi	r22, 0x22	; 34
    187a:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    187c:	31 97       	sbiw	r30, 0x01	; 1
    187e:	23 e3       	ldi	r18, 0x33	; 51
    1880:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    1882:	01 2e       	mov	r0, r17
    1884:	00 0c       	add	r0, r0
    1886:	22 0b       	sbc	r18, r18
    1888:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    188a:	31 97       	sbiw	r30, 0x01	; 1
    188c:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    188e:	31 97       	sbiw	r30, 0x01	; 1
    1890:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    1892:	31 97       	sbiw	r30, 0x01	; 1
    1894:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    1896:	31 97       	sbiw	r30, 0x01	; 1
    1898:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    189a:	31 97       	sbiw	r30, 0x01	; 1
    189c:	20 e8       	ldi	r18, 0x80	; 128
    189e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    18a0:	31 97       	sbiw	r30, 0x01	; 1
    18a2:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    18a4:	31 97       	sbiw	r30, 0x01	; 1
    18a6:	22 e0       	ldi	r18, 0x02	; 2
    18a8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    18aa:	31 97       	sbiw	r30, 0x01	; 1
    18ac:	23 e0       	ldi	r18, 0x03	; 3
    18ae:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    18b0:	31 97       	sbiw	r30, 0x01	; 1
    18b2:	24 e0       	ldi	r18, 0x04	; 4
    18b4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    18b6:	31 97       	sbiw	r30, 0x01	; 1
    18b8:	25 e0       	ldi	r18, 0x05	; 5
    18ba:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    18bc:	31 97       	sbiw	r30, 0x01	; 1
    18be:	26 e0       	ldi	r18, 0x06	; 6
    18c0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    18c2:	31 97       	sbiw	r30, 0x01	; 1
    18c4:	27 e0       	ldi	r18, 0x07	; 7
    18c6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    18c8:	31 97       	sbiw	r30, 0x01	; 1
    18ca:	28 e0       	ldi	r18, 0x08	; 8
    18cc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    18ce:	31 97       	sbiw	r30, 0x01	; 1
    18d0:	29 e0       	ldi	r18, 0x09	; 9
    18d2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    18d4:	31 97       	sbiw	r30, 0x01	; 1
    18d6:	20 e1       	ldi	r18, 0x10	; 16
    18d8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    18da:	31 97       	sbiw	r30, 0x01	; 1
    18dc:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    18de:	31 97       	sbiw	r30, 0x01	; 1
    18e0:	22 e1       	ldi	r18, 0x12	; 18
    18e2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    18e4:	31 97       	sbiw	r30, 0x01	; 1
    18e6:	23 e1       	ldi	r18, 0x13	; 19
    18e8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    18ea:	31 97       	sbiw	r30, 0x01	; 1
    18ec:	24 e1       	ldi	r18, 0x14	; 20
    18ee:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    18f0:	31 97       	sbiw	r30, 0x01	; 1
    18f2:	25 e1       	ldi	r18, 0x15	; 21
    18f4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    18f6:	31 97       	sbiw	r30, 0x01	; 1
    18f8:	26 e1       	ldi	r18, 0x16	; 22
    18fa:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    18fc:	31 97       	sbiw	r30, 0x01	; 1
    18fe:	27 e1       	ldi	r18, 0x17	; 23
    1900:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1902:	31 97       	sbiw	r30, 0x01	; 1
    1904:	28 e1       	ldi	r18, 0x18	; 24
    1906:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    1908:	31 97       	sbiw	r30, 0x01	; 1
    190a:	29 e1       	ldi	r18, 0x19	; 25
    190c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    190e:	31 97       	sbiw	r30, 0x01	; 1
    1910:	20 e2       	ldi	r18, 0x20	; 32
    1912:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1914:	31 97       	sbiw	r30, 0x01	; 1
    1916:	21 e2       	ldi	r18, 0x21	; 33
    1918:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    191a:	31 97       	sbiw	r30, 0x01	; 1
    191c:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    191e:	31 97       	sbiw	r30, 0x01	; 1
    1920:	23 e2       	ldi	r18, 0x23	; 35
    1922:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1924:	31 97       	sbiw	r30, 0x01	; 1
    1926:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1928:	31 97       	sbiw	r30, 0x01	; 1
    192a:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    192c:	31 97       	sbiw	r30, 0x01	; 1
    192e:	26 e2       	ldi	r18, 0x26	; 38
    1930:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1932:	31 97       	sbiw	r30, 0x01	; 1
    1934:	27 e2       	ldi	r18, 0x27	; 39
    1936:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    1938:	31 97       	sbiw	r30, 0x01	; 1
    193a:	28 e2       	ldi	r18, 0x28	; 40
    193c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    193e:	31 97       	sbiw	r30, 0x01	; 1
    1940:	29 e2       	ldi	r18, 0x29	; 41
    1942:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1944:	31 97       	sbiw	r30, 0x01	; 1
    1946:	20 e3       	ldi	r18, 0x30	; 48
    1948:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    194a:	31 97       	sbiw	r30, 0x01	; 1
    194c:	21 e3       	ldi	r18, 0x31	; 49
    194e:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1950:	87 97       	sbiw	r24, 0x27	; 39
    1952:	1f 91       	pop	r17
    1954:	0f 91       	pop	r16
    1956:	08 95       	ret

00001958 <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    1958:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    195a:	e0 e7       	ldi	r30, 0x70	; 112
    195c:	f0 e0       	ldi	r31, 0x00	; 0
    195e:	83 81       	ldd	r24, Z+3	; 0x03
    1960:	8a 7f       	andi	r24, 0xFA	; 250
    1962:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1964:	e0 e0       	ldi	r30, 0x00	; 0
    1966:	f8 e0       	ldi	r31, 0x08	; 8
    1968:	80 e0       	ldi	r24, 0x00	; 0
    196a:	9a ef       	ldi	r25, 0xFA	; 250
    196c:	86 a3       	std	Z+38, r24	; 0x26
    196e:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1970:	91 e0       	ldi	r25, 0x01	; 1
    1972:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1974:	a0 ea       	ldi	r26, 0xA0	; 160
    1976:	b0 e0       	ldi	r27, 0x00	; 0
    1978:	12 96       	adiw	r26, 0x02	; 2
    197a:	8c 91       	ld	r24, X
    197c:	12 97       	sbiw	r26, 0x02	; 2
    197e:	81 60       	ori	r24, 0x01	; 1
    1980:	12 96       	adiw	r26, 0x02	; 2
    1982:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    1984:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    1986:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    1988:	a0 91 ac 22 	lds	r26, 0x22AC
    198c:	b0 91 ad 22 	lds	r27, 0x22AD
    1990:	0d 90       	ld	r0, X+
    1992:	0d be       	out	0x3d, r0	; 61
    1994:	0d 90       	ld	r0, X+
    1996:	0e be       	out	0x3e, r0	; 62
    1998:	ff 91       	pop	r31
    199a:	ef 91       	pop	r30
    199c:	df 91       	pop	r29
    199e:	cf 91       	pop	r28
    19a0:	bf 91       	pop	r27
    19a2:	af 91       	pop	r26
    19a4:	9f 91       	pop	r25
    19a6:	8f 91       	pop	r24
    19a8:	7f 91       	pop	r23
    19aa:	6f 91       	pop	r22
    19ac:	5f 91       	pop	r21
    19ae:	4f 91       	pop	r20
    19b0:	3f 91       	pop	r19
    19b2:	2f 91       	pop	r18
    19b4:	1f 91       	pop	r17
    19b6:	0f 91       	pop	r16
    19b8:	ff 90       	pop	r15
    19ba:	ef 90       	pop	r14
    19bc:	df 90       	pop	r13
    19be:	cf 90       	pop	r12
    19c0:	bf 90       	pop	r11
    19c2:	af 90       	pop	r10
    19c4:	9f 90       	pop	r9
    19c6:	8f 90       	pop	r8
    19c8:	7f 90       	pop	r7
    19ca:	6f 90       	pop	r6
    19cc:	5f 90       	pop	r5
    19ce:	4f 90       	pop	r4
    19d0:	3f 90       	pop	r3
    19d2:	2f 90       	pop	r2
    19d4:	1f 90       	pop	r1
    19d6:	0f 90       	pop	r0
    19d8:	0f be       	out	0x3f, r0	; 63
    19da:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    19dc:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    19de:	81 e0       	ldi	r24, 0x01	; 1
    19e0:	08 95       	ret

000019e2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    19e2:	0f 92       	push	r0
    19e4:	0f b6       	in	r0, 0x3f	; 63
    19e6:	f8 94       	cli
    19e8:	0f 92       	push	r0
    19ea:	1f 92       	push	r1
    19ec:	11 24       	eor	r1, r1
    19ee:	2f 92       	push	r2
    19f0:	3f 92       	push	r3
    19f2:	4f 92       	push	r4
    19f4:	5f 92       	push	r5
    19f6:	6f 92       	push	r6
    19f8:	7f 92       	push	r7
    19fa:	8f 92       	push	r8
    19fc:	9f 92       	push	r9
    19fe:	af 92       	push	r10
    1a00:	bf 92       	push	r11
    1a02:	cf 92       	push	r12
    1a04:	df 92       	push	r13
    1a06:	ef 92       	push	r14
    1a08:	ff 92       	push	r15
    1a0a:	0f 93       	push	r16
    1a0c:	1f 93       	push	r17
    1a0e:	2f 93       	push	r18
    1a10:	3f 93       	push	r19
    1a12:	4f 93       	push	r20
    1a14:	5f 93       	push	r21
    1a16:	6f 93       	push	r22
    1a18:	7f 93       	push	r23
    1a1a:	8f 93       	push	r24
    1a1c:	9f 93       	push	r25
    1a1e:	af 93       	push	r26
    1a20:	bf 93       	push	r27
    1a22:	cf 93       	push	r28
    1a24:	df 93       	push	r29
    1a26:	ef 93       	push	r30
    1a28:	ff 93       	push	r31
    1a2a:	a0 91 ac 22 	lds	r26, 0x22AC
    1a2e:	b0 91 ad 22 	lds	r27, 0x22AD
    1a32:	0d b6       	in	r0, 0x3d	; 61
    1a34:	0d 92       	st	X+, r0
    1a36:	0e b6       	in	r0, 0x3e	; 62
    1a38:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    1a3a:	10 d6       	rcall	.+3104   	; 0x265c <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1a3c:	a0 91 ac 22 	lds	r26, 0x22AC
    1a40:	b0 91 ad 22 	lds	r27, 0x22AD
    1a44:	0d 90       	ld	r0, X+
    1a46:	0d be       	out	0x3d, r0	; 61
    1a48:	0d 90       	ld	r0, X+
    1a4a:	0e be       	out	0x3e, r0	; 62
    1a4c:	ff 91       	pop	r31
    1a4e:	ef 91       	pop	r30
    1a50:	df 91       	pop	r29
    1a52:	cf 91       	pop	r28
    1a54:	bf 91       	pop	r27
    1a56:	af 91       	pop	r26
    1a58:	9f 91       	pop	r25
    1a5a:	8f 91       	pop	r24
    1a5c:	7f 91       	pop	r23
    1a5e:	6f 91       	pop	r22
    1a60:	5f 91       	pop	r21
    1a62:	4f 91       	pop	r20
    1a64:	3f 91       	pop	r19
    1a66:	2f 91       	pop	r18
    1a68:	1f 91       	pop	r17
    1a6a:	0f 91       	pop	r16
    1a6c:	ff 90       	pop	r15
    1a6e:	ef 90       	pop	r14
    1a70:	df 90       	pop	r13
    1a72:	cf 90       	pop	r12
    1a74:	bf 90       	pop	r11
    1a76:	af 90       	pop	r10
    1a78:	9f 90       	pop	r9
    1a7a:	8f 90       	pop	r8
    1a7c:	7f 90       	pop	r7
    1a7e:	6f 90       	pop	r6
    1a80:	5f 90       	pop	r5
    1a82:	4f 90       	pop	r4
    1a84:	3f 90       	pop	r3
    1a86:	2f 90       	pop	r2
    1a88:	1f 90       	pop	r1
    1a8a:	0f 90       	pop	r0
    1a8c:	0f be       	out	0x3f, r0	; 63
    1a8e:	0f 90       	pop	r0

    asm volatile ( "ret" );
    1a90:	08 95       	ret

00001a92 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    1a92:	0f 92       	push	r0
    1a94:	0f b6       	in	r0, 0x3f	; 63
    1a96:	f8 94       	cli
    1a98:	0f 92       	push	r0
    1a9a:	1f 92       	push	r1
    1a9c:	11 24       	eor	r1, r1
    1a9e:	2f 92       	push	r2
    1aa0:	3f 92       	push	r3
    1aa2:	4f 92       	push	r4
    1aa4:	5f 92       	push	r5
    1aa6:	6f 92       	push	r6
    1aa8:	7f 92       	push	r7
    1aaa:	8f 92       	push	r8
    1aac:	9f 92       	push	r9
    1aae:	af 92       	push	r10
    1ab0:	bf 92       	push	r11
    1ab2:	cf 92       	push	r12
    1ab4:	df 92       	push	r13
    1ab6:	ef 92       	push	r14
    1ab8:	ff 92       	push	r15
    1aba:	0f 93       	push	r16
    1abc:	1f 93       	push	r17
    1abe:	2f 93       	push	r18
    1ac0:	3f 93       	push	r19
    1ac2:	4f 93       	push	r20
    1ac4:	5f 93       	push	r21
    1ac6:	6f 93       	push	r22
    1ac8:	7f 93       	push	r23
    1aca:	8f 93       	push	r24
    1acc:	9f 93       	push	r25
    1ace:	af 93       	push	r26
    1ad0:	bf 93       	push	r27
    1ad2:	cf 93       	push	r28
    1ad4:	df 93       	push	r29
    1ad6:	ef 93       	push	r30
    1ad8:	ff 93       	push	r31
    1ada:	a0 91 ac 22 	lds	r26, 0x22AC
    1ade:	b0 91 ad 22 	lds	r27, 0x22AD
    1ae2:	0d b6       	in	r0, 0x3d	; 61
    1ae4:	0d 92       	st	X+, r0
    1ae6:	0e b6       	in	r0, 0x3e	; 62
    1ae8:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    1aea:	4d d4       	rcall	.+2202   	; 0x2386 <xTaskIncrementTick>
    1aec:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    1aee:	b6 d5       	rcall	.+2924   	; 0x265c <vTaskSwitchContext>
        }
        portRESTORE_CONTEXT();
    1af0:	a0 91 ac 22 	lds	r26, 0x22AC
    1af4:	b0 91 ad 22 	lds	r27, 0x22AD
    1af8:	0d 90       	ld	r0, X+
    1afa:	0d be       	out	0x3d, r0	; 61
    1afc:	0d 90       	ld	r0, X+
    1afe:	0e be       	out	0x3e, r0	; 62
    1b00:	ff 91       	pop	r31
    1b02:	ef 91       	pop	r30
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	bf 91       	pop	r27
    1b0a:	af 91       	pop	r26
    1b0c:	9f 91       	pop	r25
    1b0e:	8f 91       	pop	r24
    1b10:	7f 91       	pop	r23
    1b12:	6f 91       	pop	r22
    1b14:	5f 91       	pop	r21
    1b16:	4f 91       	pop	r20
    1b18:	3f 91       	pop	r19
    1b1a:	2f 91       	pop	r18
    1b1c:	1f 91       	pop	r17
    1b1e:	0f 91       	pop	r16
    1b20:	ff 90       	pop	r15
    1b22:	ef 90       	pop	r14
    1b24:	df 90       	pop	r13
    1b26:	cf 90       	pop	r12
    1b28:	bf 90       	pop	r11
    1b2a:	af 90       	pop	r10
    1b2c:	9f 90       	pop	r9
    1b2e:	8f 90       	pop	r8
    1b30:	7f 90       	pop	r7
    1b32:	6f 90       	pop	r6
    1b34:	5f 90       	pop	r5
    1b36:	4f 90       	pop	r4
    1b38:	3f 90       	pop	r3
    1b3a:	2f 90       	pop	r2
    1b3c:	1f 90       	pop	r1
    1b3e:	0f 90       	pop	r0
    1b40:	0f be       	out	0x3f, r0	; 63
    1b42:	0f 90       	pop	r0

        asm volatile ( "reti" );
    1b44:	18 95       	reti

00001b46 <pvPortMalloc>:
#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1b46:	cf 93       	push	r28
    1b48:	df 93       	push	r29
    1b4a:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    1b4c:	0c d4       	rcall	.+2072   	; 0x2366 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    1b4e:	ce 01       	movw	r24, r28
    1b50:	0e 94 c1 19 	call	0x3382	; 0x3382 <malloc>
    1b54:	ec 01       	movw	r28, r24
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1b56:	ea d4       	rcall	.+2516   	; 0x252c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1b58:	ce 01       	movw	r24, r28
    1b5a:	df 91       	pop	r29
    1b5c:	cf 91       	pop	r28
    1b5e:	08 95       	ret

00001b60 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1b60:	cf 93       	push	r28
    1b62:	df 93       	push	r29
	if( pv )
    1b64:	00 97       	sbiw	r24, 0x00	; 0
    1b66:	31 f0       	breq	.+12     	; 0x1b74 <vPortFree+0x14>
    1b68:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    1b6a:	fd d3       	rcall	.+2042   	; 0x2366 <vTaskSuspendAll>
		{
			free( pv );
    1b6c:	ce 01       	movw	r24, r28
    1b6e:	0e 94 56 1a 	call	0x34ac	; 0x34ac <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    1b72:	dc d4       	rcall	.+2488   	; 0x252c <xTaskResumeAll>
	}
}
    1b74:	df 91       	pop	r29
    1b76:	cf 91       	pop	r28
    1b78:	08 95       	ret

00001b7a <prvCopyDataToQueue>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1b7a:	1f 93       	push	r17
    1b7c:	cf 93       	push	r28
    1b7e:	df 93       	push	r29
    1b80:	ec 01       	movw	r28, r24
    1b82:	14 2f       	mov	r17, r20
    1b84:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1b86:	88 23       	and	r24, r24
    1b88:	e9 f1       	breq	.+122    	; 0x1c04 <prvCopyDataToQueue+0x8a>
    1b8a:	41 11       	cpse	r20, r1
    1b8c:	17 c0       	rjmp	.+46     	; 0x1bbc <prvCopyDataToQueue+0x42>
    1b8e:	48 2f       	mov	r20, r24
    1b90:	50 e0       	ldi	r21, 0x00	; 0
    1b92:	8c 81       	ldd	r24, Y+4	; 0x04
    1b94:	9d 81       	ldd	r25, Y+5	; 0x05
    1b96:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <memcpy>
    1b9a:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1b9c:	8c 81       	ldd	r24, Y+4	; 0x04
    1b9e:	9d 81       	ldd	r25, Y+5	; 0x05
    1ba0:	82 0f       	add	r24, r18
    1ba2:	91 1d       	adc	r25, r1
    1ba4:	8c 83       	std	Y+4, r24	; 0x04
    1ba6:	9d 83       	std	Y+5, r25	; 0x05
    1ba8:	2a 81       	ldd	r18, Y+2	; 0x02
    1baa:	3b 81       	ldd	r19, Y+3	; 0x03
    1bac:	82 17       	cp	r24, r18
    1bae:	93 07       	cpc	r25, r19
    1bb0:	48 f1       	brcs	.+82     	; 0x1c04 <prvCopyDataToQueue+0x8a>
    1bb2:	88 81       	ld	r24, Y
    1bb4:	99 81       	ldd	r25, Y+1	; 0x01
    1bb6:	8c 83       	std	Y+4, r24	; 0x04
    1bb8:	9d 83       	std	Y+5, r25	; 0x05
    1bba:	24 c0       	rjmp	.+72     	; 0x1c04 <prvCopyDataToQueue+0x8a>
    1bbc:	48 2f       	mov	r20, r24
    1bbe:	50 e0       	ldi	r21, 0x00	; 0
    1bc0:	8e 81       	ldd	r24, Y+6	; 0x06
    1bc2:	9f 81       	ldd	r25, Y+7	; 0x07
    1bc4:	0e 94 ee 1a 	call	0x35dc	; 0x35dc <memcpy>
    1bc8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1bca:	90 e0       	ldi	r25, 0x00	; 0
    1bcc:	91 95       	neg	r25
    1bce:	81 95       	neg	r24
    1bd0:	91 09       	sbc	r25, r1
    1bd2:	2e 81       	ldd	r18, Y+6	; 0x06
    1bd4:	3f 81       	ldd	r19, Y+7	; 0x07
    1bd6:	28 0f       	add	r18, r24
    1bd8:	39 1f       	adc	r19, r25
    1bda:	2e 83       	std	Y+6, r18	; 0x06
    1bdc:	3f 83       	std	Y+7, r19	; 0x07
    1bde:	48 81       	ld	r20, Y
    1be0:	59 81       	ldd	r21, Y+1	; 0x01
    1be2:	24 17       	cp	r18, r20
    1be4:	35 07       	cpc	r19, r21
    1be6:	30 f4       	brcc	.+12     	; 0x1bf4 <prvCopyDataToQueue+0x7a>
    1be8:	2a 81       	ldd	r18, Y+2	; 0x02
    1bea:	3b 81       	ldd	r19, Y+3	; 0x03
    1bec:	82 0f       	add	r24, r18
    1bee:	93 1f       	adc	r25, r19
    1bf0:	8e 83       	std	Y+6, r24	; 0x06
    1bf2:	9f 83       	std	Y+7, r25	; 0x07
    1bf4:	12 30       	cpi	r17, 0x02	; 2
    1bf6:	31 f4       	brne	.+12     	; 0x1c04 <prvCopyDataToQueue+0x8a>
    1bf8:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1bfa:	88 23       	and	r24, r24
    1bfc:	19 f0       	breq	.+6      	; 0x1c04 <prvCopyDataToQueue+0x8a>
    1bfe:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c00:	81 50       	subi	r24, 0x01	; 1
    1c02:	8a 8f       	std	Y+26, r24	; 0x1a
    1c04:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c06:	8f 5f       	subi	r24, 0xFF	; 255
    1c08:	8a 8f       	std	Y+26, r24	; 0x1a
    1c0a:	80 e0       	ldi	r24, 0x00	; 0
    1c0c:	df 91       	pop	r29
    1c0e:	cf 91       	pop	r28
    1c10:	1f 91       	pop	r17
    1c12:	08 95       	ret

00001c14 <prvCopyDataFromQueue>:
    1c14:	fc 01       	movw	r30, r24
    1c16:	44 8d       	ldd	r20, Z+28	; 0x1c
    1c18:	44 23       	and	r20, r20
    1c1a:	a9 f0       	breq	.+42     	; 0x1c46 <prvCopyDataFromQueue+0x32>
    1c1c:	50 e0       	ldi	r21, 0x00	; 0
    1c1e:	26 81       	ldd	r18, Z+6	; 0x06
    1c20:	37 81       	ldd	r19, Z+7	; 0x07
    1c22:	24 0f       	add	r18, r20
    1c24:	35 1f       	adc	r19, r21
    1c26:	26 83       	std	Z+6, r18	; 0x06
    1c28:	37 83       	std	Z+7, r19	; 0x07
    1c2a:	82 81       	ldd	r24, Z+2	; 0x02
    1c2c:	93 81       	ldd	r25, Z+3	; 0x03
    1c2e:	28 17       	cp	r18, r24
    1c30:	39 07       	cpc	r19, r25
    1c32:	20 f0       	brcs	.+8      	; 0x1c3c <prvCopyDataFromQueue+0x28>
    1c34:	80 81       	ld	r24, Z
    1c36:	91 81       	ldd	r25, Z+1	; 0x01
    1c38:	86 83       	std	Z+6, r24	; 0x06
    1c3a:	97 83       	std	Z+7, r25	; 0x07
    1c3c:	cb 01       	movw	r24, r22
    1c3e:	66 81       	ldd	r22, Z+6	; 0x06
    1c40:	77 81       	ldd	r23, Z+7	; 0x07
    1c42:	0c 94 ee 1a 	jmp	0x35dc	; 0x35dc <memcpy>
    1c46:	08 95       	ret

00001c48 <prvUnlockQueue>:
    1c48:	0f 93       	push	r16
    1c4a:	1f 93       	push	r17
    1c4c:	cf 93       	push	r28
    1c4e:	df 93       	push	r29
    1c50:	ec 01       	movw	r28, r24
    1c52:	0f b6       	in	r0, 0x3f	; 63
    1c54:	f8 94       	cli
    1c56:	0f 92       	push	r0
    1c58:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1c5a:	18 16       	cp	r1, r24
    1c5c:	ac f4       	brge	.+42     	; 0x1c88 <prvUnlockQueue+0x40>
    1c5e:	89 89       	ldd	r24, Y+17	; 0x11
    1c60:	81 11       	cpse	r24, r1
    1c62:	05 c0       	rjmp	.+10     	; 0x1c6e <prvUnlockQueue+0x26>
    1c64:	11 c0       	rjmp	.+34     	; 0x1c88 <prvUnlockQueue+0x40>
    1c66:	99 89       	ldd	r25, Y+17	; 0x11
    1c68:	91 11       	cpse	r25, r1
    1c6a:	04 c0       	rjmp	.+8      	; 0x1c74 <prvUnlockQueue+0x2c>
    1c6c:	0d c0       	rjmp	.+26     	; 0x1c88 <prvUnlockQueue+0x40>
    1c6e:	8e 01       	movw	r16, r28
    1c70:	0f 5e       	subi	r16, 0xEF	; 239
    1c72:	1f 4f       	sbci	r17, 0xFF	; 255
    1c74:	c8 01       	movw	r24, r16
    1c76:	96 d5       	rcall	.+2860   	; 0x27a4 <xTaskRemoveFromEventList>
    1c78:	81 11       	cpse	r24, r1
    1c7a:	16 d6       	rcall	.+3116   	; 0x28a8 <vTaskMissedYield>
    1c7c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1c7e:	91 50       	subi	r25, 0x01	; 1
    1c80:	9e 8f       	std	Y+30, r25	; 0x1e
    1c82:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1c84:	19 16       	cp	r1, r25
    1c86:	7c f3       	brlt	.-34     	; 0x1c66 <prvUnlockQueue+0x1e>
    1c88:	8f ef       	ldi	r24, 0xFF	; 255
    1c8a:	8e 8f       	std	Y+30, r24	; 0x1e
    1c8c:	0f 90       	pop	r0
    1c8e:	0f be       	out	0x3f, r0	; 63
    1c90:	0f b6       	in	r0, 0x3f	; 63
    1c92:	f8 94       	cli
    1c94:	0f 92       	push	r0
    1c96:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1c98:	18 16       	cp	r1, r24
    1c9a:	ac f4       	brge	.+42     	; 0x1cc6 <prvUnlockQueue+0x7e>
    1c9c:	88 85       	ldd	r24, Y+8	; 0x08
    1c9e:	81 11       	cpse	r24, r1
    1ca0:	05 c0       	rjmp	.+10     	; 0x1cac <prvUnlockQueue+0x64>
    1ca2:	11 c0       	rjmp	.+34     	; 0x1cc6 <prvUnlockQueue+0x7e>
    1ca4:	98 85       	ldd	r25, Y+8	; 0x08
    1ca6:	91 11       	cpse	r25, r1
    1ca8:	04 c0       	rjmp	.+8      	; 0x1cb2 <prvUnlockQueue+0x6a>
    1caa:	0d c0       	rjmp	.+26     	; 0x1cc6 <prvUnlockQueue+0x7e>
    1cac:	8e 01       	movw	r16, r28
    1cae:	08 5f       	subi	r16, 0xF8	; 248
    1cb0:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb2:	c8 01       	movw	r24, r16
    1cb4:	77 d5       	rcall	.+2798   	; 0x27a4 <xTaskRemoveFromEventList>
    1cb6:	81 11       	cpse	r24, r1
    1cb8:	f7 d5       	rcall	.+3054   	; 0x28a8 <vTaskMissedYield>
    1cba:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1cbc:	91 50       	subi	r25, 0x01	; 1
    1cbe:	9d 8f       	std	Y+29, r25	; 0x1d
    1cc0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1cc2:	19 16       	cp	r1, r25
    1cc4:	7c f3       	brlt	.-34     	; 0x1ca4 <prvUnlockQueue+0x5c>
    1cc6:	8f ef       	ldi	r24, 0xFF	; 255
    1cc8:	8d 8f       	std	Y+29, r24	; 0x1d
    1cca:	0f 90       	pop	r0
    1ccc:	0f be       	out	0x3f, r0	; 63
    1cce:	df 91       	pop	r29
    1cd0:	cf 91       	pop	r28
    1cd2:	1f 91       	pop	r17
    1cd4:	0f 91       	pop	r16
    1cd6:	08 95       	ret

00001cd8 <xQueueGenericReset>:
    1cd8:	cf 93       	push	r28
    1cda:	df 93       	push	r29
    1cdc:	ec 01       	movw	r28, r24
    1cde:	0f b6       	in	r0, 0x3f	; 63
    1ce0:	f8 94       	cli
    1ce2:	0f 92       	push	r0
    1ce4:	48 81       	ld	r20, Y
    1ce6:	59 81       	ldd	r21, Y+1	; 0x01
    1ce8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1cea:	30 e0       	ldi	r19, 0x00	; 0
    1cec:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1cee:	72 9f       	mul	r23, r18
    1cf0:	c0 01       	movw	r24, r0
    1cf2:	73 9f       	mul	r23, r19
    1cf4:	90 0d       	add	r25, r0
    1cf6:	11 24       	eor	r1, r1
    1cf8:	fa 01       	movw	r30, r20
    1cfa:	e8 0f       	add	r30, r24
    1cfc:	f9 1f       	adc	r31, r25
    1cfe:	ea 83       	std	Y+2, r30	; 0x02
    1d00:	fb 83       	std	Y+3, r31	; 0x03
    1d02:	1a 8e       	std	Y+26, r1	; 0x1a
    1d04:	4c 83       	std	Y+4, r20	; 0x04
    1d06:	5d 83       	std	Y+5, r21	; 0x05
    1d08:	82 1b       	sub	r24, r18
    1d0a:	93 0b       	sbc	r25, r19
    1d0c:	84 0f       	add	r24, r20
    1d0e:	95 1f       	adc	r25, r21
    1d10:	8e 83       	std	Y+6, r24	; 0x06
    1d12:	9f 83       	std	Y+7, r25	; 0x07
    1d14:	8f ef       	ldi	r24, 0xFF	; 255
    1d16:	8d 8f       	std	Y+29, r24	; 0x1d
    1d18:	8e 8f       	std	Y+30, r24	; 0x1e
    1d1a:	61 11       	cpse	r22, r1
    1d1c:	0a c0       	rjmp	.+20     	; 0x1d32 <xQueueGenericReset+0x5a>
    1d1e:	88 85       	ldd	r24, Y+8	; 0x08
    1d20:	88 23       	and	r24, r24
    1d22:	69 f0       	breq	.+26     	; 0x1d3e <xQueueGenericReset+0x66>
    1d24:	ce 01       	movw	r24, r28
    1d26:	08 96       	adiw	r24, 0x08	; 8
    1d28:	3d d5       	rcall	.+2682   	; 0x27a4 <xTaskRemoveFromEventList>
    1d2a:	81 30       	cpi	r24, 0x01	; 1
    1d2c:	41 f4       	brne	.+16     	; 0x1d3e <xQueueGenericReset+0x66>
    1d2e:	59 de       	rcall	.-846    	; 0x19e2 <vPortYield>
    1d30:	06 c0       	rjmp	.+12     	; 0x1d3e <xQueueGenericReset+0x66>
    1d32:	ce 01       	movw	r24, r28
    1d34:	08 96       	adiw	r24, 0x08	; 8
    1d36:	0f dd       	rcall	.-1506   	; 0x1756 <vListInitialise>
    1d38:	ce 01       	movw	r24, r28
    1d3a:	41 96       	adiw	r24, 0x11	; 17
    1d3c:	0c dd       	rcall	.-1512   	; 0x1756 <vListInitialise>
    1d3e:	0f 90       	pop	r0
    1d40:	0f be       	out	0x3f, r0	; 63
    1d42:	81 e0       	ldi	r24, 0x01	; 1
    1d44:	df 91       	pop	r29
    1d46:	cf 91       	pop	r28
    1d48:	08 95       	ret

00001d4a <xQueueGenericCreate>:
    1d4a:	0f 93       	push	r16
    1d4c:	1f 93       	push	r17
    1d4e:	cf 93       	push	r28
    1d50:	df 93       	push	r29
    1d52:	08 2f       	mov	r16, r24
    1d54:	16 2f       	mov	r17, r22
    1d56:	66 23       	and	r22, r22
    1d58:	a9 f0       	breq	.+42     	; 0x1d84 <xQueueGenericCreate+0x3a>
    1d5a:	86 9f       	mul	r24, r22
    1d5c:	c0 01       	movw	r24, r0
    1d5e:	11 24       	eor	r1, r1
    1d60:	80 96       	adiw	r24, 0x20	; 32
    1d62:	f1 de       	rcall	.-542    	; 0x1b46 <pvPortMalloc>
    1d64:	ec 01       	movw	r28, r24
    1d66:	00 97       	sbiw	r24, 0x00	; 0
    1d68:	21 f4       	brne	.+8      	; 0x1d72 <xQueueGenericCreate+0x28>
    1d6a:	12 c0       	rjmp	.+36     	; 0x1d90 <xQueueGenericCreate+0x46>
    1d6c:	c8 83       	st	Y, r28
    1d6e:	d9 83       	std	Y+1, r29	; 0x01
    1d70:	03 c0       	rjmp	.+6      	; 0x1d78 <xQueueGenericCreate+0x2e>
    1d72:	4f 96       	adiw	r24, 0x1f	; 31
    1d74:	88 83       	st	Y, r24
    1d76:	99 83       	std	Y+1, r25	; 0x01
    1d78:	0b 8f       	std	Y+27, r16	; 0x1b
    1d7a:	1c 8f       	std	Y+28, r17	; 0x1c
    1d7c:	61 e0       	ldi	r22, 0x01	; 1
    1d7e:	ce 01       	movw	r24, r28
    1d80:	ab df       	rcall	.-170    	; 0x1cd8 <xQueueGenericReset>
    1d82:	06 c0       	rjmp	.+12     	; 0x1d90 <xQueueGenericCreate+0x46>
    1d84:	8f e1       	ldi	r24, 0x1F	; 31
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	de de       	rcall	.-580    	; 0x1b46 <pvPortMalloc>
    1d8a:	ec 01       	movw	r28, r24
    1d8c:	89 2b       	or	r24, r25
    1d8e:	71 f7       	brne	.-36     	; 0x1d6c <xQueueGenericCreate+0x22>
    1d90:	ce 01       	movw	r24, r28
    1d92:	df 91       	pop	r29
    1d94:	cf 91       	pop	r28
    1d96:	1f 91       	pop	r17
    1d98:	0f 91       	pop	r16
    1d9a:	08 95       	ret

00001d9c <xQueueGenericSend>:
    1d9c:	af 92       	push	r10
    1d9e:	bf 92       	push	r11
    1da0:	cf 92       	push	r12
    1da2:	df 92       	push	r13
    1da4:	ef 92       	push	r14
    1da6:	ff 92       	push	r15
    1da8:	0f 93       	push	r16
    1daa:	1f 93       	push	r17
    1dac:	cf 93       	push	r28
    1dae:	df 93       	push	r29
    1db0:	cd b7       	in	r28, 0x3d	; 61
    1db2:	de b7       	in	r29, 0x3e	; 62
    1db4:	25 97       	sbiw	r28, 0x05	; 5
    1db6:	cd bf       	out	0x3d, r28	; 61
    1db8:	de bf       	out	0x3e, r29	; 62
    1dba:	8c 01       	movw	r16, r24
    1dbc:	6b 01       	movw	r12, r22
    1dbe:	4c 83       	std	Y+4, r20	; 0x04
    1dc0:	5d 83       	std	Y+5, r21	; 0x05
    1dc2:	a2 2e       	mov	r10, r18
    1dc4:	b1 2c       	mov	r11, r1
    1dc6:	7c 01       	movw	r14, r24
    1dc8:	88 e0       	ldi	r24, 0x08	; 8
    1dca:	e8 0e       	add	r14, r24
    1dcc:	f1 1c       	adc	r15, r1
    1dce:	0f b6       	in	r0, 0x3f	; 63
    1dd0:	f8 94       	cli
    1dd2:	0f 92       	push	r0
    1dd4:	f8 01       	movw	r30, r16
    1dd6:	32 8d       	ldd	r19, Z+26	; 0x1a
    1dd8:	93 8d       	ldd	r25, Z+27	; 0x1b
    1dda:	39 17       	cp	r19, r25
    1ddc:	18 f0       	brcs	.+6      	; 0x1de4 <xQueueGenericSend+0x48>
    1dde:	f2 e0       	ldi	r31, 0x02	; 2
    1de0:	af 12       	cpse	r10, r31
    1de2:	15 c0       	rjmp	.+42     	; 0x1e0e <xQueueGenericSend+0x72>
    1de4:	4a 2d       	mov	r20, r10
    1de6:	b6 01       	movw	r22, r12
    1de8:	c8 01       	movw	r24, r16
    1dea:	c7 de       	rcall	.-626    	; 0x1b7a <prvCopyDataToQueue>
    1dec:	f8 01       	movw	r30, r16
    1dee:	91 89       	ldd	r25, Z+17	; 0x11
    1df0:	99 23       	and	r25, r25
    1df2:	39 f0       	breq	.+14     	; 0x1e02 <xQueueGenericSend+0x66>
    1df4:	c8 01       	movw	r24, r16
    1df6:	41 96       	adiw	r24, 0x11	; 17
    1df8:	d5 d4       	rcall	.+2474   	; 0x27a4 <xTaskRemoveFromEventList>
    1dfa:	81 30       	cpi	r24, 0x01	; 1
    1dfc:	21 f4       	brne	.+8      	; 0x1e06 <xQueueGenericSend+0x6a>
    1dfe:	f1 dd       	rcall	.-1054   	; 0x19e2 <vPortYield>
    1e00:	02 c0       	rjmp	.+4      	; 0x1e06 <xQueueGenericSend+0x6a>
    1e02:	81 11       	cpse	r24, r1
    1e04:	ee dd       	rcall	.-1060   	; 0x19e2 <vPortYield>
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	81 e0       	ldi	r24, 0x01	; 1
    1e0c:	46 c0       	rjmp	.+140    	; 0x1e9a <xQueueGenericSend+0xfe>
    1e0e:	ec 81       	ldd	r30, Y+4	; 0x04
    1e10:	fd 81       	ldd	r31, Y+5	; 0x05
    1e12:	ef 2b       	or	r30, r31
    1e14:	21 f4       	brne	.+8      	; 0x1e1e <xQueueGenericSend+0x82>
    1e16:	0f 90       	pop	r0
    1e18:	0f be       	out	0x3f, r0	; 63
    1e1a:	80 e0       	ldi	r24, 0x00	; 0
    1e1c:	3e c0       	rjmp	.+124    	; 0x1e9a <xQueueGenericSend+0xfe>
    1e1e:	b1 10       	cpse	r11, r1
    1e20:	05 c0       	rjmp	.+10     	; 0x1e2c <xQueueGenericSend+0x90>
    1e22:	ce 01       	movw	r24, r28
    1e24:	01 96       	adiw	r24, 0x01	; 1
    1e26:	04 d5       	rcall	.+2568   	; 0x2830 <vTaskSetTimeOutState>
    1e28:	bb 24       	eor	r11, r11
    1e2a:	b3 94       	inc	r11
    1e2c:	0f 90       	pop	r0
    1e2e:	0f be       	out	0x3f, r0	; 63
    1e30:	9a d2       	rcall	.+1332   	; 0x2366 <vTaskSuspendAll>
    1e32:	0f b6       	in	r0, 0x3f	; 63
    1e34:	f8 94       	cli
    1e36:	0f 92       	push	r0
    1e38:	f8 01       	movw	r30, r16
    1e3a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e3c:	8f 3f       	cpi	r24, 0xFF	; 255
    1e3e:	09 f4       	brne	.+2      	; 0x1e42 <xQueueGenericSend+0xa6>
    1e40:	15 8e       	std	Z+29, r1	; 0x1d
    1e42:	f8 01       	movw	r30, r16
    1e44:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e46:	8f 3f       	cpi	r24, 0xFF	; 255
    1e48:	09 f4       	brne	.+2      	; 0x1e4c <xQueueGenericSend+0xb0>
    1e4a:	16 8e       	std	Z+30, r1	; 0x1e
    1e4c:	0f 90       	pop	r0
    1e4e:	0f be       	out	0x3f, r0	; 63
    1e50:	be 01       	movw	r22, r28
    1e52:	6c 5f       	subi	r22, 0xFC	; 252
    1e54:	7f 4f       	sbci	r23, 0xFF	; 255
    1e56:	ce 01       	movw	r24, r28
    1e58:	01 96       	adiw	r24, 0x01	; 1
    1e5a:	f5 d4       	rcall	.+2538   	; 0x2846 <xTaskCheckForTimeOut>
    1e5c:	81 11       	cpse	r24, r1
    1e5e:	19 c0       	rjmp	.+50     	; 0x1e92 <xQueueGenericSend+0xf6>
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	0f 92       	push	r0
    1e66:	f8 01       	movw	r30, r16
    1e68:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e6a:	0f 90       	pop	r0
    1e6c:	0f be       	out	0x3f, r0	; 63
    1e6e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e70:	98 13       	cpse	r25, r24
    1e72:	0b c0       	rjmp	.+22     	; 0x1e8a <xQueueGenericSend+0xee>
    1e74:	6c 81       	ldd	r22, Y+4	; 0x04
    1e76:	7d 81       	ldd	r23, Y+5	; 0x05
    1e78:	c7 01       	movw	r24, r14
    1e7a:	5d d4       	rcall	.+2234   	; 0x2736 <vTaskPlaceOnEventList>
    1e7c:	c8 01       	movw	r24, r16
    1e7e:	e4 de       	rcall	.-568    	; 0x1c48 <prvUnlockQueue>
    1e80:	55 d3       	rcall	.+1706   	; 0x252c <xTaskResumeAll>
    1e82:	81 11       	cpse	r24, r1
    1e84:	a4 cf       	rjmp	.-184    	; 0x1dce <xQueueGenericSend+0x32>
    1e86:	ad dd       	rcall	.-1190   	; 0x19e2 <vPortYield>
    1e88:	a2 cf       	rjmp	.-188    	; 0x1dce <xQueueGenericSend+0x32>
    1e8a:	c8 01       	movw	r24, r16
    1e8c:	dd de       	rcall	.-582    	; 0x1c48 <prvUnlockQueue>
    1e8e:	4e d3       	rcall	.+1692   	; 0x252c <xTaskResumeAll>
    1e90:	9e cf       	rjmp	.-196    	; 0x1dce <xQueueGenericSend+0x32>
    1e92:	c8 01       	movw	r24, r16
    1e94:	d9 de       	rcall	.-590    	; 0x1c48 <prvUnlockQueue>
    1e96:	4a d3       	rcall	.+1684   	; 0x252c <xTaskResumeAll>
    1e98:	80 e0       	ldi	r24, 0x00	; 0
    1e9a:	25 96       	adiw	r28, 0x05	; 5
    1e9c:	cd bf       	out	0x3d, r28	; 61
    1e9e:	de bf       	out	0x3e, r29	; 62
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	ff 90       	pop	r15
    1eaa:	ef 90       	pop	r14
    1eac:	df 90       	pop	r13
    1eae:	cf 90       	pop	r12
    1eb0:	bf 90       	pop	r11
    1eb2:	af 90       	pop	r10
    1eb4:	08 95       	ret

00001eb6 <xQueueGenericSendFromISR>:
    1eb6:	0f 93       	push	r16
    1eb8:	1f 93       	push	r17
    1eba:	cf 93       	push	r28
    1ebc:	df 93       	push	r29
    1ebe:	fa 01       	movw	r30, r20
    1ec0:	dc 01       	movw	r26, r24
    1ec2:	5a 96       	adiw	r26, 0x1a	; 26
    1ec4:	5c 91       	ld	r21, X
    1ec6:	5a 97       	sbiw	r26, 0x1a	; 26
    1ec8:	5b 96       	adiw	r26, 0x1b	; 27
    1eca:	3c 91       	ld	r19, X
    1ecc:	53 17       	cp	r21, r19
    1ece:	10 f0       	brcs	.+4      	; 0x1ed4 <xQueueGenericSendFromISR+0x1e>
    1ed0:	22 30       	cpi	r18, 0x02	; 2
    1ed2:	d9 f4       	brne	.+54     	; 0x1f0a <xQueueGenericSendFromISR+0x54>
    1ed4:	42 2f       	mov	r20, r18
    1ed6:	8f 01       	movw	r16, r30
    1ed8:	ec 01       	movw	r28, r24
    1eda:	4f de       	rcall	.-866    	; 0x1b7a <prvCopyDataToQueue>
    1edc:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1ede:	8f 3f       	cpi	r24, 0xFF	; 255
    1ee0:	79 f4       	brne	.+30     	; 0x1f00 <xQueueGenericSendFromISR+0x4a>
    1ee2:	89 89       	ldd	r24, Y+17	; 0x11
    1ee4:	88 23       	and	r24, r24
    1ee6:	99 f0       	breq	.+38     	; 0x1f0e <xQueueGenericSendFromISR+0x58>
    1ee8:	ce 01       	movw	r24, r28
    1eea:	41 96       	adiw	r24, 0x11	; 17
    1eec:	5b d4       	rcall	.+2230   	; 0x27a4 <xTaskRemoveFromEventList>
    1eee:	88 23       	and	r24, r24
    1ef0:	81 f0       	breq	.+32     	; 0x1f12 <xQueueGenericSendFromISR+0x5c>
    1ef2:	01 15       	cp	r16, r1
    1ef4:	11 05       	cpc	r17, r1
    1ef6:	79 f0       	breq	.+30     	; 0x1f16 <xQueueGenericSendFromISR+0x60>
    1ef8:	81 e0       	ldi	r24, 0x01	; 1
    1efa:	f8 01       	movw	r30, r16
    1efc:	80 83       	st	Z, r24
    1efe:	0c c0       	rjmp	.+24     	; 0x1f18 <xQueueGenericSendFromISR+0x62>
    1f00:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1f02:	8f 5f       	subi	r24, 0xFF	; 255
    1f04:	8e 8f       	std	Y+30, r24	; 0x1e
    1f06:	81 e0       	ldi	r24, 0x01	; 1
    1f08:	07 c0       	rjmp	.+14     	; 0x1f18 <xQueueGenericSendFromISR+0x62>
    1f0a:	80 e0       	ldi	r24, 0x00	; 0
    1f0c:	05 c0       	rjmp	.+10     	; 0x1f18 <xQueueGenericSendFromISR+0x62>
    1f0e:	81 e0       	ldi	r24, 0x01	; 1
    1f10:	03 c0       	rjmp	.+6      	; 0x1f18 <xQueueGenericSendFromISR+0x62>
    1f12:	81 e0       	ldi	r24, 0x01	; 1
    1f14:	01 c0       	rjmp	.+2      	; 0x1f18 <xQueueGenericSendFromISR+0x62>
    1f16:	81 e0       	ldi	r24, 0x01	; 1
    1f18:	df 91       	pop	r29
    1f1a:	cf 91       	pop	r28
    1f1c:	1f 91       	pop	r17
    1f1e:	0f 91       	pop	r16
    1f20:	08 95       	ret

00001f22 <xQueueGenericReceive>:
    1f22:	af 92       	push	r10
    1f24:	bf 92       	push	r11
    1f26:	cf 92       	push	r12
    1f28:	df 92       	push	r13
    1f2a:	ef 92       	push	r14
    1f2c:	ff 92       	push	r15
    1f2e:	0f 93       	push	r16
    1f30:	1f 93       	push	r17
    1f32:	cf 93       	push	r28
    1f34:	df 93       	push	r29
    1f36:	cd b7       	in	r28, 0x3d	; 61
    1f38:	de b7       	in	r29, 0x3e	; 62
    1f3a:	25 97       	sbiw	r28, 0x05	; 5
    1f3c:	cd bf       	out	0x3d, r28	; 61
    1f3e:	de bf       	out	0x3e, r29	; 62
    1f40:	8c 01       	movw	r16, r24
    1f42:	6b 01       	movw	r12, r22
    1f44:	4c 83       	std	Y+4, r20	; 0x04
    1f46:	5d 83       	std	Y+5, r21	; 0x05
    1f48:	a2 2e       	mov	r10, r18
    1f4a:	b1 2c       	mov	r11, r1
    1f4c:	7c 01       	movw	r14, r24
    1f4e:	81 e1       	ldi	r24, 0x11	; 17
    1f50:	e8 0e       	add	r14, r24
    1f52:	f1 1c       	adc	r15, r1
    1f54:	0f b6       	in	r0, 0x3f	; 63
    1f56:	f8 94       	cli
    1f58:	0f 92       	push	r0
    1f5a:	f8 01       	movw	r30, r16
    1f5c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f5e:	99 23       	and	r25, r25
    1f60:	21 f1       	breq	.+72     	; 0x1faa <xQueueGenericReceive+0x88>
    1f62:	e6 80       	ldd	r14, Z+6	; 0x06
    1f64:	f7 80       	ldd	r15, Z+7	; 0x07
    1f66:	b6 01       	movw	r22, r12
    1f68:	c8 01       	movw	r24, r16
    1f6a:	54 de       	rcall	.-856    	; 0x1c14 <prvCopyDataFromQueue>
    1f6c:	a1 10       	cpse	r10, r1
    1f6e:	0e c0       	rjmp	.+28     	; 0x1f8c <xQueueGenericReceive+0x6a>
    1f70:	f8 01       	movw	r30, r16
    1f72:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f74:	81 50       	subi	r24, 0x01	; 1
    1f76:	82 8f       	std	Z+26, r24	; 0x1a
    1f78:	80 85       	ldd	r24, Z+8	; 0x08
    1f7a:	88 23       	and	r24, r24
    1f7c:	91 f0       	breq	.+36     	; 0x1fa2 <xQueueGenericReceive+0x80>
    1f7e:	c8 01       	movw	r24, r16
    1f80:	08 96       	adiw	r24, 0x08	; 8
    1f82:	10 d4       	rcall	.+2080   	; 0x27a4 <xTaskRemoveFromEventList>
    1f84:	81 30       	cpi	r24, 0x01	; 1
    1f86:	69 f4       	brne	.+26     	; 0x1fa2 <xQueueGenericReceive+0x80>
    1f88:	2c dd       	rcall	.-1448   	; 0x19e2 <vPortYield>
    1f8a:	0b c0       	rjmp	.+22     	; 0x1fa2 <xQueueGenericReceive+0x80>
    1f8c:	f8 01       	movw	r30, r16
    1f8e:	e6 82       	std	Z+6, r14	; 0x06
    1f90:	f7 82       	std	Z+7, r15	; 0x07
    1f92:	81 89       	ldd	r24, Z+17	; 0x11
    1f94:	88 23       	and	r24, r24
    1f96:	29 f0       	breq	.+10     	; 0x1fa2 <xQueueGenericReceive+0x80>
    1f98:	c8 01       	movw	r24, r16
    1f9a:	41 96       	adiw	r24, 0x11	; 17
    1f9c:	03 d4       	rcall	.+2054   	; 0x27a4 <xTaskRemoveFromEventList>
    1f9e:	81 11       	cpse	r24, r1
    1fa0:	20 dd       	rcall	.-1472   	; 0x19e2 <vPortYield>
    1fa2:	0f 90       	pop	r0
    1fa4:	0f be       	out	0x3f, r0	; 63
    1fa6:	81 e0       	ldi	r24, 0x01	; 1
    1fa8:	45 c0       	rjmp	.+138    	; 0x2034 <xQueueGenericReceive+0x112>
    1faa:	4c 81       	ldd	r20, Y+4	; 0x04
    1fac:	5d 81       	ldd	r21, Y+5	; 0x05
    1fae:	45 2b       	or	r20, r21
    1fb0:	21 f4       	brne	.+8      	; 0x1fba <xQueueGenericReceive+0x98>
    1fb2:	0f 90       	pop	r0
    1fb4:	0f be       	out	0x3f, r0	; 63
    1fb6:	80 e0       	ldi	r24, 0x00	; 0
    1fb8:	3d c0       	rjmp	.+122    	; 0x2034 <xQueueGenericReceive+0x112>
    1fba:	b1 10       	cpse	r11, r1
    1fbc:	05 c0       	rjmp	.+10     	; 0x1fc8 <xQueueGenericReceive+0xa6>
    1fbe:	ce 01       	movw	r24, r28
    1fc0:	01 96       	adiw	r24, 0x01	; 1
    1fc2:	36 d4       	rcall	.+2156   	; 0x2830 <vTaskSetTimeOutState>
    1fc4:	bb 24       	eor	r11, r11
    1fc6:	b3 94       	inc	r11
    1fc8:	0f 90       	pop	r0
    1fca:	0f be       	out	0x3f, r0	; 63
    1fcc:	cc d1       	rcall	.+920    	; 0x2366 <vTaskSuspendAll>
    1fce:	0f b6       	in	r0, 0x3f	; 63
    1fd0:	f8 94       	cli
    1fd2:	0f 92       	push	r0
    1fd4:	f8 01       	movw	r30, r16
    1fd6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fd8:	8f 3f       	cpi	r24, 0xFF	; 255
    1fda:	09 f4       	brne	.+2      	; 0x1fde <xQueueGenericReceive+0xbc>
    1fdc:	15 8e       	std	Z+29, r1	; 0x1d
    1fde:	f8 01       	movw	r30, r16
    1fe0:	96 8d       	ldd	r25, Z+30	; 0x1e
    1fe2:	9f 3f       	cpi	r25, 0xFF	; 255
    1fe4:	09 f4       	brne	.+2      	; 0x1fe8 <xQueueGenericReceive+0xc6>
    1fe6:	16 8e       	std	Z+30, r1	; 0x1e
    1fe8:	0f 90       	pop	r0
    1fea:	0f be       	out	0x3f, r0	; 63
    1fec:	be 01       	movw	r22, r28
    1fee:	6c 5f       	subi	r22, 0xFC	; 252
    1ff0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ff2:	ce 01       	movw	r24, r28
    1ff4:	01 96       	adiw	r24, 0x01	; 1
    1ff6:	27 d4       	rcall	.+2126   	; 0x2846 <xTaskCheckForTimeOut>
    1ff8:	81 11       	cpse	r24, r1
    1ffa:	18 c0       	rjmp	.+48     	; 0x202c <xQueueGenericReceive+0x10a>
    1ffc:	0f b6       	in	r0, 0x3f	; 63
    1ffe:	f8 94       	cli
    2000:	0f 92       	push	r0
    2002:	f8 01       	movw	r30, r16
    2004:	82 8d       	ldd	r24, Z+26	; 0x1a
    2006:	0f 90       	pop	r0
    2008:	0f be       	out	0x3f, r0	; 63
    200a:	81 11       	cpse	r24, r1
    200c:	0b c0       	rjmp	.+22     	; 0x2024 <xQueueGenericReceive+0x102>
    200e:	6c 81       	ldd	r22, Y+4	; 0x04
    2010:	7d 81       	ldd	r23, Y+5	; 0x05
    2012:	c7 01       	movw	r24, r14
    2014:	90 d3       	rcall	.+1824   	; 0x2736 <vTaskPlaceOnEventList>
    2016:	c8 01       	movw	r24, r16
    2018:	17 de       	rcall	.-978    	; 0x1c48 <prvUnlockQueue>
    201a:	88 d2       	rcall	.+1296   	; 0x252c <xTaskResumeAll>
    201c:	81 11       	cpse	r24, r1
    201e:	9a cf       	rjmp	.-204    	; 0x1f54 <xQueueGenericReceive+0x32>
    2020:	e0 dc       	rcall	.-1600   	; 0x19e2 <vPortYield>
    2022:	98 cf       	rjmp	.-208    	; 0x1f54 <xQueueGenericReceive+0x32>
    2024:	c8 01       	movw	r24, r16
    2026:	10 de       	rcall	.-992    	; 0x1c48 <prvUnlockQueue>
    2028:	81 d2       	rcall	.+1282   	; 0x252c <xTaskResumeAll>
    202a:	94 cf       	rjmp	.-216    	; 0x1f54 <xQueueGenericReceive+0x32>
    202c:	c8 01       	movw	r24, r16
    202e:	0c de       	rcall	.-1000   	; 0x1c48 <prvUnlockQueue>
    2030:	7d d2       	rcall	.+1274   	; 0x252c <xTaskResumeAll>
    2032:	80 e0       	ldi	r24, 0x00	; 0
    2034:	25 96       	adiw	r28, 0x05	; 5
    2036:	cd bf       	out	0x3d, r28	; 61
    2038:	de bf       	out	0x3e, r29	; 62
    203a:	df 91       	pop	r29
    203c:	cf 91       	pop	r28
    203e:	1f 91       	pop	r17
    2040:	0f 91       	pop	r16
    2042:	ff 90       	pop	r15
    2044:	ef 90       	pop	r14
    2046:	df 90       	pop	r13
    2048:	cf 90       	pop	r12
    204a:	bf 90       	pop	r11
    204c:	af 90       	pop	r10
    204e:	08 95       	ret

00002050 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    2050:	cf 93       	push	r28
    2052:	df 93       	push	r29
    2054:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2056:	0f b6       	in	r0, 0x3f	; 63
    2058:	f8 94       	cli
    205a:	0f 92       	push	r0
    205c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    205e:	8f 3f       	cpi	r24, 0xFF	; 255
    2060:	09 f4       	brne	.+2      	; 0x2064 <vQueueWaitForMessageRestricted+0x14>
    2062:	1d 8e       	std	Y+29, r1	; 0x1d
    2064:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2066:	8f 3f       	cpi	r24, 0xFF	; 255
    2068:	09 f4       	brne	.+2      	; 0x206c <vQueueWaitForMessageRestricted+0x1c>
    206a:	1e 8e       	std	Y+30, r1	; 0x1e
    206c:	0f 90       	pop	r0
    206e:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2070:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2072:	81 11       	cpse	r24, r1
    2074:	03 c0       	rjmp	.+6      	; 0x207c <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    2076:	ce 01       	movw	r24, r28
    2078:	41 96       	adiw	r24, 0x11	; 17
    207a:	78 d3       	rcall	.+1776   	; 0x276c <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    207c:	ce 01       	movw	r24, r28
    207e:	e4 dd       	rcall	.-1080   	; 0x1c48 <prvUnlockQueue>
	}
    2080:	df 91       	pop	r29
    2082:	cf 91       	pop	r28
    2084:	08 95       	ret

00002086 <prvIdleTask>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    2086:	cf e7       	ldi	r28, 0x7F	; 127
    2088:	d2 e2       	ldi	r29, 0x22	; 34
    208a:	88 81       	ld	r24, Y
    208c:	82 30       	cpi	r24, 0x02	; 2
    208e:	f0 f3       	brcs	.-4      	; 0x208c <prvIdleTask+0x6>
    2090:	a8 dc       	rcall	.-1712   	; 0x19e2 <vPortYield>
    2092:	fb cf       	rjmp	.-10     	; 0x208a <prvIdleTask+0x4>

00002094 <prvAddCurrentTaskToDelayedList>:
    2094:	cf 93       	push	r28
    2096:	df 93       	push	r29
    2098:	ec 01       	movw	r28, r24
    209a:	e0 91 ac 22 	lds	r30, 0x22AC
    209e:	f0 91 ad 22 	lds	r31, 0x22AD
    20a2:	82 83       	std	Z+2, r24	; 0x02
    20a4:	93 83       	std	Z+3, r25	; 0x03
    20a6:	80 91 5d 22 	lds	r24, 0x225D
    20aa:	90 91 5e 22 	lds	r25, 0x225E
    20ae:	c8 17       	cp	r28, r24
    20b0:	d9 07       	cpc	r29, r25
    20b2:	60 f4       	brcc	.+24     	; 0x20cc <prvAddCurrentTaskToDelayedList+0x38>
    20b4:	60 91 ac 22 	lds	r22, 0x22AC
    20b8:	70 91 ad 22 	lds	r23, 0x22AD
    20bc:	80 91 69 22 	lds	r24, 0x2269
    20c0:	90 91 6a 22 	lds	r25, 0x226A
    20c4:	6e 5f       	subi	r22, 0xFE	; 254
    20c6:	7f 4f       	sbci	r23, 0xFF	; 255
    20c8:	79 db       	rcall	.-2318   	; 0x17bc <vListInsert>
    20ca:	16 c0       	rjmp	.+44     	; 0x20f8 <prvAddCurrentTaskToDelayedList+0x64>
    20cc:	60 91 ac 22 	lds	r22, 0x22AC
    20d0:	70 91 ad 22 	lds	r23, 0x22AD
    20d4:	80 91 6b 22 	lds	r24, 0x226B
    20d8:	90 91 6c 22 	lds	r25, 0x226C
    20dc:	6e 5f       	subi	r22, 0xFE	; 254
    20de:	7f 4f       	sbci	r23, 0xFF	; 255
    20e0:	6d db       	rcall	.-2342   	; 0x17bc <vListInsert>
    20e2:	80 91 55 22 	lds	r24, 0x2255
    20e6:	90 91 56 22 	lds	r25, 0x2256
    20ea:	c8 17       	cp	r28, r24
    20ec:	d9 07       	cpc	r29, r25
    20ee:	20 f4       	brcc	.+8      	; 0x20f8 <prvAddCurrentTaskToDelayedList+0x64>
    20f0:	c0 93 55 22 	sts	0x2255, r28
    20f4:	d0 93 56 22 	sts	0x2256, r29
    20f8:	df 91       	pop	r29
    20fa:	cf 91       	pop	r28
    20fc:	08 95       	ret

000020fe <xTaskGenericCreate>:
    20fe:	4f 92       	push	r4
    2100:	5f 92       	push	r5
    2102:	6f 92       	push	r6
    2104:	7f 92       	push	r7
    2106:	8f 92       	push	r8
    2108:	9f 92       	push	r9
    210a:	af 92       	push	r10
    210c:	bf 92       	push	r11
    210e:	cf 92       	push	r12
    2110:	df 92       	push	r13
    2112:	ef 92       	push	r14
    2114:	ff 92       	push	r15
    2116:	0f 93       	push	r16
    2118:	1f 93       	push	r17
    211a:	cf 93       	push	r28
    211c:	df 93       	push	r29
    211e:	4c 01       	movw	r8, r24
    2120:	eb 01       	movw	r28, r22
    2122:	5a 01       	movw	r10, r20
    2124:	29 01       	movw	r4, r18
    2126:	c1 14       	cp	r12, r1
    2128:	d1 04       	cpc	r13, r1
    212a:	31 f4       	brne	.+12     	; 0x2138 <xTaskGenericCreate+0x3a>
    212c:	ca 01       	movw	r24, r20
    212e:	0b dd       	rcall	.-1514   	; 0x1b46 <pvPortMalloc>
    2130:	6c 01       	movw	r12, r24
    2132:	89 2b       	or	r24, r25
    2134:	09 f4       	brne	.+2      	; 0x2138 <xTaskGenericCreate+0x3a>
    2136:	d2 c0       	rjmp	.+420    	; 0x22dc <xTaskGenericCreate+0x1de>
    2138:	86 e2       	ldi	r24, 0x26	; 38
    213a:	90 e0       	ldi	r25, 0x00	; 0
    213c:	04 dd       	rcall	.-1528   	; 0x1b46 <pvPortMalloc>
    213e:	3c 01       	movw	r6, r24
    2140:	00 97       	sbiw	r24, 0x00	; 0
    2142:	79 f0       	breq	.+30     	; 0x2162 <xTaskGenericCreate+0x64>
    2144:	fc 01       	movw	r30, r24
    2146:	c7 8a       	std	Z+23, r12	; 0x17
    2148:	d0 8e       	std	Z+24, r13	; 0x18
    214a:	f1 e0       	ldi	r31, 0x01	; 1
    214c:	af 1a       	sub	r10, r31
    214e:	b1 08       	sbc	r11, r1
    2150:	ca 0c       	add	r12, r10
    2152:	db 1c       	adc	r13, r11
    2154:	88 81       	ld	r24, Y
    2156:	f3 01       	movw	r30, r6
    2158:	81 8f       	std	Z+25, r24	; 0x19
    215a:	88 81       	ld	r24, Y
    215c:	81 11       	cpse	r24, r1
    215e:	04 c0       	rjmp	.+8      	; 0x2168 <xTaskGenericCreate+0x6a>
    2160:	13 c0       	rjmp	.+38     	; 0x2188 <xTaskGenericCreate+0x8a>
    2162:	c6 01       	movw	r24, r12
    2164:	fd dc       	rcall	.-1542   	; 0x1b60 <vPortFree>
    2166:	ba c0       	rjmp	.+372    	; 0x22dc <xTaskGenericCreate+0x1de>
    2168:	d3 01       	movw	r26, r6
    216a:	5a 96       	adiw	r26, 0x1a	; 26
    216c:	fe 01       	movw	r30, r28
    216e:	31 96       	adiw	r30, 0x01	; 1
    2170:	9e 01       	movw	r18, r28
    2172:	28 5f       	subi	r18, 0xF8	; 248
    2174:	3f 4f       	sbci	r19, 0xFF	; 255
    2176:	ef 01       	movw	r28, r30
    2178:	81 91       	ld	r24, Z+
    217a:	8d 93       	st	X+, r24
    217c:	88 81       	ld	r24, Y
    217e:	88 23       	and	r24, r24
    2180:	19 f0       	breq	.+6      	; 0x2188 <xTaskGenericCreate+0x8a>
    2182:	e2 17       	cp	r30, r18
    2184:	f3 07       	cpc	r31, r19
    2186:	b9 f7       	brne	.-18     	; 0x2176 <xTaskGenericCreate+0x78>
    2188:	f3 01       	movw	r30, r6
    218a:	10 a2       	std	Z+32, r1	; 0x20
    218c:	10 2f       	mov	r17, r16
    218e:	05 30       	cpi	r16, 0x05	; 5
    2190:	08 f0       	brcs	.+2      	; 0x2194 <xTaskGenericCreate+0x96>
    2192:	14 e0       	ldi	r17, 0x04	; 4
    2194:	f3 01       	movw	r30, r6
    2196:	16 8b       	std	Z+22, r17	; 0x16
    2198:	e3 01       	movw	r28, r6
    219a:	22 96       	adiw	r28, 0x02	; 2
    219c:	ce 01       	movw	r24, r28
    219e:	e9 da       	rcall	.-2606   	; 0x1772 <vListInitialiseItem>
    21a0:	c3 01       	movw	r24, r6
    21a2:	0c 96       	adiw	r24, 0x0c	; 12
    21a4:	e6 da       	rcall	.-2612   	; 0x1772 <vListInitialiseItem>
    21a6:	f3 01       	movw	r30, r6
    21a8:	60 86       	std	Z+8, r6	; 0x08
    21aa:	71 86       	std	Z+9, r7	; 0x09
    21ac:	85 e0       	ldi	r24, 0x05	; 5
    21ae:	90 e0       	ldi	r25, 0x00	; 0
    21b0:	81 1b       	sub	r24, r17
    21b2:	91 09       	sbc	r25, r1
    21b4:	84 87       	std	Z+12, r24	; 0x0c
    21b6:	95 87       	std	Z+13, r25	; 0x0d
    21b8:	62 8a       	std	Z+18, r6	; 0x12
    21ba:	73 8a       	std	Z+19, r7	; 0x13
    21bc:	11 a2       	std	Z+33, r1	; 0x21
    21be:	12 a2       	std	Z+34, r1	; 0x22
    21c0:	13 a2       	std	Z+35, r1	; 0x23
    21c2:	14 a2       	std	Z+36, r1	; 0x24
    21c4:	15 a2       	std	Z+37, r1	; 0x25
    21c6:	a2 01       	movw	r20, r4
    21c8:	b4 01       	movw	r22, r8
    21ca:	c6 01       	movw	r24, r12
    21cc:	4e db       	rcall	.-2404   	; 0x186a <pxPortInitialiseStack>
    21ce:	f3 01       	movw	r30, r6
    21d0:	80 83       	st	Z, r24
    21d2:	91 83       	std	Z+1, r25	; 0x01
    21d4:	e1 14       	cp	r14, r1
    21d6:	f1 04       	cpc	r15, r1
    21d8:	19 f0       	breq	.+6      	; 0x21e0 <xTaskGenericCreate+0xe2>
    21da:	f7 01       	movw	r30, r14
    21dc:	60 82       	st	Z, r6
    21de:	71 82       	std	Z+1, r7	; 0x01
    21e0:	0f b6       	in	r0, 0x3f	; 63
    21e2:	f8 94       	cli
    21e4:	0f 92       	push	r0
    21e6:	80 91 5f 22 	lds	r24, 0x225F
    21ea:	8f 5f       	subi	r24, 0xFF	; 255
    21ec:	80 93 5f 22 	sts	0x225F, r24
    21f0:	80 91 ac 22 	lds	r24, 0x22AC
    21f4:	90 91 ad 22 	lds	r25, 0x22AD
    21f8:	89 2b       	or	r24, r25
    21fa:	91 f5       	brne	.+100    	; 0x2260 <xTaskGenericCreate+0x162>
    21fc:	60 92 ac 22 	sts	0x22AC, r6
    2200:	70 92 ad 22 	sts	0x22AD, r7
    2204:	80 91 5f 22 	lds	r24, 0x225F
    2208:	81 30       	cpi	r24, 0x01	; 1
    220a:	c9 f5       	brne	.+114    	; 0x227e <xTaskGenericCreate+0x180>
    220c:	0f 2e       	mov	r0, r31
    220e:	ff e7       	ldi	r31, 0x7F	; 127
    2210:	ef 2e       	mov	r14, r31
    2212:	f2 e2       	ldi	r31, 0x22	; 34
    2214:	ff 2e       	mov	r15, r31
    2216:	f0 2d       	mov	r31, r0
    2218:	0f 2e       	mov	r0, r31
    221a:	fc ea       	ldi	r31, 0xAC	; 172
    221c:	cf 2e       	mov	r12, r31
    221e:	f2 e2       	ldi	r31, 0x22	; 34
    2220:	df 2e       	mov	r13, r31
    2222:	f0 2d       	mov	r31, r0
    2224:	c7 01       	movw	r24, r14
    2226:	97 da       	rcall	.-2770   	; 0x1756 <vListInitialise>
    2228:	f9 e0       	ldi	r31, 0x09	; 9
    222a:	ef 0e       	add	r14, r31
    222c:	f1 1c       	adc	r15, r1
    222e:	ec 14       	cp	r14, r12
    2230:	fd 04       	cpc	r15, r13
    2232:	c1 f7       	brne	.-16     	; 0x2224 <xTaskGenericCreate+0x126>
    2234:	86 e7       	ldi	r24, 0x76	; 118
    2236:	92 e2       	ldi	r25, 0x22	; 34
    2238:	8e da       	rcall	.-2788   	; 0x1756 <vListInitialise>
    223a:	8d e6       	ldi	r24, 0x6D	; 109
    223c:	92 e2       	ldi	r25, 0x22	; 34
    223e:	8b da       	rcall	.-2794   	; 0x1756 <vListInitialise>
    2240:	80 e6       	ldi	r24, 0x60	; 96
    2242:	92 e2       	ldi	r25, 0x22	; 34
    2244:	88 da       	rcall	.-2800   	; 0x1756 <vListInitialise>
    2246:	86 e7       	ldi	r24, 0x76	; 118
    2248:	92 e2       	ldi	r25, 0x22	; 34
    224a:	80 93 6b 22 	sts	0x226B, r24
    224e:	90 93 6c 22 	sts	0x226C, r25
    2252:	8d e6       	ldi	r24, 0x6D	; 109
    2254:	92 e2       	ldi	r25, 0x22	; 34
    2256:	80 93 69 22 	sts	0x2269, r24
    225a:	90 93 6a 22 	sts	0x226A, r25
    225e:	0f c0       	rjmp	.+30     	; 0x227e <xTaskGenericCreate+0x180>
    2260:	80 91 5b 22 	lds	r24, 0x225B
    2264:	81 11       	cpse	r24, r1
    2266:	0b c0       	rjmp	.+22     	; 0x227e <xTaskGenericCreate+0x180>
    2268:	e0 91 ac 22 	lds	r30, 0x22AC
    226c:	f0 91 ad 22 	lds	r31, 0x22AD
    2270:	86 89       	ldd	r24, Z+22	; 0x16
    2272:	08 17       	cp	r16, r24
    2274:	20 f0       	brcs	.+8      	; 0x227e <xTaskGenericCreate+0x180>
    2276:	60 92 ac 22 	sts	0x22AC, r6
    227a:	70 92 ad 22 	sts	0x22AD, r7
    227e:	80 91 57 22 	lds	r24, 0x2257
    2282:	8f 5f       	subi	r24, 0xFF	; 255
    2284:	80 93 57 22 	sts	0x2257, r24
    2288:	f3 01       	movw	r30, r6
    228a:	86 89       	ldd	r24, Z+22	; 0x16
    228c:	90 91 5c 22 	lds	r25, 0x225C
    2290:	98 17       	cp	r25, r24
    2292:	10 f4       	brcc	.+4      	; 0x2298 <xTaskGenericCreate+0x19a>
    2294:	80 93 5c 22 	sts	0x225C, r24
    2298:	90 e0       	ldi	r25, 0x00	; 0
    229a:	9c 01       	movw	r18, r24
    229c:	22 0f       	add	r18, r18
    229e:	33 1f       	adc	r19, r19
    22a0:	22 0f       	add	r18, r18
    22a2:	33 1f       	adc	r19, r19
    22a4:	22 0f       	add	r18, r18
    22a6:	33 1f       	adc	r19, r19
    22a8:	82 0f       	add	r24, r18
    22aa:	93 1f       	adc	r25, r19
    22ac:	be 01       	movw	r22, r28
    22ae:	81 58       	subi	r24, 0x81	; 129
    22b0:	9d 4d       	sbci	r25, 0xDD	; 221
    22b2:	63 da       	rcall	.-2874   	; 0x177a <vListInsertEnd>
    22b4:	0f 90       	pop	r0
    22b6:	0f be       	out	0x3f, r0	; 63
    22b8:	80 91 5b 22 	lds	r24, 0x225B
    22bc:	88 23       	and	r24, r24
    22be:	51 f0       	breq	.+20     	; 0x22d4 <xTaskGenericCreate+0x1d6>
    22c0:	e0 91 ac 22 	lds	r30, 0x22AC
    22c4:	f0 91 ad 22 	lds	r31, 0x22AD
    22c8:	86 89       	ldd	r24, Z+22	; 0x16
    22ca:	80 17       	cp	r24, r16
    22cc:	28 f4       	brcc	.+10     	; 0x22d8 <xTaskGenericCreate+0x1da>
    22ce:	89 db       	rcall	.-2286   	; 0x19e2 <vPortYield>
    22d0:	81 e0       	ldi	r24, 0x01	; 1
    22d2:	05 c0       	rjmp	.+10     	; 0x22de <xTaskGenericCreate+0x1e0>
    22d4:	81 e0       	ldi	r24, 0x01	; 1
    22d6:	03 c0       	rjmp	.+6      	; 0x22de <xTaskGenericCreate+0x1e0>
    22d8:	81 e0       	ldi	r24, 0x01	; 1
    22da:	01 c0       	rjmp	.+2      	; 0x22de <xTaskGenericCreate+0x1e0>
    22dc:	8f ef       	ldi	r24, 0xFF	; 255
    22de:	df 91       	pop	r29
    22e0:	cf 91       	pop	r28
    22e2:	1f 91       	pop	r17
    22e4:	0f 91       	pop	r16
    22e6:	ff 90       	pop	r15
    22e8:	ef 90       	pop	r14
    22ea:	df 90       	pop	r13
    22ec:	cf 90       	pop	r12
    22ee:	bf 90       	pop	r11
    22f0:	af 90       	pop	r10
    22f2:	9f 90       	pop	r9
    22f4:	8f 90       	pop	r8
    22f6:	7f 90       	pop	r7
    22f8:	6f 90       	pop	r6
    22fa:	5f 90       	pop	r5
    22fc:	4f 90       	pop	r4
    22fe:	08 95       	ret

00002300 <vTaskStartScheduler>:
    2300:	af 92       	push	r10
    2302:	bf 92       	push	r11
    2304:	cf 92       	push	r12
    2306:	df 92       	push	r13
    2308:	ef 92       	push	r14
    230a:	ff 92       	push	r15
    230c:	0f 93       	push	r16
    230e:	a1 2c       	mov	r10, r1
    2310:	b1 2c       	mov	r11, r1
    2312:	c1 2c       	mov	r12, r1
    2314:	d1 2c       	mov	r13, r1
    2316:	e1 2c       	mov	r14, r1
    2318:	f1 2c       	mov	r15, r1
    231a:	00 e0       	ldi	r16, 0x00	; 0
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	30 e0       	ldi	r19, 0x00	; 0
    2320:	45 e5       	ldi	r20, 0x55	; 85
    2322:	50 e0       	ldi	r21, 0x00	; 0
    2324:	6d e0       	ldi	r22, 0x0D	; 13
    2326:	70 e2       	ldi	r23, 0x20	; 32
    2328:	83 e4       	ldi	r24, 0x43	; 67
    232a:	90 e1       	ldi	r25, 0x10	; 16
    232c:	e8 de       	rcall	.-560    	; 0x20fe <xTaskGenericCreate>
    232e:	81 30       	cpi	r24, 0x01	; 1
    2330:	91 f4       	brne	.+36     	; 0x2356 <vTaskStartScheduler+0x56>
    2332:	23 d3       	rcall	.+1606   	; 0x297a <xTimerCreateTimerTask>
    2334:	81 30       	cpi	r24, 0x01	; 1
    2336:	79 f4       	brne	.+30     	; 0x2356 <vTaskStartScheduler+0x56>
    2338:	f8 94       	cli
    233a:	8f ef       	ldi	r24, 0xFF	; 255
    233c:	9f ef       	ldi	r25, 0xFF	; 255
    233e:	80 93 55 22 	sts	0x2255, r24
    2342:	90 93 56 22 	sts	0x2256, r25
    2346:	81 e0       	ldi	r24, 0x01	; 1
    2348:	80 93 5b 22 	sts	0x225B, r24
    234c:	10 92 5d 22 	sts	0x225D, r1
    2350:	10 92 5e 22 	sts	0x225E, r1
    2354:	01 db       	rcall	.-2558   	; 0x1958 <xPortStartScheduler>
    2356:	0f 91       	pop	r16
    2358:	ff 90       	pop	r15
    235a:	ef 90       	pop	r14
    235c:	df 90       	pop	r13
    235e:	cf 90       	pop	r12
    2360:	bf 90       	pop	r11
    2362:	af 90       	pop	r10
    2364:	08 95       	ret

00002366 <vTaskSuspendAll>:
    2366:	80 91 54 22 	lds	r24, 0x2254
    236a:	8f 5f       	subi	r24, 0xFF	; 255
    236c:	80 93 54 22 	sts	0x2254, r24
    2370:	08 95       	ret

00002372 <xTaskGetTickCount>:
    2372:	0f b6       	in	r0, 0x3f	; 63
    2374:	f8 94       	cli
    2376:	0f 92       	push	r0
    2378:	80 91 5d 22 	lds	r24, 0x225D
    237c:	90 91 5e 22 	lds	r25, 0x225E
    2380:	0f 90       	pop	r0
    2382:	0f be       	out	0x3f, r0	; 63
    2384:	08 95       	ret

00002386 <xTaskIncrementTick>:
    2386:	df 92       	push	r13
    2388:	ef 92       	push	r14
    238a:	ff 92       	push	r15
    238c:	0f 93       	push	r16
    238e:	1f 93       	push	r17
    2390:	cf 93       	push	r28
    2392:	df 93       	push	r29
    2394:	80 91 54 22 	lds	r24, 0x2254
    2398:	81 11       	cpse	r24, r1
    239a:	b3 c0       	rjmp	.+358    	; 0x2502 <xTaskIncrementTick+0x17c>
    239c:	80 91 5d 22 	lds	r24, 0x225D
    23a0:	90 91 5e 22 	lds	r25, 0x225E
    23a4:	01 96       	adiw	r24, 0x01	; 1
    23a6:	80 93 5d 22 	sts	0x225D, r24
    23aa:	90 93 5e 22 	sts	0x225E, r25
    23ae:	e0 90 5d 22 	lds	r14, 0x225D
    23b2:	f0 90 5e 22 	lds	r15, 0x225E
    23b6:	e1 14       	cp	r14, r1
    23b8:	f1 04       	cpc	r15, r1
    23ba:	99 f5       	brne	.+102    	; 0x2422 <xTaskIncrementTick+0x9c>
    23bc:	80 91 6b 22 	lds	r24, 0x226B
    23c0:	90 91 6c 22 	lds	r25, 0x226C
    23c4:	20 91 69 22 	lds	r18, 0x2269
    23c8:	30 91 6a 22 	lds	r19, 0x226A
    23cc:	20 93 6b 22 	sts	0x226B, r18
    23d0:	30 93 6c 22 	sts	0x226C, r19
    23d4:	80 93 69 22 	sts	0x2269, r24
    23d8:	90 93 6a 22 	sts	0x226A, r25
    23dc:	80 91 58 22 	lds	r24, 0x2258
    23e0:	8f 5f       	subi	r24, 0xFF	; 255
    23e2:	80 93 58 22 	sts	0x2258, r24
    23e6:	e0 91 6b 22 	lds	r30, 0x226B
    23ea:	f0 91 6c 22 	lds	r31, 0x226C
    23ee:	80 81       	ld	r24, Z
    23f0:	81 11       	cpse	r24, r1
    23f2:	07 c0       	rjmp	.+14     	; 0x2402 <xTaskIncrementTick+0x7c>
    23f4:	8f ef       	ldi	r24, 0xFF	; 255
    23f6:	9f ef       	ldi	r25, 0xFF	; 255
    23f8:	80 93 55 22 	sts	0x2255, r24
    23fc:	90 93 56 22 	sts	0x2256, r25
    2400:	10 c0       	rjmp	.+32     	; 0x2422 <xTaskIncrementTick+0x9c>
    2402:	e0 91 6b 22 	lds	r30, 0x226B
    2406:	f0 91 6c 22 	lds	r31, 0x226C
    240a:	05 80       	ldd	r0, Z+5	; 0x05
    240c:	f6 81       	ldd	r31, Z+6	; 0x06
    240e:	e0 2d       	mov	r30, r0
    2410:	06 80       	ldd	r0, Z+6	; 0x06
    2412:	f7 81       	ldd	r31, Z+7	; 0x07
    2414:	e0 2d       	mov	r30, r0
    2416:	82 81       	ldd	r24, Z+2	; 0x02
    2418:	93 81       	ldd	r25, Z+3	; 0x03
    241a:	80 93 55 22 	sts	0x2255, r24
    241e:	90 93 56 22 	sts	0x2256, r25
    2422:	80 91 55 22 	lds	r24, 0x2255
    2426:	90 91 56 22 	lds	r25, 0x2256
    242a:	e8 16       	cp	r14, r24
    242c:	f9 06       	cpc	r15, r25
    242e:	10 f4       	brcc	.+4      	; 0x2434 <xTaskIncrementTick+0xae>
    2430:	d1 2c       	mov	r13, r1
    2432:	4f c0       	rjmp	.+158    	; 0x24d2 <xTaskIncrementTick+0x14c>
    2434:	d1 2c       	mov	r13, r1
    2436:	e0 91 6b 22 	lds	r30, 0x226B
    243a:	f0 91 6c 22 	lds	r31, 0x226C
    243e:	90 81       	ld	r25, Z
    2440:	91 11       	cpse	r25, r1
    2442:	07 c0       	rjmp	.+14     	; 0x2452 <xTaskIncrementTick+0xcc>
    2444:	8f ef       	ldi	r24, 0xFF	; 255
    2446:	9f ef       	ldi	r25, 0xFF	; 255
    2448:	80 93 55 22 	sts	0x2255, r24
    244c:	90 93 56 22 	sts	0x2256, r25
    2450:	40 c0       	rjmp	.+128    	; 0x24d2 <xTaskIncrementTick+0x14c>
    2452:	e0 91 6b 22 	lds	r30, 0x226B
    2456:	f0 91 6c 22 	lds	r31, 0x226C
    245a:	05 80       	ldd	r0, Z+5	; 0x05
    245c:	f6 81       	ldd	r31, Z+6	; 0x06
    245e:	e0 2d       	mov	r30, r0
    2460:	c6 81       	ldd	r28, Z+6	; 0x06
    2462:	d7 81       	ldd	r29, Z+7	; 0x07
    2464:	2a 81       	ldd	r18, Y+2	; 0x02
    2466:	3b 81       	ldd	r19, Y+3	; 0x03
    2468:	e2 16       	cp	r14, r18
    246a:	f3 06       	cpc	r15, r19
    246c:	28 f4       	brcc	.+10     	; 0x2478 <xTaskIncrementTick+0xf2>
    246e:	20 93 55 22 	sts	0x2255, r18
    2472:	30 93 56 22 	sts	0x2256, r19
    2476:	2d c0       	rjmp	.+90     	; 0x24d2 <xTaskIncrementTick+0x14c>
    2478:	8e 01       	movw	r16, r28
    247a:	0e 5f       	subi	r16, 0xFE	; 254
    247c:	1f 4f       	sbci	r17, 0xFF	; 255
    247e:	c8 01       	movw	r24, r16
    2480:	ce d9       	rcall	.-3172   	; 0x181e <uxListRemove>
    2482:	8c 89       	ldd	r24, Y+20	; 0x14
    2484:	9d 89       	ldd	r25, Y+21	; 0x15
    2486:	89 2b       	or	r24, r25
    2488:	19 f0       	breq	.+6      	; 0x2490 <xTaskIncrementTick+0x10a>
    248a:	ce 01       	movw	r24, r28
    248c:	0c 96       	adiw	r24, 0x0c	; 12
    248e:	c7 d9       	rcall	.-3186   	; 0x181e <uxListRemove>
    2490:	2e 89       	ldd	r18, Y+22	; 0x16
    2492:	80 91 5c 22 	lds	r24, 0x225C
    2496:	82 17       	cp	r24, r18
    2498:	10 f4       	brcc	.+4      	; 0x249e <xTaskIncrementTick+0x118>
    249a:	20 93 5c 22 	sts	0x225C, r18
    249e:	30 e0       	ldi	r19, 0x00	; 0
    24a0:	c9 01       	movw	r24, r18
    24a2:	88 0f       	add	r24, r24
    24a4:	99 1f       	adc	r25, r25
    24a6:	88 0f       	add	r24, r24
    24a8:	99 1f       	adc	r25, r25
    24aa:	88 0f       	add	r24, r24
    24ac:	99 1f       	adc	r25, r25
    24ae:	82 0f       	add	r24, r18
    24b0:	93 1f       	adc	r25, r19
    24b2:	b8 01       	movw	r22, r16
    24b4:	81 58       	subi	r24, 0x81	; 129
    24b6:	9d 4d       	sbci	r25, 0xDD	; 221
    24b8:	60 d9       	rcall	.-3392   	; 0x177a <vListInsertEnd>
    24ba:	e0 91 ac 22 	lds	r30, 0x22AC
    24be:	f0 91 ad 22 	lds	r31, 0x22AD
    24c2:	9e 89       	ldd	r25, Y+22	; 0x16
    24c4:	86 89       	ldd	r24, Z+22	; 0x16
    24c6:	98 17       	cp	r25, r24
    24c8:	08 f4       	brcc	.+2      	; 0x24cc <xTaskIncrementTick+0x146>
    24ca:	b5 cf       	rjmp	.-150    	; 0x2436 <xTaskIncrementTick+0xb0>
    24cc:	dd 24       	eor	r13, r13
    24ce:	d3 94       	inc	r13
    24d0:	b2 cf       	rjmp	.-156    	; 0x2436 <xTaskIncrementTick+0xb0>
    24d2:	e0 91 ac 22 	lds	r30, 0x22AC
    24d6:	f0 91 ad 22 	lds	r31, 0x22AD
    24da:	86 89       	ldd	r24, Z+22	; 0x16
    24dc:	90 e0       	ldi	r25, 0x00	; 0
    24de:	fc 01       	movw	r30, r24
    24e0:	ee 0f       	add	r30, r30
    24e2:	ff 1f       	adc	r31, r31
    24e4:	ee 0f       	add	r30, r30
    24e6:	ff 1f       	adc	r31, r31
    24e8:	ee 0f       	add	r30, r30
    24ea:	ff 1f       	adc	r31, r31
    24ec:	8e 0f       	add	r24, r30
    24ee:	9f 1f       	adc	r25, r31
    24f0:	fc 01       	movw	r30, r24
    24f2:	e1 58       	subi	r30, 0x81	; 129
    24f4:	fd 4d       	sbci	r31, 0xDD	; 221
    24f6:	80 81       	ld	r24, Z
    24f8:	82 30       	cpi	r24, 0x02	; 2
    24fa:	48 f0       	brcs	.+18     	; 0x250e <xTaskIncrementTick+0x188>
    24fc:	dd 24       	eor	r13, r13
    24fe:	d3 94       	inc	r13
    2500:	06 c0       	rjmp	.+12     	; 0x250e <xTaskIncrementTick+0x188>
    2502:	80 91 5a 22 	lds	r24, 0x225A
    2506:	8f 5f       	subi	r24, 0xFF	; 255
    2508:	80 93 5a 22 	sts	0x225A, r24
    250c:	d1 2c       	mov	r13, r1
    250e:	80 91 59 22 	lds	r24, 0x2259
    2512:	88 23       	and	r24, r24
    2514:	11 f0       	breq	.+4      	; 0x251a <xTaskIncrementTick+0x194>
    2516:	dd 24       	eor	r13, r13
    2518:	d3 94       	inc	r13
    251a:	8d 2d       	mov	r24, r13
    251c:	df 91       	pop	r29
    251e:	cf 91       	pop	r28
    2520:	1f 91       	pop	r17
    2522:	0f 91       	pop	r16
    2524:	ff 90       	pop	r15
    2526:	ef 90       	pop	r14
    2528:	df 90       	pop	r13
    252a:	08 95       	ret

0000252c <xTaskResumeAll>:
    252c:	df 92       	push	r13
    252e:	ef 92       	push	r14
    2530:	ff 92       	push	r15
    2532:	0f 93       	push	r16
    2534:	1f 93       	push	r17
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
    253a:	0f b6       	in	r0, 0x3f	; 63
    253c:	f8 94       	cli
    253e:	0f 92       	push	r0
    2540:	80 91 54 22 	lds	r24, 0x2254
    2544:	81 50       	subi	r24, 0x01	; 1
    2546:	80 93 54 22 	sts	0x2254, r24
    254a:	80 91 54 22 	lds	r24, 0x2254
    254e:	81 11       	cpse	r24, r1
    2550:	5d c0       	rjmp	.+186    	; 0x260c <xTaskResumeAll+0xe0>
    2552:	80 91 5f 22 	lds	r24, 0x225F
    2556:	81 11       	cpse	r24, r1
    2558:	30 c0       	rjmp	.+96     	; 0x25ba <xTaskResumeAll+0x8e>
    255a:	5b c0       	rjmp	.+182    	; 0x2612 <xTaskResumeAll+0xe6>
    255c:	d7 01       	movw	r26, r14
    255e:	15 96       	adiw	r26, 0x05	; 5
    2560:	ed 91       	ld	r30, X+
    2562:	fc 91       	ld	r31, X
    2564:	16 97       	sbiw	r26, 0x06	; 6
    2566:	c6 81       	ldd	r28, Z+6	; 0x06
    2568:	d7 81       	ldd	r29, Z+7	; 0x07
    256a:	ce 01       	movw	r24, r28
    256c:	0c 96       	adiw	r24, 0x0c	; 12
    256e:	57 d9       	rcall	.-3410   	; 0x181e <uxListRemove>
    2570:	8e 01       	movw	r16, r28
    2572:	0e 5f       	subi	r16, 0xFE	; 254
    2574:	1f 4f       	sbci	r17, 0xFF	; 255
    2576:	c8 01       	movw	r24, r16
    2578:	52 d9       	rcall	.-3420   	; 0x181e <uxListRemove>
    257a:	2e 89       	ldd	r18, Y+22	; 0x16
    257c:	80 91 5c 22 	lds	r24, 0x225C
    2580:	82 17       	cp	r24, r18
    2582:	10 f4       	brcc	.+4      	; 0x2588 <xTaskResumeAll+0x5c>
    2584:	20 93 5c 22 	sts	0x225C, r18
    2588:	30 e0       	ldi	r19, 0x00	; 0
    258a:	c9 01       	movw	r24, r18
    258c:	88 0f       	add	r24, r24
    258e:	99 1f       	adc	r25, r25
    2590:	88 0f       	add	r24, r24
    2592:	99 1f       	adc	r25, r25
    2594:	88 0f       	add	r24, r24
    2596:	99 1f       	adc	r25, r25
    2598:	82 0f       	add	r24, r18
    259a:	93 1f       	adc	r25, r19
    259c:	b8 01       	movw	r22, r16
    259e:	81 58       	subi	r24, 0x81	; 129
    25a0:	9d 4d       	sbci	r25, 0xDD	; 221
    25a2:	eb d8       	rcall	.-3626   	; 0x177a <vListInsertEnd>
    25a4:	e0 91 ac 22 	lds	r30, 0x22AC
    25a8:	f0 91 ad 22 	lds	r31, 0x22AD
    25ac:	9e 89       	ldd	r25, Y+22	; 0x16
    25ae:	86 89       	ldd	r24, Z+22	; 0x16
    25b0:	98 17       	cp	r25, r24
    25b2:	58 f0       	brcs	.+22     	; 0x25ca <xTaskResumeAll+0x9e>
    25b4:	d0 92 59 22 	sts	0x2259, r13
    25b8:	08 c0       	rjmp	.+16     	; 0x25ca <xTaskResumeAll+0x9e>
    25ba:	0f 2e       	mov	r0, r31
    25bc:	f0 e6       	ldi	r31, 0x60	; 96
    25be:	ef 2e       	mov	r14, r31
    25c0:	f2 e2       	ldi	r31, 0x22	; 34
    25c2:	ff 2e       	mov	r15, r31
    25c4:	f0 2d       	mov	r31, r0
    25c6:	dd 24       	eor	r13, r13
    25c8:	d3 94       	inc	r13
    25ca:	f7 01       	movw	r30, r14
    25cc:	80 81       	ld	r24, Z
    25ce:	81 11       	cpse	r24, r1
    25d0:	c5 cf       	rjmp	.-118    	; 0x255c <xTaskResumeAll+0x30>
    25d2:	80 91 5a 22 	lds	r24, 0x225A
    25d6:	88 23       	and	r24, r24
    25d8:	91 f0       	breq	.+36     	; 0x25fe <xTaskResumeAll+0xd2>
    25da:	80 91 5a 22 	lds	r24, 0x225A
    25de:	88 23       	and	r24, r24
    25e0:	71 f0       	breq	.+28     	; 0x25fe <xTaskResumeAll+0xd2>
    25e2:	c1 e0       	ldi	r28, 0x01	; 1
    25e4:	d0 de       	rcall	.-608    	; 0x2386 <xTaskIncrementTick>
    25e6:	81 11       	cpse	r24, r1
    25e8:	c0 93 59 22 	sts	0x2259, r28
    25ec:	80 91 5a 22 	lds	r24, 0x225A
    25f0:	81 50       	subi	r24, 0x01	; 1
    25f2:	80 93 5a 22 	sts	0x225A, r24
    25f6:	80 91 5a 22 	lds	r24, 0x225A
    25fa:	81 11       	cpse	r24, r1
    25fc:	f3 cf       	rjmp	.-26     	; 0x25e4 <xTaskResumeAll+0xb8>
    25fe:	80 91 59 22 	lds	r24, 0x2259
    2602:	81 30       	cpi	r24, 0x01	; 1
    2604:	29 f4       	brne	.+10     	; 0x2610 <xTaskResumeAll+0xe4>
    2606:	ed d9       	rcall	.-3110   	; 0x19e2 <vPortYield>
    2608:	81 e0       	ldi	r24, 0x01	; 1
    260a:	03 c0       	rjmp	.+6      	; 0x2612 <xTaskResumeAll+0xe6>
    260c:	80 e0       	ldi	r24, 0x00	; 0
    260e:	01 c0       	rjmp	.+2      	; 0x2612 <xTaskResumeAll+0xe6>
    2610:	80 e0       	ldi	r24, 0x00	; 0
    2612:	0f 90       	pop	r0
    2614:	0f be       	out	0x3f, r0	; 63
    2616:	df 91       	pop	r29
    2618:	cf 91       	pop	r28
    261a:	1f 91       	pop	r17
    261c:	0f 91       	pop	r16
    261e:	ff 90       	pop	r15
    2620:	ef 90       	pop	r14
    2622:	df 90       	pop	r13
    2624:	08 95       	ret

00002626 <vTaskDelay>:
    2626:	cf 93       	push	r28
    2628:	df 93       	push	r29
    262a:	ec 01       	movw	r28, r24
    262c:	89 2b       	or	r24, r25
    262e:	91 f0       	breq	.+36     	; 0x2654 <vTaskDelay+0x2e>
    2630:	9a de       	rcall	.-716    	; 0x2366 <vTaskSuspendAll>
    2632:	80 91 5d 22 	lds	r24, 0x225D
    2636:	90 91 5e 22 	lds	r25, 0x225E
    263a:	c8 0f       	add	r28, r24
    263c:	d9 1f       	adc	r29, r25
    263e:	80 91 ac 22 	lds	r24, 0x22AC
    2642:	90 91 ad 22 	lds	r25, 0x22AD
    2646:	02 96       	adiw	r24, 0x02	; 2
    2648:	ea d8       	rcall	.-3628   	; 0x181e <uxListRemove>
    264a:	ce 01       	movw	r24, r28
    264c:	23 dd       	rcall	.-1466   	; 0x2094 <prvAddCurrentTaskToDelayedList>
    264e:	6e df       	rcall	.-292    	; 0x252c <xTaskResumeAll>
    2650:	81 11       	cpse	r24, r1
    2652:	01 c0       	rjmp	.+2      	; 0x2656 <vTaskDelay+0x30>
    2654:	c6 d9       	rcall	.-3188   	; 0x19e2 <vPortYield>
    2656:	df 91       	pop	r29
    2658:	cf 91       	pop	r28
    265a:	08 95       	ret

0000265c <vTaskSwitchContext>:
    265c:	80 91 54 22 	lds	r24, 0x2254
    2660:	88 23       	and	r24, r24
    2662:	21 f0       	breq	.+8      	; 0x266c <vTaskSwitchContext+0x10>
    2664:	81 e0       	ldi	r24, 0x01	; 1
    2666:	80 93 59 22 	sts	0x2259, r24
    266a:	08 95       	ret
    266c:	10 92 59 22 	sts	0x2259, r1
    2670:	80 91 5c 22 	lds	r24, 0x225C
    2674:	90 e0       	ldi	r25, 0x00	; 0
    2676:	fc 01       	movw	r30, r24
    2678:	ee 0f       	add	r30, r30
    267a:	ff 1f       	adc	r31, r31
    267c:	ee 0f       	add	r30, r30
    267e:	ff 1f       	adc	r31, r31
    2680:	ee 0f       	add	r30, r30
    2682:	ff 1f       	adc	r31, r31
    2684:	8e 0f       	add	r24, r30
    2686:	9f 1f       	adc	r25, r31
    2688:	fc 01       	movw	r30, r24
    268a:	e1 58       	subi	r30, 0x81	; 129
    268c:	fd 4d       	sbci	r31, 0xDD	; 221
    268e:	80 81       	ld	r24, Z
    2690:	81 11       	cpse	r24, r1
    2692:	17 c0       	rjmp	.+46     	; 0x26c2 <vTaskSwitchContext+0x66>
    2694:	80 91 5c 22 	lds	r24, 0x225C
    2698:	81 50       	subi	r24, 0x01	; 1
    269a:	80 93 5c 22 	sts	0x225C, r24
    269e:	80 91 5c 22 	lds	r24, 0x225C
    26a2:	90 e0       	ldi	r25, 0x00	; 0
    26a4:	fc 01       	movw	r30, r24
    26a6:	ee 0f       	add	r30, r30
    26a8:	ff 1f       	adc	r31, r31
    26aa:	ee 0f       	add	r30, r30
    26ac:	ff 1f       	adc	r31, r31
    26ae:	ee 0f       	add	r30, r30
    26b0:	ff 1f       	adc	r31, r31
    26b2:	8e 0f       	add	r24, r30
    26b4:	9f 1f       	adc	r25, r31
    26b6:	fc 01       	movw	r30, r24
    26b8:	e1 58       	subi	r30, 0x81	; 129
    26ba:	fd 4d       	sbci	r31, 0xDD	; 221
    26bc:	80 81       	ld	r24, Z
    26be:	88 23       	and	r24, r24
    26c0:	49 f3       	breq	.-46     	; 0x2694 <vTaskSwitchContext+0x38>
    26c2:	80 91 5c 22 	lds	r24, 0x225C
    26c6:	90 e0       	ldi	r25, 0x00	; 0
    26c8:	9c 01       	movw	r18, r24
    26ca:	22 0f       	add	r18, r18
    26cc:	33 1f       	adc	r19, r19
    26ce:	22 0f       	add	r18, r18
    26d0:	33 1f       	adc	r19, r19
    26d2:	22 0f       	add	r18, r18
    26d4:	33 1f       	adc	r19, r19
    26d6:	28 0f       	add	r18, r24
    26d8:	39 1f       	adc	r19, r25
    26da:	d9 01       	movw	r26, r18
    26dc:	a1 58       	subi	r26, 0x81	; 129
    26de:	bd 4d       	sbci	r27, 0xDD	; 221
    26e0:	11 96       	adiw	r26, 0x01	; 1
    26e2:	ed 91       	ld	r30, X+
    26e4:	fc 91       	ld	r31, X
    26e6:	12 97       	sbiw	r26, 0x02	; 2
    26e8:	02 80       	ldd	r0, Z+2	; 0x02
    26ea:	f3 81       	ldd	r31, Z+3	; 0x03
    26ec:	e0 2d       	mov	r30, r0
    26ee:	11 96       	adiw	r26, 0x01	; 1
    26f0:	ed 93       	st	X+, r30
    26f2:	fc 93       	st	X, r31
    26f4:	12 97       	sbiw	r26, 0x02	; 2
    26f6:	2e 57       	subi	r18, 0x7E	; 126
    26f8:	3d 4d       	sbci	r19, 0xDD	; 221
    26fa:	e2 17       	cp	r30, r18
    26fc:	f3 07       	cpc	r31, r19
    26fe:	29 f4       	brne	.+10     	; 0x270a <vTaskSwitchContext+0xae>
    2700:	22 81       	ldd	r18, Z+2	; 0x02
    2702:	33 81       	ldd	r19, Z+3	; 0x03
    2704:	fd 01       	movw	r30, r26
    2706:	21 83       	std	Z+1, r18	; 0x01
    2708:	32 83       	std	Z+2, r19	; 0x02
    270a:	fc 01       	movw	r30, r24
    270c:	ee 0f       	add	r30, r30
    270e:	ff 1f       	adc	r31, r31
    2710:	ee 0f       	add	r30, r30
    2712:	ff 1f       	adc	r31, r31
    2714:	ee 0f       	add	r30, r30
    2716:	ff 1f       	adc	r31, r31
    2718:	8e 0f       	add	r24, r30
    271a:	9f 1f       	adc	r25, r31
    271c:	fc 01       	movw	r30, r24
    271e:	e1 58       	subi	r30, 0x81	; 129
    2720:	fd 4d       	sbci	r31, 0xDD	; 221
    2722:	01 80       	ldd	r0, Z+1	; 0x01
    2724:	f2 81       	ldd	r31, Z+2	; 0x02
    2726:	e0 2d       	mov	r30, r0
    2728:	86 81       	ldd	r24, Z+6	; 0x06
    272a:	97 81       	ldd	r25, Z+7	; 0x07
    272c:	80 93 ac 22 	sts	0x22AC, r24
    2730:	90 93 ad 22 	sts	0x22AD, r25
    2734:	08 95       	ret

00002736 <vTaskPlaceOnEventList>:
    2736:	cf 93       	push	r28
    2738:	df 93       	push	r29
    273a:	eb 01       	movw	r28, r22
    273c:	20 91 ac 22 	lds	r18, 0x22AC
    2740:	30 91 ad 22 	lds	r19, 0x22AD
    2744:	b9 01       	movw	r22, r18
    2746:	64 5f       	subi	r22, 0xF4	; 244
    2748:	7f 4f       	sbci	r23, 0xFF	; 255
    274a:	38 d8       	rcall	.-3984   	; 0x17bc <vListInsert>
    274c:	80 91 ac 22 	lds	r24, 0x22AC
    2750:	90 91 ad 22 	lds	r25, 0x22AD
    2754:	02 96       	adiw	r24, 0x02	; 2
    2756:	63 d8       	rcall	.-3898   	; 0x181e <uxListRemove>
    2758:	80 91 5d 22 	lds	r24, 0x225D
    275c:	90 91 5e 22 	lds	r25, 0x225E
    2760:	8c 0f       	add	r24, r28
    2762:	9d 1f       	adc	r25, r29
    2764:	97 dc       	rcall	.-1746   	; 0x2094 <prvAddCurrentTaskToDelayedList>
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	08 95       	ret

0000276c <vTaskPlaceOnEventListRestricted>:
    276c:	cf 93       	push	r28
    276e:	df 93       	push	r29
    2770:	eb 01       	movw	r28, r22
    2772:	20 91 ac 22 	lds	r18, 0x22AC
    2776:	30 91 ad 22 	lds	r19, 0x22AD
    277a:	b9 01       	movw	r22, r18
    277c:	64 5f       	subi	r22, 0xF4	; 244
    277e:	7f 4f       	sbci	r23, 0xFF	; 255
    2780:	0e 94 bd 0b 	call	0x177a	; 0x177a <vListInsertEnd>
    2784:	80 91 ac 22 	lds	r24, 0x22AC
    2788:	90 91 ad 22 	lds	r25, 0x22AD
    278c:	02 96       	adiw	r24, 0x02	; 2
    278e:	47 d8       	rcall	.-3954   	; 0x181e <uxListRemove>
    2790:	80 91 5d 22 	lds	r24, 0x225D
    2794:	90 91 5e 22 	lds	r25, 0x225E
    2798:	8c 0f       	add	r24, r28
    279a:	9d 1f       	adc	r25, r29
    279c:	7b dc       	rcall	.-1802   	; 0x2094 <prvAddCurrentTaskToDelayedList>
    279e:	df 91       	pop	r29
    27a0:	cf 91       	pop	r28
    27a2:	08 95       	ret

000027a4 <xTaskRemoveFromEventList>:
    27a4:	0f 93       	push	r16
    27a6:	1f 93       	push	r17
    27a8:	cf 93       	push	r28
    27aa:	df 93       	push	r29
    27ac:	dc 01       	movw	r26, r24
    27ae:	15 96       	adiw	r26, 0x05	; 5
    27b0:	ed 91       	ld	r30, X+
    27b2:	fc 91       	ld	r31, X
    27b4:	16 97       	sbiw	r26, 0x06	; 6
    27b6:	c6 81       	ldd	r28, Z+6	; 0x06
    27b8:	d7 81       	ldd	r29, Z+7	; 0x07
    27ba:	8e 01       	movw	r16, r28
    27bc:	04 5f       	subi	r16, 0xF4	; 244
    27be:	1f 4f       	sbci	r17, 0xFF	; 255
    27c0:	c8 01       	movw	r24, r16
    27c2:	2d d8       	rcall	.-4006   	; 0x181e <uxListRemove>
    27c4:	80 91 54 22 	lds	r24, 0x2254
    27c8:	81 11       	cpse	r24, r1
    27ca:	1b c0       	rjmp	.+54     	; 0x2802 <xTaskRemoveFromEventList+0x5e>
    27cc:	0a 50       	subi	r16, 0x0A	; 10
    27ce:	11 09       	sbc	r17, r1
    27d0:	c8 01       	movw	r24, r16
    27d2:	25 d8       	rcall	.-4022   	; 0x181e <uxListRemove>
    27d4:	2e 89       	ldd	r18, Y+22	; 0x16
    27d6:	80 91 5c 22 	lds	r24, 0x225C
    27da:	82 17       	cp	r24, r18
    27dc:	10 f4       	brcc	.+4      	; 0x27e2 <xTaskRemoveFromEventList+0x3e>
    27de:	20 93 5c 22 	sts	0x225C, r18
    27e2:	30 e0       	ldi	r19, 0x00	; 0
    27e4:	c9 01       	movw	r24, r18
    27e6:	88 0f       	add	r24, r24
    27e8:	99 1f       	adc	r25, r25
    27ea:	88 0f       	add	r24, r24
    27ec:	99 1f       	adc	r25, r25
    27ee:	88 0f       	add	r24, r24
    27f0:	99 1f       	adc	r25, r25
    27f2:	82 0f       	add	r24, r18
    27f4:	93 1f       	adc	r25, r19
    27f6:	b8 01       	movw	r22, r16
    27f8:	81 58       	subi	r24, 0x81	; 129
    27fa:	9d 4d       	sbci	r25, 0xDD	; 221
    27fc:	0e 94 bd 0b 	call	0x177a	; 0x177a <vListInsertEnd>
    2800:	05 c0       	rjmp	.+10     	; 0x280c <xTaskRemoveFromEventList+0x68>
    2802:	b8 01       	movw	r22, r16
    2804:	80 e6       	ldi	r24, 0x60	; 96
    2806:	92 e2       	ldi	r25, 0x22	; 34
    2808:	0e 94 bd 0b 	call	0x177a	; 0x177a <vListInsertEnd>
    280c:	e0 91 ac 22 	lds	r30, 0x22AC
    2810:	f0 91 ad 22 	lds	r31, 0x22AD
    2814:	9e 89       	ldd	r25, Y+22	; 0x16
    2816:	86 89       	ldd	r24, Z+22	; 0x16
    2818:	89 17       	cp	r24, r25
    281a:	20 f4       	brcc	.+8      	; 0x2824 <xTaskRemoveFromEventList+0x80>
    281c:	81 e0       	ldi	r24, 0x01	; 1
    281e:	80 93 59 22 	sts	0x2259, r24
    2822:	01 c0       	rjmp	.+2      	; 0x2826 <xTaskRemoveFromEventList+0x82>
    2824:	80 e0       	ldi	r24, 0x00	; 0
    2826:	df 91       	pop	r29
    2828:	cf 91       	pop	r28
    282a:	1f 91       	pop	r17
    282c:	0f 91       	pop	r16
    282e:	08 95       	ret

00002830 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    2830:	20 91 58 22 	lds	r18, 0x2258
    2834:	fc 01       	movw	r30, r24
    2836:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2838:	20 91 5d 22 	lds	r18, 0x225D
    283c:	30 91 5e 22 	lds	r19, 0x225E
    2840:	21 83       	std	Z+1, r18	; 0x01
    2842:	32 83       	std	Z+2, r19	; 0x02
    2844:	08 95       	ret

00002846 <xTaskCheckForTimeOut>:
}
/*-----------------------------------------------------------*/

BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
{
    2846:	cf 93       	push	r28
    2848:	df 93       	push	r29
    284a:	fc 01       	movw	r30, r24
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    284c:	0f b6       	in	r0, 0x3f	; 63
    284e:	f8 94       	cli
    2850:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2852:	20 91 5d 22 	lds	r18, 0x225D
    2856:	30 91 5e 22 	lds	r19, 0x225E
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    285a:	80 91 58 22 	lds	r24, 0x2258
    285e:	90 81       	ld	r25, Z
    2860:	98 17       	cp	r25, r24
    2862:	29 f0       	breq	.+10     	; 0x286e <xTaskCheckForTimeOut+0x28>
    2864:	81 81       	ldd	r24, Z+1	; 0x01
    2866:	92 81       	ldd	r25, Z+2	; 0x02
    2868:	28 17       	cp	r18, r24
    286a:	39 07       	cpc	r19, r25
    286c:	a8 f4       	brcc	.+42     	; 0x2898 <xTaskCheckForTimeOut+0x52>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    286e:	a1 81       	ldd	r26, Z+1	; 0x01
    2870:	b2 81       	ldd	r27, Z+2	; 0x02
    2872:	eb 01       	movw	r28, r22
    2874:	48 81       	ld	r20, Y
    2876:	59 81       	ldd	r21, Y+1	; 0x01
    2878:	c9 01       	movw	r24, r18
    287a:	8a 1b       	sub	r24, r26
    287c:	9b 0b       	sbc	r25, r27
    287e:	84 17       	cp	r24, r20
    2880:	95 07       	cpc	r25, r21
    2882:	60 f4       	brcc	.+24     	; 0x289c <xTaskCheckForTimeOut+0x56>
    2884:	cf 01       	movw	r24, r30
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    2886:	a2 1b       	sub	r26, r18
    2888:	b3 0b       	sbc	r27, r19
    288a:	4a 0f       	add	r20, r26
    288c:	5b 1f       	adc	r21, r27
    288e:	48 83       	st	Y, r20
    2890:	59 83       	std	Y+1, r21	; 0x01
			vTaskSetTimeOutState( pxTimeOut );
    2892:	ce df       	rcall	.-100    	; 0x2830 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    2894:	80 e0       	ldi	r24, 0x00	; 0
    2896:	03 c0       	rjmp	.+6      	; 0x289e <xTaskCheckForTimeOut+0x58>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    2898:	81 e0       	ldi	r24, 0x01	; 1
    289a:	01 c0       	rjmp	.+2      	; 0x289e <xTaskCheckForTimeOut+0x58>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    289c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    289e:	0f 90       	pop	r0
    28a0:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    28a2:	df 91       	pop	r29
    28a4:	cf 91       	pop	r28
    28a6:	08 95       	ret

000028a8 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    28a8:	81 e0       	ldi	r24, 0x01	; 1
    28aa:	80 93 59 22 	sts	0x2259, r24
    28ae:	08 95       	ret

000028b0 <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    28b0:	80 91 5b 22 	lds	r24, 0x225B
    28b4:	88 23       	and	r24, r24
    28b6:	31 f0       	breq	.+12     	; 0x28c4 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    28b8:	80 91 54 22 	lds	r24, 0x2254
    28bc:	88 23       	and	r24, r24
    28be:	21 f0       	breq	.+8      	; 0x28c8 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    28c0:	80 e0       	ldi	r24, 0x00	; 0
    28c2:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    28c4:	81 e0       	ldi	r24, 0x01	; 1
    28c6:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    28c8:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    28ca:	08 95       	ret

000028cc <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    28cc:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    28ce:	62 83       	std	Z+2, r22	; 0x02
    28d0:	73 83       	std	Z+3, r23	; 0x03
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    28d2:	80 87       	std	Z+8, r24	; 0x08
    28d4:	91 87       	std	Z+9, r25	; 0x09

	if( xNextExpiryTime <= xTimeNow )
    28d6:	46 17       	cp	r20, r22
    28d8:	57 07       	cpc	r21, r23
    28da:	90 f0       	brcs	.+36     	; 0x2900 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
    28dc:	42 1b       	sub	r20, r18
    28de:	53 0b       	sbc	r21, r19
    28e0:	84 85       	ldd	r24, Z+12	; 0x0c
    28e2:	95 85       	ldd	r25, Z+13	; 0x0d
    28e4:	48 17       	cp	r20, r24
    28e6:	59 07       	cpc	r21, r25
    28e8:	e0 f4       	brcc	.+56     	; 0x2922 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    28ea:	bf 01       	movw	r22, r30
    28ec:	6e 5f       	subi	r22, 0xFE	; 254
    28ee:	7f 4f       	sbci	r23, 0xFF	; 255
    28f0:	80 91 b2 22 	lds	r24, 0x22B2
    28f4:	90 91 b3 22 	lds	r25, 0x22B3
    28f8:	0e 94 de 0b 	call	0x17bc	; 0x17bc <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    28fc:	80 e0       	ldi	r24, 0x00	; 0
    28fe:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2900:	42 17       	cp	r20, r18
    2902:	53 07       	cpc	r21, r19
    2904:	18 f4       	brcc	.+6      	; 0x290c <prvInsertTimerInActiveList+0x40>
    2906:	62 17       	cp	r22, r18
    2908:	73 07       	cpc	r23, r19
    290a:	68 f4       	brcc	.+26     	; 0x2926 <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    290c:	bf 01       	movw	r22, r30
    290e:	6e 5f       	subi	r22, 0xFE	; 254
    2910:	7f 4f       	sbci	r23, 0xFF	; 255
    2912:	80 91 b4 22 	lds	r24, 0x22B4
    2916:	90 91 b5 22 	lds	r25, 0x22B5
    291a:	0e 94 de 0b 	call	0x17bc	; 0x17bc <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    291e:	80 e0       	ldi	r24, 0x00	; 0
    2920:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( xTimeNow - xCommandTime ) >= pxTimer->xTimerPeriodInTicks )
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    2922:	81 e0       	ldi	r24, 0x01	; 1
    2924:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    2926:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    2928:	08 95       	ret

0000292a <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    292a:	0f b6       	in	r0, 0x3f	; 63
    292c:	f8 94       	cli
    292e:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    2930:	80 91 b0 22 	lds	r24, 0x22B0
    2934:	90 91 b1 22 	lds	r25, 0x22B1
    2938:	89 2b       	or	r24, r25
    293a:	e1 f4       	brne	.+56     	; 0x2974 <prvCheckForValidListAndQueue+0x4a>
		{
			vListInitialise( &xActiveTimerList1 );
    293c:	8f eb       	ldi	r24, 0xBF	; 191
    293e:	92 e2       	ldi	r25, 0x22	; 34
    2940:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    2944:	86 eb       	ldi	r24, 0xB6	; 182
    2946:	92 e2       	ldi	r25, 0x22	; 34
    2948:	0e 94 ab 0b 	call	0x1756	; 0x1756 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    294c:	8f eb       	ldi	r24, 0xBF	; 191
    294e:	92 e2       	ldi	r25, 0x22	; 34
    2950:	80 93 b4 22 	sts	0x22B4, r24
    2954:	90 93 b5 22 	sts	0x22B5, r25
			pxOverflowTimerList = &xActiveTimerList2;
    2958:	86 eb       	ldi	r24, 0xB6	; 182
    295a:	92 e2       	ldi	r25, 0x22	; 34
    295c:	80 93 b2 22 	sts	0x22B2, r24
    2960:	90 93 b3 22 	sts	0x22B3, r25
			xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    2964:	40 e0       	ldi	r20, 0x00	; 0
    2966:	65 e0       	ldi	r22, 0x05	; 5
    2968:	8a e0       	ldi	r24, 0x0A	; 10
    296a:	ef d9       	rcall	.-3106   	; 0x1d4a <xQueueGenericCreate>
    296c:	80 93 b0 22 	sts	0x22B0, r24
    2970:	90 93 b1 22 	sts	0x22B1, r25
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    2974:	0f 90       	pop	r0
    2976:	0f be       	out	0x3f, r0	; 63
    2978:	08 95       	ret

0000297a <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    297a:	af 92       	push	r10
    297c:	bf 92       	push	r11
    297e:	cf 92       	push	r12
    2980:	df 92       	push	r13
    2982:	ef 92       	push	r14
    2984:	ff 92       	push	r15
    2986:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    2988:	d0 df       	rcall	.-96     	; 0x292a <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    298a:	80 91 b0 22 	lds	r24, 0x22B0
    298e:	90 91 b1 22 	lds	r25, 0x22B1
    2992:	89 2b       	or	r24, r25
    2994:	89 f0       	breq	.+34     	; 0x29b8 <xTimerCreateTimerTask+0x3e>
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, "Tmr Svc", ( uint16_t ) configTIMER_TASK_STACK_DEPTH, NULL, ( ( UBaseType_t ) configTIMER_TASK_PRIORITY ) | portPRIVILEGE_BIT, NULL);
    2996:	a1 2c       	mov	r10, r1
    2998:	b1 2c       	mov	r11, r1
    299a:	c1 2c       	mov	r12, r1
    299c:	d1 2c       	mov	r13, r1
    299e:	e1 2c       	mov	r14, r1
    29a0:	f1 2c       	mov	r15, r1
    29a2:	03 e0       	ldi	r16, 0x03	; 3
    29a4:	20 e0       	ldi	r18, 0x00	; 0
    29a6:	30 e0       	ldi	r19, 0x00	; 0
    29a8:	45 e5       	ldi	r20, 0x55	; 85
    29aa:	50 e0       	ldi	r21, 0x00	; 0
    29ac:	62 e1       	ldi	r22, 0x12	; 18
    29ae:	70 e2       	ldi	r23, 0x20	; 32
    29b0:	8b ec       	ldi	r24, 0xCB	; 203
    29b2:	95 e1       	ldi	r25, 0x15	; 21
    29b4:	a4 db       	rcall	.-2232   	; 0x20fe <xTaskGenericCreate>
    29b6:	01 c0       	rjmp	.+2      	; 0x29ba <xTimerCreateTimerTask+0x40>

/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    29b8:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    29ba:	0f 91       	pop	r16
    29bc:	ff 90       	pop	r15
    29be:	ef 90       	pop	r14
    29c0:	df 90       	pop	r13
    29c2:	cf 90       	pop	r12
    29c4:	bf 90       	pop	r11
    29c6:	af 90       	pop	r10
    29c8:	08 95       	ret

000029ca <xTimerCreate>:
/*-----------------------------------------------------------*/

TimerHandle_t xTimerCreate( const char * const pcTimerName, const TickType_t xTimerPeriodInTicks, const UBaseType_t uxAutoReload, void * const pvTimerID, TimerCallbackFunction_t pxCallbackFunction ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
    29ca:	8f 92       	push	r8
    29cc:	9f 92       	push	r9
    29ce:	bf 92       	push	r11
    29d0:	cf 92       	push	r12
    29d2:	df 92       	push	r13
    29d4:	ef 92       	push	r14
    29d6:	ff 92       	push	r15
    29d8:	0f 93       	push	r16
    29da:	1f 93       	push	r17
    29dc:	cf 93       	push	r28
    29de:	df 93       	push	r29
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
    29e0:	61 15       	cp	r22, r1
    29e2:	71 05       	cpc	r23, r1
    29e4:	c9 f0       	breq	.+50     	; 0x2a18 <xTimerCreate+0x4e>
    29e6:	69 01       	movw	r12, r18
    29e8:	b4 2e       	mov	r11, r20
    29ea:	7b 01       	movw	r14, r22
    29ec:	4c 01       	movw	r8, r24
	{
		pxNewTimer = NULL;
	}
	else
	{
		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) );
    29ee:	83 e1       	ldi	r24, 0x13	; 19
    29f0:	90 e0       	ldi	r25, 0x00	; 0
    29f2:	a9 d8       	rcall	.-3758   	; 0x1b46 <pvPortMalloc>
    29f4:	ec 01       	movw	r28, r24
		if( pxNewTimer != NULL )
    29f6:	89 2b       	or	r24, r25
    29f8:	89 f0       	breq	.+34     	; 0x2a1c <xTimerCreate+0x52>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    29fa:	97 df       	rcall	.-210    	; 0x292a <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    29fc:	88 82       	st	Y, r8
    29fe:	99 82       	std	Y+1, r9	; 0x01
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    2a00:	ec 86       	std	Y+12, r14	; 0x0c
    2a02:	fd 86       	std	Y+13, r15	; 0x0d
			pxNewTimer->uxAutoReload = uxAutoReload;
    2a04:	be 86       	std	Y+14, r11	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    2a06:	cf 86       	std	Y+15, r12	; 0x0f
    2a08:	d8 8a       	std	Y+16, r13	; 0x10
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    2a0a:	09 8b       	std	Y+17, r16	; 0x11
    2a0c:	1a 8b       	std	Y+18, r17	; 0x12
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    2a0e:	ce 01       	movw	r24, r28
    2a10:	02 96       	adiw	r24, 0x02	; 2
    2a12:	0e 94 b9 0b 	call	0x1772	; 0x1772 <vListInitialiseItem>
    2a16:	02 c0       	rjmp	.+4      	; 0x2a1c <xTimerCreate+0x52>
Timer_t *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( TickType_t ) 0U )
	{
		pxNewTimer = NULL;
    2a18:	c0 e0       	ldi	r28, 0x00	; 0
    2a1a:	d0 e0       	ldi	r29, 0x00	; 0

	/* 0 is not a valid value for xTimerPeriodInTicks. */
	configASSERT( ( xTimerPeriodInTicks > 0 ) );

	return ( TimerHandle_t ) pxNewTimer;
}
    2a1c:	ce 01       	movw	r24, r28
    2a1e:	df 91       	pop	r29
    2a20:	cf 91       	pop	r28
    2a22:	1f 91       	pop	r17
    2a24:	0f 91       	pop	r16
    2a26:	ff 90       	pop	r15
    2a28:	ef 90       	pop	r14
    2a2a:	df 90       	pop	r13
    2a2c:	cf 90       	pop	r12
    2a2e:	bf 90       	pop	r11
    2a30:	9f 90       	pop	r9
    2a32:	8f 90       	pop	r8
    2a34:	08 95       	ret

00002a36 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2a36:	0f 93       	push	r16
    2a38:	1f 93       	push	r17
    2a3a:	cf 93       	push	r28
    2a3c:	df 93       	push	r29
    2a3e:	cd b7       	in	r28, 0x3d	; 61
    2a40:	de b7       	in	r29, 0x3e	; 62
    2a42:	25 97       	sbiw	r28, 0x05	; 5
    2a44:	cd bf       	out	0x3d, r28	; 61
    2a46:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    2a48:	e0 91 b0 22 	lds	r30, 0x22B0
    2a4c:	f0 91 b1 22 	lds	r31, 0x22B1
    2a50:	30 97       	sbiw	r30, 0x00	; 0
    2a52:	51 f1       	breq	.+84     	; 0x2aa8 <xTimerGenericCommand+0x72>
    2a54:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    2a56:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    2a58:	4a 83       	std	Y+2, r20	; 0x02
    2a5a:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = ( Timer_t * ) xTimer;
    2a5c:	8c 83       	std	Y+4, r24	; 0x04
    2a5e:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    2a60:	66 30       	cpi	r22, 0x06	; 6
    2a62:	d4 f4       	brge	.+52     	; 0x2a98 <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    2a64:	25 df       	rcall	.-438    	; 0x28b0 <xTaskGetSchedulerState>
    2a66:	82 30       	cpi	r24, 0x02	; 2
    2a68:	59 f4       	brne	.+22     	; 0x2a80 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    2a6a:	20 e0       	ldi	r18, 0x00	; 0
    2a6c:	a8 01       	movw	r20, r16
    2a6e:	be 01       	movw	r22, r28
    2a70:	6f 5f       	subi	r22, 0xFF	; 255
    2a72:	7f 4f       	sbci	r23, 0xFF	; 255
    2a74:	80 91 b0 22 	lds	r24, 0x22B0
    2a78:	90 91 b1 22 	lds	r25, 0x22B1
    2a7c:	8f d9       	rcall	.-3298   	; 0x1d9c <xQueueGenericSend>
    2a7e:	15 c0       	rjmp	.+42     	; 0x2aaa <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    2a80:	20 e0       	ldi	r18, 0x00	; 0
    2a82:	40 e0       	ldi	r20, 0x00	; 0
    2a84:	50 e0       	ldi	r21, 0x00	; 0
    2a86:	be 01       	movw	r22, r28
    2a88:	6f 5f       	subi	r22, 0xFF	; 255
    2a8a:	7f 4f       	sbci	r23, 0xFF	; 255
    2a8c:	80 91 b0 22 	lds	r24, 0x22B0
    2a90:	90 91 b1 22 	lds	r25, 0x22B1
    2a94:	83 d9       	rcall	.-3322   	; 0x1d9c <xQueueGenericSend>
    2a96:	09 c0       	rjmp	.+18     	; 0x2aaa <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    2a98:	20 e0       	ldi	r18, 0x00	; 0
    2a9a:	ad 01       	movw	r20, r26
    2a9c:	be 01       	movw	r22, r28
    2a9e:	6f 5f       	subi	r22, 0xFF	; 255
    2aa0:	7f 4f       	sbci	r23, 0xFF	; 255
    2aa2:	cf 01       	movw	r24, r30
    2aa4:	08 da       	rcall	.-3056   	; 0x1eb6 <xQueueGenericSendFromISR>
    2aa6:	01 c0       	rjmp	.+2      	; 0x2aaa <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    2aaa:	25 96       	adiw	r28, 0x05	; 5
    2aac:	cd bf       	out	0x3d, r28	; 61
    2aae:	de bf       	out	0x3e, r29	; 62
    2ab0:	df 91       	pop	r29
    2ab2:	cf 91       	pop	r28
    2ab4:	1f 91       	pop	r17
    2ab6:	0f 91       	pop	r16
    2ab8:	08 95       	ret

00002aba <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    2aba:	af 92       	push	r10
    2abc:	bf 92       	push	r11
    2abe:	cf 92       	push	r12
    2ac0:	df 92       	push	r13
    2ac2:	ef 92       	push	r14
    2ac4:	ff 92       	push	r15
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	cf 93       	push	r28
    2acc:	df 93       	push	r29
    2ace:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2ad0:	50 dc       	rcall	.-1888   	; 0x2372 <xTaskGetTickCount>
    2ad2:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    2ad4:	80 91 ae 22 	lds	r24, 0x22AE
    2ad8:	90 91 af 22 	lds	r25, 0x22AF
    2adc:	e8 16       	cp	r14, r24
    2ade:	f9 06       	cpc	r15, r25
    2ae0:	08 f0       	brcs	.+2      	; 0x2ae4 <prvSampleTimeNow+0x2a>
    2ae2:	47 c0       	rjmp	.+142    	; 0x2b72 <prvSampleTimeNow+0xb8>
    2ae4:	2f c0       	rjmp	.+94     	; 0x2b44 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2ae6:	05 80       	ldd	r0, Z+5	; 0x05
    2ae8:	f6 81       	ldd	r31, Z+6	; 0x06
    2aea:	e0 2d       	mov	r30, r0
    2aec:	a0 80       	ld	r10, Z
    2aee:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2af0:	c6 81       	ldd	r28, Z+6	; 0x06
    2af2:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2af4:	8e 01       	movw	r16, r28
    2af6:	0e 5f       	subi	r16, 0xFE	; 254
    2af8:	1f 4f       	sbci	r17, 0xFF	; 255
    2afa:	c8 01       	movw	r24, r16
    2afc:	0e 94 0f 0c 	call	0x181e	; 0x181e <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2b00:	e9 89       	ldd	r30, Y+17	; 0x11
    2b02:	fa 89       	ldd	r31, Y+18	; 0x12
    2b04:	ce 01       	movw	r24, r28
    2b06:	19 95       	eicall

		if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2b08:	8e 85       	ldd	r24, Y+14	; 0x0e
    2b0a:	81 30       	cpi	r24, 0x01	; 1
    2b0c:	d9 f4       	brne	.+54     	; 0x2b44 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2b0e:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b10:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b12:	8a 0d       	add	r24, r10
    2b14:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2b16:	a8 16       	cp	r10, r24
    2b18:	b9 06       	cpc	r11, r25
    2b1a:	60 f4       	brcc	.+24     	; 0x2b34 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    2b1c:	8a 83       	std	Y+2, r24	; 0x02
    2b1e:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2b20:	c8 87       	std	Y+8, r28	; 0x08
    2b22:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2b24:	b8 01       	movw	r22, r16
    2b26:	80 91 b4 22 	lds	r24, 0x22B4
    2b2a:	90 91 b5 22 	lds	r25, 0x22B5
    2b2e:	0e 94 de 0b 	call	0x17bc	; 0x17bc <vListInsert>
    2b32:	08 c0       	rjmp	.+16     	; 0x2b44 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2b34:	00 e0       	ldi	r16, 0x00	; 0
    2b36:	10 e0       	ldi	r17, 0x00	; 0
    2b38:	20 e0       	ldi	r18, 0x00	; 0
    2b3a:	30 e0       	ldi	r19, 0x00	; 0
    2b3c:	a5 01       	movw	r20, r10
    2b3e:	60 e0       	ldi	r22, 0x00	; 0
    2b40:	ce 01       	movw	r24, r28
    2b42:	79 df       	rcall	.-270    	; 0x2a36 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2b44:	e0 91 b4 22 	lds	r30, 0x22B4
    2b48:	f0 91 b5 22 	lds	r31, 0x22B5
    2b4c:	90 81       	ld	r25, Z
    2b4e:	91 11       	cpse	r25, r1
    2b50:	ca cf       	rjmp	.-108    	; 0x2ae6 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    2b52:	80 91 b2 22 	lds	r24, 0x22B2
    2b56:	90 91 b3 22 	lds	r25, 0x22B3
    2b5a:	80 93 b4 22 	sts	0x22B4, r24
    2b5e:	90 93 b5 22 	sts	0x22B5, r25
	pxOverflowTimerList = pxTemp;
    2b62:	e0 93 b2 22 	sts	0x22B2, r30
    2b66:	f0 93 b3 22 	sts	0x22B3, r31
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    2b6a:	81 e0       	ldi	r24, 0x01	; 1
    2b6c:	f6 01       	movw	r30, r12
    2b6e:	80 83       	st	Z, r24
    2b70:	02 c0       	rjmp	.+4      	; 0x2b76 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    2b72:	f6 01       	movw	r30, r12
    2b74:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    2b76:	e0 92 ae 22 	sts	0x22AE, r14
    2b7a:	f0 92 af 22 	sts	0x22AF, r15

	return xTimeNow;
}
    2b7e:	c7 01       	movw	r24, r14
    2b80:	df 91       	pop	r29
    2b82:	cf 91       	pop	r28
    2b84:	1f 91       	pop	r17
    2b86:	0f 91       	pop	r16
    2b88:	ff 90       	pop	r15
    2b8a:	ef 90       	pop	r14
    2b8c:	df 90       	pop	r13
    2b8e:	cf 90       	pop	r12
    2b90:	bf 90       	pop	r11
    2b92:	af 90       	pop	r10
    2b94:	08 95       	ret

00002b96 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    2b96:	cf 93       	push	r28
    2b98:	df 93       	push	r29
    2b9a:	00 d0       	rcall	.+0      	; 0x2b9c <prvTimerTask+0x6>
    2b9c:	00 d0       	rcall	.+0      	; 0x2b9e <prvTimerTask+0x8>
    2b9e:	cd b7       	in	r28, 0x3d	; 61
    2ba0:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2ba2:	ce 01       	movw	r24, r28
    2ba4:	01 96       	adiw	r24, 0x01	; 1
    2ba6:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2ba8:	e8 2e       	mov	r14, r24
    2baa:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    2bac:	e0 91 b4 22 	lds	r30, 0x22B4
    2bb0:	f0 91 b5 22 	lds	r31, 0x22B5
	if( *pxListWasEmpty == pdFALSE )
    2bb4:	80 81       	ld	r24, Z
    2bb6:	88 23       	and	r24, r24
    2bb8:	69 f0       	breq	.+26     	; 0x2bd4 <prvTimerTask+0x3e>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2bba:	05 80       	ldd	r0, Z+5	; 0x05
    2bbc:	f6 81       	ldd	r31, Z+6	; 0x06
    2bbe:	e0 2d       	mov	r30, r0
    2bc0:	c0 80       	ld	r12, Z
    2bc2:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2bc4:	d0 db       	rcall	.-2144   	; 0x2366 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2bc6:	c5 01       	movw	r24, r10
    2bc8:	78 df       	rcall	.-272    	; 0x2aba <prvSampleTimeNow>
    2bca:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2bcc:	89 81       	ldd	r24, Y+1	; 0x01
    2bce:	88 23       	and	r24, r24
    2bd0:	49 f0       	breq	.+18     	; 0x2be4 <prvTimerTask+0x4e>
    2bd2:	56 c0       	rjmp	.+172    	; 0x2c80 <prvTimerTask+0xea>
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2bd4:	c8 db       	rcall	.-2160   	; 0x2366 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2bd6:	c5 01       	movw	r24, r10
    2bd8:	70 df       	rcall	.-288    	; 0x2aba <prvSampleTimeNow>
    2bda:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2bdc:	89 81       	ldd	r24, Y+1	; 0x01
    2bde:	88 23       	and	r24, r24
    2be0:	a9 f1       	breq	.+106    	; 0x2c4c <prvTimerTask+0xb6>
    2be2:	4e c0       	rjmp	.+156    	; 0x2c80 <prvTimerTask+0xea>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2be4:	0c 15       	cp	r16, r12
    2be6:	1d 05       	cpc	r17, r13
    2be8:	08 f4       	brcc	.+2      	; 0x2bec <prvTimerTask+0x56>
    2bea:	3b c0       	rjmp	.+118    	; 0x2c62 <prvTimerTask+0xcc>
			{
				( void ) xTaskResumeAll();
    2bec:	9f dc       	rcall	.-1730   	; 0x252c <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    2bee:	e0 91 b4 22 	lds	r30, 0x22B4
    2bf2:	f0 91 b5 22 	lds	r31, 0x22B5
    2bf6:	05 80       	ldd	r0, Z+5	; 0x05
    2bf8:	f6 81       	ldd	r31, Z+6	; 0x06
    2bfa:	e0 2d       	mov	r30, r0
    2bfc:	86 80       	ldd	r8, Z+6	; 0x06
    2bfe:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c00:	c4 01       	movw	r24, r8
    2c02:	02 96       	adiw	r24, 0x02	; 2
    2c04:	0e 94 0f 0c 	call	0x181e	; 0x181e <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2c08:	d4 01       	movw	r26, r8
    2c0a:	1e 96       	adiw	r26, 0x0e	; 14
    2c0c:	8c 91       	ld	r24, X
    2c0e:	1e 97       	sbiw	r26, 0x0e	; 14
    2c10:	81 30       	cpi	r24, 0x01	; 1
    2c12:	a1 f4       	brne	.+40     	; 0x2c3c <prvTimerTask+0xa6>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    2c14:	1c 96       	adiw	r26, 0x0c	; 12
    2c16:	6d 91       	ld	r22, X+
    2c18:	7c 91       	ld	r23, X
    2c1a:	1d 97       	sbiw	r26, 0x0d	; 13
    2c1c:	6c 0d       	add	r22, r12
    2c1e:	7d 1d       	adc	r23, r13
    2c20:	96 01       	movw	r18, r12
    2c22:	a8 01       	movw	r20, r16
    2c24:	c4 01       	movw	r24, r8
    2c26:	52 de       	rcall	.-860    	; 0x28cc <prvInsertTimerInActiveList>
    2c28:	81 30       	cpi	r24, 0x01	; 1
    2c2a:	41 f4       	brne	.+16     	; 0x2c3c <prvTimerTask+0xa6>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2c2c:	00 e0       	ldi	r16, 0x00	; 0
    2c2e:	10 e0       	ldi	r17, 0x00	; 0
    2c30:	20 e0       	ldi	r18, 0x00	; 0
    2c32:	30 e0       	ldi	r19, 0x00	; 0
    2c34:	a6 01       	movw	r20, r12
    2c36:	60 e0       	ldi	r22, 0x00	; 0
    2c38:	c4 01       	movw	r24, r8
    2c3a:	fd de       	rcall	.-518    	; 0x2a36 <xTimerGenericCommand>
	{
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2c3c:	d4 01       	movw	r26, r8
    2c3e:	51 96       	adiw	r26, 0x11	; 17
    2c40:	ed 91       	ld	r30, X+
    2c42:	fc 91       	ld	r31, X
    2c44:	52 97       	sbiw	r26, 0x12	; 18
    2c46:	c4 01       	movw	r24, r8
    2c48:	19 95       	eicall
    2c4a:	75 c0       	rjmp	.+234    	; 0x2d36 <prvTimerTask+0x1a0>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    2c4c:	e0 91 b2 22 	lds	r30, 0x22B2
    2c50:	f0 91 b3 22 	lds	r31, 0x22B3
    2c54:	41 e0       	ldi	r20, 0x01	; 1
    2c56:	80 81       	ld	r24, Z
    2c58:	81 11       	cpse	r24, r1
    2c5a:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    2c5c:	c1 2c       	mov	r12, r1
    2c5e:	d1 2c       	mov	r13, r1
    2c60:	01 c0       	rjmp	.+2      	; 0x2c64 <prvTimerTask+0xce>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2c62:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2c64:	b6 01       	movw	r22, r12
    2c66:	60 1b       	sub	r22, r16
    2c68:	71 0b       	sbc	r23, r17
    2c6a:	80 91 b0 22 	lds	r24, 0x22B0
    2c6e:	90 91 b1 22 	lds	r25, 0x22B1
    2c72:	ee d9       	rcall	.-3108   	; 0x2050 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    2c74:	5b dc       	rcall	.-1866   	; 0x252c <xTaskResumeAll>
    2c76:	81 11       	cpse	r24, r1
    2c78:	5e c0       	rjmp	.+188    	; 0x2d36 <prvTimerTask+0x1a0>
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    2c7a:	0e 94 f1 0c 	call	0x19e2	; 0x19e2 <vPortYield>
    2c7e:	5b c0       	rjmp	.+182    	; 0x2d36 <prvTimerTask+0x1a0>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    2c80:	55 dc       	rcall	.-1878   	; 0x252c <xTaskResumeAll>
    2c82:	59 c0       	rjmp	.+178    	; 0x2d36 <prvTimerTask+0x1a0>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    2c84:	99 81       	ldd	r25, Y+1	; 0x01
    2c86:	99 23       	and	r25, r25
    2c88:	0c f4       	brge	.+2      	; 0x2c8c <prvTimerTask+0xf6>
    2c8a:	55 c0       	rjmp	.+170    	; 0x2d36 <prvTimerTask+0x1a0>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    2c8c:	cc 80       	ldd	r12, Y+4	; 0x04
    2c8e:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    2c90:	f6 01       	movw	r30, r12
    2c92:	82 85       	ldd	r24, Z+10	; 0x0a
    2c94:	93 85       	ldd	r25, Z+11	; 0x0b
    2c96:	89 2b       	or	r24, r25
    2c98:	21 f0       	breq	.+8      	; 0x2ca2 <prvTimerTask+0x10c>
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2c9a:	c6 01       	movw	r24, r12
    2c9c:	02 96       	adiw	r24, 0x02	; 2
    2c9e:	0e 94 0f 0c 	call	0x181e	; 0x181e <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    2ca2:	ce 01       	movw	r24, r28
    2ca4:	06 96       	adiw	r24, 0x06	; 6
    2ca6:	09 df       	rcall	.-494    	; 0x2aba <prvSampleTimeNow>
    2ca8:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    2caa:	09 81       	ldd	r16, Y+1	; 0x01
    2cac:	00 2e       	mov	r0, r16
    2cae:	00 0c       	add	r0, r0
    2cb0:	11 0b       	sbc	r17, r17
    2cb2:	22 0b       	sbc	r18, r18
    2cb4:	33 0b       	sbc	r19, r19
    2cb6:	0a 30       	cpi	r16, 0x0A	; 10
    2cb8:	11 05       	cpc	r17, r1
    2cba:	08 f0       	brcs	.+2      	; 0x2cbe <prvTimerTask+0x128>
    2cbc:	3c c0       	rjmp	.+120    	; 0x2d36 <prvTimerTask+0x1a0>
    2cbe:	f8 01       	movw	r30, r16
    2cc0:	88 27       	eor	r24, r24
    2cc2:	e2 50       	subi	r30, 0x02	; 2
    2cc4:	ff 4f       	sbci	r31, 0xFF	; 255
    2cc6:	8f 4f       	sbci	r24, 0xFF	; 255
    2cc8:	54 c3       	rjmp	.+1704   	; 0x3372 <__tablejump2__>
			    case tmrCOMMAND_START_FROM_ISR :
			    case tmrCOMMAND_RESET :
			    case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) == pdTRUE )
    2cca:	2a 81       	ldd	r18, Y+2	; 0x02
    2ccc:	3b 81       	ldd	r19, Y+3	; 0x03
    2cce:	d6 01       	movw	r26, r12
    2cd0:	1c 96       	adiw	r26, 0x0c	; 12
    2cd2:	6d 91       	ld	r22, X+
    2cd4:	7c 91       	ld	r23, X
    2cd6:	1d 97       	sbiw	r26, 0x0d	; 13
    2cd8:	62 0f       	add	r22, r18
    2cda:	73 1f       	adc	r23, r19
    2cdc:	c6 01       	movw	r24, r12
    2cde:	f6 dd       	rcall	.-1044   	; 0x28cc <prvInsertTimerInActiveList>
    2ce0:	81 30       	cpi	r24, 0x01	; 1
    2ce2:	49 f5       	brne	.+82     	; 0x2d36 <prvTimerTask+0x1a0>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2ce4:	d6 01       	movw	r26, r12
    2ce6:	51 96       	adiw	r26, 0x11	; 17
    2ce8:	ed 91       	ld	r30, X+
    2cea:	fc 91       	ld	r31, X
    2cec:	52 97       	sbiw	r26, 0x12	; 18
    2cee:	c6 01       	movw	r24, r12
    2cf0:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( pxTimer->uxAutoReload == ( UBaseType_t ) pdTRUE )
    2cf2:	f6 01       	movw	r30, r12
    2cf4:	86 85       	ldd	r24, Z+14	; 0x0e
    2cf6:	81 30       	cpi	r24, 0x01	; 1
    2cf8:	f1 f4       	brne	.+60     	; 0x2d36 <prvTimerTask+0x1a0>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2cfa:	44 85       	ldd	r20, Z+12	; 0x0c
    2cfc:	55 85       	ldd	r21, Z+13	; 0x0d
    2cfe:	8a 81       	ldd	r24, Y+2	; 0x02
    2d00:	9b 81       	ldd	r25, Y+3	; 0x03
    2d02:	48 0f       	add	r20, r24
    2d04:	59 1f       	adc	r21, r25
    2d06:	00 e0       	ldi	r16, 0x00	; 0
    2d08:	10 e0       	ldi	r17, 0x00	; 0
    2d0a:	20 e0       	ldi	r18, 0x00	; 0
    2d0c:	30 e0       	ldi	r19, 0x00	; 0
    2d0e:	60 e0       	ldi	r22, 0x00	; 0
    2d10:	c6 01       	movw	r24, r12
    2d12:	91 de       	rcall	.-734    	; 0x2a36 <xTimerGenericCommand>
    2d14:	10 c0       	rjmp	.+32     	; 0x2d36 <prvTimerTask+0x1a0>
					There is nothing to do here. */
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2d16:	6a 81       	ldd	r22, Y+2	; 0x02
    2d18:	7b 81       	ldd	r23, Y+3	; 0x03
    2d1a:	d6 01       	movw	r26, r12
    2d1c:	1c 96       	adiw	r26, 0x0c	; 12
    2d1e:	6d 93       	st	X+, r22
    2d20:	7c 93       	st	X, r23
    2d22:	1d 97       	sbiw	r26, 0x0d	; 13
					longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot be
					zero the next expiry time can only be in the future, meaning
					(unlike for the xTimerStart() case above) there is no fail case
					that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    2d24:	64 0f       	add	r22, r20
    2d26:	75 1f       	adc	r23, r21
    2d28:	9a 01       	movw	r18, r20
    2d2a:	c6 01       	movw	r24, r12
    2d2c:	cf dd       	rcall	.-1122   	; 0x28cc <prvInsertTimerInActiveList>
    2d2e:	03 c0       	rjmp	.+6      	; 0x2d36 <prvTimerTask+0x1a0>
					break;

				case tmrCOMMAND_DELETE :
					/* The timer has already been removed from the active list,
					just free up the memory. */
					vPortFree( pxTimer );
    2d30:	c6 01       	movw	r24, r12
    2d32:	0e 94 b0 0d 	call	0x1b60	; 0x1b60 <vPortFree>
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2d36:	20 e0       	ldi	r18, 0x00	; 0
    2d38:	40 e0       	ldi	r20, 0x00	; 0
    2d3a:	50 e0       	ldi	r21, 0x00	; 0
    2d3c:	6e 2d       	mov	r22, r14
    2d3e:	7f 2d       	mov	r23, r15
    2d40:	80 91 b0 22 	lds	r24, 0x22B0
    2d44:	90 91 b1 22 	lds	r25, 0x22B1
    2d48:	ec d8       	rcall	.-3624   	; 0x1f22 <xQueueGenericReceive>
    2d4a:	81 11       	cpse	r24, r1
    2d4c:	9b cf       	rjmp	.-202    	; 0x2c84 <prvTimerTask+0xee>
    2d4e:	2e cf       	rjmp	.-420    	; 0x2bac <prvTimerTask+0x16>

00002d50 <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    2d50:	cf 93       	push	r28
    2d52:	df 93       	push	r29
    2d54:	fc 01       	movw	r30, r24
    2d56:	70 96       	adiw	r30, 0x10	; 16
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2d58:	20 e0       	ldi	r18, 0x00	; 0
    2d5a:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    2d5c:	c6 2f       	mov	r28, r22
    2d5e:	d0 e0       	ldi	r29, 0x00	; 0
    2d60:	de 01       	movw	r26, r28
    2d62:	02 2e       	mov	r0, r18
    2d64:	02 c0       	rjmp	.+4      	; 0x2d6a <ioport_configure_port_pin+0x1a>
    2d66:	b5 95       	asr	r27
    2d68:	a7 95       	ror	r26
    2d6a:	0a 94       	dec	r0
    2d6c:	e2 f7       	brpl	.-8      	; 0x2d66 <ioport_configure_port_pin+0x16>
    2d6e:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2d70:	50 83       	st	Z, r21
    2d72:	2f 5f       	subi	r18, 0xFF	; 255
    2d74:	3f 4f       	sbci	r19, 0xFF	; 255
    2d76:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    2d78:	28 30       	cpi	r18, 0x08	; 8
    2d7a:	31 05       	cpc	r19, r1
    2d7c:	89 f7       	brne	.-30     	; 0x2d60 <ioport_configure_port_pin+0x10>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    2d7e:	40 ff       	sbrs	r20, 0
    2d80:	0a c0       	rjmp	.+20     	; 0x2d96 <ioport_configure_port_pin+0x46>
		if (flags & IOPORT_INIT_HIGH) {
    2d82:	41 ff       	sbrs	r20, 1
    2d84:	03 c0       	rjmp	.+6      	; 0x2d8c <ioport_configure_port_pin+0x3c>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    2d86:	fc 01       	movw	r30, r24
    2d88:	65 83       	std	Z+5, r22	; 0x05
    2d8a:	02 c0       	rjmp	.+4      	; 0x2d90 <ioport_configure_port_pin+0x40>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    2d8c:	fc 01       	movw	r30, r24
    2d8e:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    2d90:	fc 01       	movw	r30, r24
    2d92:	61 83       	std	Z+1, r22	; 0x01
    2d94:	02 c0       	rjmp	.+4      	; 0x2d9a <ioport_configure_port_pin+0x4a>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    2d96:	fc 01       	movw	r30, r24
    2d98:	62 83       	std	Z+2, r22	; 0x02
	}
}
    2d9a:	df 91       	pop	r29
    2d9c:	cf 91       	pop	r28
    2d9e:	08 95       	ret

00002da0 <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    2da0:	43 e0       	ldi	r20, 0x03	; 3
    2da2:	50 e0       	ldi	r21, 0x00	; 0
    2da4:	61 e0       	ldi	r22, 0x01	; 1
    2da6:	80 ee       	ldi	r24, 0xE0	; 224
    2da8:	97 e0       	ldi	r25, 0x07	; 7
    2daa:	d2 df       	rcall	.-92     	; 0x2d50 <ioport_configure_port_pin>
    2dac:	43 e0       	ldi	r20, 0x03	; 3
    2dae:	50 e0       	ldi	r21, 0x00	; 0
    2db0:	62 e0       	ldi	r22, 0x02	; 2
    2db2:	80 ee       	ldi	r24, 0xE0	; 224
    2db4:	97 e0       	ldi	r25, 0x07	; 7
    2db6:	cc df       	rcall	.-104    	; 0x2d50 <ioport_configure_port_pin>
    2db8:	43 e0       	ldi	r20, 0x03	; 3
    2dba:	50 e0       	ldi	r21, 0x00	; 0
    2dbc:	60 e1       	ldi	r22, 0x10	; 16
    2dbe:	80 e6       	ldi	r24, 0x60	; 96
    2dc0:	96 e0       	ldi	r25, 0x06	; 6
    2dc2:	c6 df       	rcall	.-116    	; 0x2d50 <ioport_configure_port_pin>
    2dc4:	41 e0       	ldi	r20, 0x01	; 1
    2dc6:	50 e4       	ldi	r21, 0x40	; 64
    2dc8:	60 e2       	ldi	r22, 0x20	; 32
    2dca:	80 e6       	ldi	r24, 0x60	; 96
    2dcc:	96 e0       	ldi	r25, 0x06	; 6
    2dce:	c0 df       	rcall	.-128    	; 0x2d50 <ioport_configure_port_pin>
    2dd0:	40 e0       	ldi	r20, 0x00	; 0
    2dd2:	5b e1       	ldi	r21, 0x1B	; 27
    2dd4:	60 e2       	ldi	r22, 0x20	; 32
    2dd6:	80 e8       	ldi	r24, 0x80	; 128
    2dd8:	96 e0       	ldi	r25, 0x06	; 6
    2dda:	ba df       	rcall	.-140    	; 0x2d50 <ioport_configure_port_pin>
    2ddc:	40 e0       	ldi	r20, 0x00	; 0
    2dde:	5b e1       	ldi	r21, 0x1B	; 27
    2de0:	62 e0       	ldi	r22, 0x02	; 2
    2de2:	80 ea       	ldi	r24, 0xA0	; 160
    2de4:	96 e0       	ldi	r25, 0x06	; 6
    2de6:	b4 df       	rcall	.-152    	; 0x2d50 <ioport_configure_port_pin>
    2de8:	40 e0       	ldi	r20, 0x00	; 0
    2dea:	5b e1       	ldi	r21, 0x1B	; 27
    2dec:	64 e0       	ldi	r22, 0x04	; 4
    2dee:	80 ea       	ldi	r24, 0xA0	; 160
    2df0:	96 e0       	ldi	r25, 0x06	; 6
    2df2:	ae df       	rcall	.-164    	; 0x2d50 <ioport_configure_port_pin>
    2df4:	43 e0       	ldi	r20, 0x03	; 3
    2df6:	50 e0       	ldi	r21, 0x00	; 0
    2df8:	62 e0       	ldi	r22, 0x02	; 2
    2dfa:	80 e6       	ldi	r24, 0x60	; 96
    2dfc:	96 e0       	ldi	r25, 0x06	; 6
    2dfe:	a8 df       	rcall	.-176    	; 0x2d50 <ioport_configure_port_pin>
    2e00:	43 e0       	ldi	r20, 0x03	; 3
    2e02:	50 e0       	ldi	r21, 0x00	; 0
    2e04:	68 e0       	ldi	r22, 0x08	; 8
    2e06:	80 e6       	ldi	r24, 0x60	; 96
    2e08:	96 e0       	ldi	r25, 0x06	; 6
    2e0a:	a2 df       	rcall	.-188    	; 0x2d50 <ioport_configure_port_pin>
    2e0c:	43 e0       	ldi	r20, 0x03	; 3
    2e0e:	50 e0       	ldi	r21, 0x00	; 0
    2e10:	68 e0       	ldi	r22, 0x08	; 8
    2e12:	80 ea       	ldi	r24, 0xA0	; 160
    2e14:	96 e0       	ldi	r25, 0x06	; 6
    2e16:	9c df       	rcall	.-200    	; 0x2d50 <ioport_configure_port_pin>
    2e18:	43 e0       	ldi	r20, 0x03	; 3
    2e1a:	50 e0       	ldi	r21, 0x00	; 0
    2e1c:	61 e0       	ldi	r22, 0x01	; 1
    2e1e:	80 e6       	ldi	r24, 0x60	; 96
    2e20:	96 e0       	ldi	r25, 0x06	; 6
    2e22:	96 df       	rcall	.-212    	; 0x2d50 <ioport_configure_port_pin>
    2e24:	43 e0       	ldi	r20, 0x03	; 3
    2e26:	50 e0       	ldi	r21, 0x00	; 0
    2e28:	68 e0       	ldi	r22, 0x08	; 8
    2e2a:	80 e0       	ldi	r24, 0x00	; 0
    2e2c:	96 e0       	ldi	r25, 0x06	; 6
    2e2e:	90 df       	rcall	.-224    	; 0x2d50 <ioport_configure_port_pin>
    2e30:	41 e0       	ldi	r20, 0x01	; 1
    2e32:	50 e0       	ldi	r21, 0x00	; 0
    2e34:	60 e1       	ldi	r22, 0x10	; 16
    2e36:	80 e8       	ldi	r24, 0x80	; 128
    2e38:	96 e0       	ldi	r25, 0x06	; 6
    2e3a:	8a df       	rcall	.-236    	; 0x2d50 <ioport_configure_port_pin>
    2e3c:	43 e0       	ldi	r20, 0x03	; 3
    2e3e:	50 e0       	ldi	r21, 0x00	; 0
    2e40:	62 e0       	ldi	r22, 0x02	; 2
    2e42:	80 e6       	ldi	r24, 0x60	; 96
    2e44:	96 e0       	ldi	r25, 0x06	; 6
    2e46:	84 df       	rcall	.-248    	; 0x2d50 <ioport_configure_port_pin>
    2e48:	43 e0       	ldi	r20, 0x03	; 3
    2e4a:	50 e0       	ldi	r21, 0x00	; 0
    2e4c:	68 e0       	ldi	r22, 0x08	; 8
    2e4e:	80 e6       	ldi	r24, 0x60	; 96
    2e50:	96 e0       	ldi	r25, 0x06	; 6
    2e52:	7e df       	rcall	.-260    	; 0x2d50 <ioport_configure_port_pin>
    2e54:	40 e0       	ldi	r20, 0x00	; 0
    2e56:	50 e0       	ldi	r21, 0x00	; 0
    2e58:	64 e0       	ldi	r22, 0x04	; 4
    2e5a:	80 e6       	ldi	r24, 0x60	; 96
    2e5c:	96 e0       	ldi	r25, 0x06	; 6
    2e5e:	78 df       	rcall	.-272    	; 0x2d50 <ioport_configure_port_pin>
    2e60:	43 e0       	ldi	r20, 0x03	; 3
    2e62:	50 e0       	ldi	r21, 0x00	; 0
    2e64:	60 e1       	ldi	r22, 0x10	; 16
    2e66:	80 ea       	ldi	r24, 0xA0	; 160
    2e68:	96 e0       	ldi	r25, 0x06	; 6
    2e6a:	72 df       	rcall	.-284    	; 0x2d50 <ioport_configure_port_pin>
    2e6c:	40 e0       	ldi	r20, 0x00	; 0
    2e6e:	50 e0       	ldi	r21, 0x00	; 0
    2e70:	61 e0       	ldi	r22, 0x01	; 1
    2e72:	80 e0       	ldi	r24, 0x00	; 0
    2e74:	96 e0       	ldi	r25, 0x06	; 6
    2e76:	6c df       	rcall	.-296    	; 0x2d50 <ioport_configure_port_pin>
    2e78:	40 e0       	ldi	r20, 0x00	; 0
    2e7a:	50 e0       	ldi	r21, 0x00	; 0
    2e7c:	64 e0       	ldi	r22, 0x04	; 4
    2e7e:	80 e0       	ldi	r24, 0x00	; 0
    2e80:	96 e0       	ldi	r25, 0x06	; 6
    2e82:	66 df       	rcall	.-308    	; 0x2d50 <ioport_configure_port_pin>
    2e84:	40 e0       	ldi	r20, 0x00	; 0
    2e86:	50 e0       	ldi	r21, 0x00	; 0
    2e88:	62 e0       	ldi	r22, 0x02	; 2
    2e8a:	80 e2       	ldi	r24, 0x20	; 32
    2e8c:	96 e0       	ldi	r25, 0x06	; 6
    2e8e:	60 df       	rcall	.-320    	; 0x2d50 <ioport_configure_port_pin>
    2e90:	43 e0       	ldi	r20, 0x03	; 3
    2e92:	50 e0       	ldi	r21, 0x00	; 0
    2e94:	68 e0       	ldi	r22, 0x08	; 8
    2e96:	80 e4       	ldi	r24, 0x40	; 64
    2e98:	96 e0       	ldi	r25, 0x06	; 6
    2e9a:	5a df       	rcall	.-332    	; 0x2d50 <ioport_configure_port_pin>
    2e9c:	40 e0       	ldi	r20, 0x00	; 0
    2e9e:	50 e0       	ldi	r21, 0x00	; 0
    2ea0:	64 e0       	ldi	r22, 0x04	; 4
    2ea2:	80 e4       	ldi	r24, 0x40	; 64
    2ea4:	96 e0       	ldi	r25, 0x06	; 6
    2ea6:	54 df       	rcall	.-344    	; 0x2d50 <ioport_configure_port_pin>
    2ea8:	43 e0       	ldi	r20, 0x03	; 3
    2eaa:	50 e0       	ldi	r21, 0x00	; 0
    2eac:	68 e0       	ldi	r22, 0x08	; 8
    2eae:	80 e6       	ldi	r24, 0x60	; 96
    2eb0:	96 e0       	ldi	r25, 0x06	; 6
    2eb2:	4e df       	rcall	.-356    	; 0x2d50 <ioport_configure_port_pin>
    2eb4:	40 e0       	ldi	r20, 0x00	; 0
    2eb6:	50 e0       	ldi	r21, 0x00	; 0
    2eb8:	64 e0       	ldi	r22, 0x04	; 4
    2eba:	80 e6       	ldi	r24, 0x60	; 96
    2ebc:	96 e0       	ldi	r25, 0x06	; 6
    2ebe:	48 df       	rcall	.-368    	; 0x2d50 <ioport_configure_port_pin>
    2ec0:	43 e0       	ldi	r20, 0x03	; 3
    2ec2:	50 e0       	ldi	r21, 0x00	; 0
    2ec4:	68 e0       	ldi	r22, 0x08	; 8
    2ec6:	80 e8       	ldi	r24, 0x80	; 128
    2ec8:	96 e0       	ldi	r25, 0x06	; 6
    2eca:	42 df       	rcall	.-380    	; 0x2d50 <ioport_configure_port_pin>
    2ecc:	40 e0       	ldi	r20, 0x00	; 0
    2ece:	50 e0       	ldi	r21, 0x00	; 0
    2ed0:	64 e0       	ldi	r22, 0x04	; 4
    2ed2:	80 e8       	ldi	r24, 0x80	; 128
    2ed4:	96 e0       	ldi	r25, 0x06	; 6
    2ed6:	3c cf       	rjmp	.-392    	; 0x2d50 <ioport_configure_port_pin>
    2ed8:	08 95       	ret

00002eda <vTimerCallback>:
static portTASK_FUNCTION_PROTO(testTempS, p_);
static portTASK_FUNCTION_PROTO(testServo, p_);
static portTASK_FUNCTION_PROTO(testPot, p_);

void vTimerCallback(){
	increment++;
    2eda:	80 91 91 23 	lds	r24, 0x2391
    2ede:	90 91 92 23 	lds	r25, 0x2392
    2ee2:	a0 91 93 23 	lds	r26, 0x2393
    2ee6:	b0 91 94 23 	lds	r27, 0x2394
    2eea:	01 96       	adiw	r24, 0x01	; 1
    2eec:	a1 1d       	adc	r26, r1
    2eee:	b1 1d       	adc	r27, r1
    2ef0:	80 93 91 23 	sts	0x2391, r24
    2ef4:	90 93 92 23 	sts	0x2392, r25
    2ef8:	a0 93 93 23 	sts	0x2393, r26
    2efc:	b0 93 94 23 	sts	0x2394, r27
    2f00:	08 95       	ret

00002f02 <testLamp>:
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2f02:	c0 ee       	ldi	r28, 0xE0	; 224
    2f04:	d7 e0       	ldi	r29, 0x07	; 7
    2f06:	11 e0       	ldi	r17, 0x01	; 1
    2f08:	01 2f       	mov	r16, r17
    2f0a:	0e 83       	std	Y+6, r16	; 0x06
static portTASK_FUNCTION(testLamp, p_){
	//ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, false);
	
	while(1){
		gpio_set_pin_low(LED0_GPIO);
		vTaskDelay(100/portTICK_PERIOD_MS);
    2f0c:	82 e3       	ldi	r24, 0x32	; 50
    2f0e:	90 e0       	ldi	r25, 0x00	; 0
    2f10:	8a db       	rcall	.-2284   	; 0x2626 <vTaskDelay>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2f12:	1d 83       	std	Y+5, r17	; 0x05
		gpio_set_pin_high(LED0_GPIO);
		vTaskDelay(100/portTICK_PERIOD_MS);
    2f14:	82 e3       	ldi	r24, 0x32	; 50
    2f16:	90 e0       	ldi	r25, 0x00	; 0
    2f18:	86 db       	rcall	.-2292   	; 0x2626 <vTaskDelay>
	}
    2f1a:	f7 cf       	rjmp	.-18     	; 0x2f0a <testLamp+0x8>

00002f1c <testPot>:
	return result;
}

static uint16_t adc_read3(){
	uint16_t result;
	adc_enable(&MY_ADC3);
    2f1c:	c0 e0       	ldi	r28, 0x00	; 0
    2f1e:	d2 e0       	ldi	r29, 0x02	; 2
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2f20:	68 94       	set
    2f22:	ff 24       	eor	r15, r15
    2f24:	f2 f8       	bld	r15, 2
	adc_start_conversion(&MY_ADC3, MY_ADC3_CH);
	adc_wait_for_interrupt_flag(&MY_ADC3, MY_ADC3_CH);
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
    2f26:	00 e3       	ldi	r16, 0x30	; 48
    2f28:	12 e0       	ldi	r17, 0x02	; 2
	return result;
}

static uint16_t adc_read3(){
	uint16_t result;
	adc_enable(&MY_ADC3);
    2f2a:	ce 01       	movw	r24, r28
    2f2c:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2f30:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    2f32:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    2f34:	88 81       	ld	r24, Y
    2f36:	80 61       	ori	r24, 0x10	; 16
    2f38:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2f3a:	9f bf       	out	0x3f, r25	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    2f3c:	9e 81       	ldd	r25, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    2f3e:	92 ff       	sbrs	r25, 2
    2f40:	fd cf       	rjmp	.-6      	; 0x2f3c <testPot+0x20>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2f42:	fe 82       	std	Y+6, r15	; 0x06
	adc_start_conversion(&MY_ADC3, MY_ADC3_CH);
	adc_wait_for_interrupt_flag(&MY_ADC3, MY_ADC3_CH);
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
    2f44:	f8 01       	movw	r30, r16
    2f46:	84 81       	ldd	r24, Z+4	; 0x04
    2f48:	95 81       	ldd	r25, Z+5	; 0x05
	}
}

static portTASK_FUNCTION(testPot, p_){
	while(1){
		result3 = adc_read3();
    2f4a:	80 93 95 23 	sts	0x2395, r24
    2f4e:	90 93 96 23 	sts	0x2396, r25
		vTaskDelay(10/portTICK_PERIOD_MS);
    2f52:	85 e0       	ldi	r24, 0x05	; 5
    2f54:	90 e0       	ldi	r25, 0x00	; 0
    2f56:	67 db       	rcall	.-2354   	; 0x2626 <vTaskDelay>
	}
    2f58:	e8 cf       	rjmp	.-48     	; 0x2f2a <testPot+0xe>

00002f5a <testTempS>:
	return result;
}

static uint16_t adc_read2(){
	uint16_t result;
	adc_enable(&MY_ADC2);
    2f5a:	c0 e0       	ldi	r28, 0x00	; 0
    2f5c:	d2 e0       	ldi	r29, 0x02	; 2
    2f5e:	68 94       	set
    2f60:	ff 24       	eor	r15, r15
    2f62:	f1 f8       	bld	r15, 1
	adc_start_conversion(&MY_ADC2, MY_ADC2_CH);
	adc_wait_for_interrupt_flag(&MY_ADC2, MY_ADC2_CH);
	result = adc_get_result(&MY_ADC2, MY_ADC2_CH);
    2f64:	08 e2       	ldi	r16, 0x28	; 40
    2f66:	12 e0       	ldi	r17, 0x02	; 2
	return result;
}

static uint16_t adc_read2(){
	uint16_t result;
	adc_enable(&MY_ADC2);
    2f68:	ce 01       	movw	r24, r28
    2f6a:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2f6e:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    2f70:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    2f72:	88 81       	ld	r24, Y
    2f74:	88 60       	ori	r24, 0x08	; 8
    2f76:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2f78:	9f bf       	out	0x3f, r25	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    2f7a:	9e 81       	ldd	r25, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    2f7c:	91 ff       	sbrs	r25, 1
    2f7e:	fd cf       	rjmp	.-6      	; 0x2f7a <testTempS+0x20>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2f80:	fe 82       	std	Y+6, r15	; 0x06
	adc_start_conversion(&MY_ADC2, MY_ADC2_CH);
	adc_wait_for_interrupt_flag(&MY_ADC2, MY_ADC2_CH);
	result = adc_get_result(&MY_ADC2, MY_ADC2_CH);
    2f82:	f8 01       	movw	r30, r16
    2f84:	84 81       	ldd	r24, Z+4	; 0x04
    2f86:	95 81       	ldd	r25, Z+5	; 0x05
	}
}

static portTASK_FUNCTION(testTempS, p_){
	while(1){
		result2 = adc_read2();
    2f88:	80 93 97 23 	sts	0x2397, r24
    2f8c:	90 93 98 23 	sts	0x2398, r25
		vTaskDelay(10/portTICK_PERIOD_MS);
    2f90:	85 e0       	ldi	r24, 0x05	; 5
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	48 db       	rcall	.-2416   	; 0x2626 <vTaskDelay>
	}
    2f96:	e8 cf       	rjmp	.-48     	; 0x2f68 <testTempS+0xe>

00002f98 <testLightS>:
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
}

static uint16_t adc_read(){
	uint16_t result;
	adc_enable(&MY_ADC);
    2f98:	c0 e0       	ldi	r28, 0x00	; 0
    2f9a:	d2 e0       	ldi	r29, 0x02	; 2
    2f9c:	11 e0       	ldi	r17, 0x01	; 1
    2f9e:	ce 01       	movw	r24, r28
    2fa0:	0e 94 46 07 	call	0xe8c	; 0xe8c <adc_enable>

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	irqflags_t flags = SREG;
    2fa4:	9f b7       	in	r25, 0x3f	; 63
	cpu_irq_disable();
    2fa6:	f8 94       	cli
 */
static inline void adc_start_conversion(ADC_t *adc, uint8_t ch_mask)
{
	irqflags_t flags = cpu_irq_save();
#if !XMEGA_E
	adc->CTRLA |= ch_mask << ADC_CH0START_bp;
    2fa8:	88 81       	ld	r24, Y
    2faa:	84 60       	ori	r24, 0x04	; 4
    2fac:	88 83       	st	Y, r24
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2fae:	9f bf       	out	0x3f, r25	; 63
 *
 * \return Mask with interrupt flags.
 */
static inline uint8_t adc_get_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	return (adc->INTFLAGS >> ADC_CH0IF_bp) & ch_mask;
    2fb0:	9e 81       	ldd	r25, Y+6	; 0x06
 * \arg \c ADC_CHn , where \c n specifies the channel. (These can be OR'ed
 * together.)
 */
static inline void adc_wait_for_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	do { } while (adc_get_interrupt_flag(adc, ch_mask) != ch_mask);
    2fb2:	90 ff       	sbrs	r25, 0
    2fb4:	fd cf       	rjmp	.-6      	; 0x2fb0 <testLightS+0x18>
 *
 * \note The ADC must be enabled for this function to have any effect.
 */
static inline void adc_clear_interrupt_flag(ADC_t *adc, uint8_t ch_mask)
{
	adc->INTFLAGS = ch_mask << ADC_CH0IF_bp;
    2fb6:	1e 83       	std	Y+6, r17	; 0x06
	adc_start_conversion(&MY_ADC, MY_ADC_CH);
	adc_wait_for_interrupt_flag(&MY_ADC, MY_ADC_CH);
	result = adc_get_result(&MY_ADC, MY_ADC_CH);
    2fb8:	8c a1       	ldd	r24, Y+36	; 0x24
    2fba:	9d a1       	ldd	r25, Y+37	; 0x25
	}
}

static portTASK_FUNCTION(testLightS, p_){
	while(1){
		result = adc_read();
    2fbc:	80 93 99 23 	sts	0x2399, r24
    2fc0:	90 93 9a 23 	sts	0x239A, r25
		vTaskDelay(10/portTICK_PERIOD_MS);
    2fc4:	85 e0       	ldi	r24, 0x05	; 5
    2fc6:	90 e0       	ldi	r25, 0x00	; 0
    2fc8:	2e db       	rcall	.-2468   	; 0x2626 <vTaskDelay>
	}
    2fca:	e9 cf       	rjmp	.-46     	; 0x2f9e <testLightS+0x6>

00002fcc <testLCD>:
    2fcc:	80 e1       	ldi	r24, 0x10	; 16
    2fce:	80 93 85 06 	sts	0x0685, r24
static portTASK_FUNCTION(testLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	while(1){
		
		//print light
		snprintf(strbuf, sizeof(strbuf), "Read Light : %3d",result);
    2fd2:	0f 2e       	mov	r0, r31
    2fd4:	fa e1       	ldi	r31, 0x1A	; 26
    2fd6:	af 2e       	mov	r10, r31
    2fd8:	f0 e2       	ldi	r31, 0x20	; 32
    2fda:	bf 2e       	mov	r11, r31
    2fdc:	f0 2d       	mov	r31, r0
    2fde:	19 ec       	ldi	r17, 0xC9	; 201
    2fe0:	c8 ec       	ldi	r28, 0xC8	; 200
    2fe2:	d2 e2       	ldi	r29, 0x22	; 34
		gfx_mono_draw_string(strbuf,0, 0, &sysfont);
		
		//print temp
		snprintf(strbuf, sizeof(strbuf), "Read Temp : %3d",result2);
    2fe4:	0f 2e       	mov	r0, r31
    2fe6:	fb e2       	ldi	r31, 0x2B	; 43
    2fe8:	cf 2e       	mov	r12, r31
    2fea:	f0 e2       	ldi	r31, 0x20	; 32
    2fec:	df 2e       	mov	r13, r31
    2fee:	f0 2d       	mov	r31, r0
		gfx_mono_draw_string(strbuf,0, 10, &sysfont);
		
		//print timer
		//snprintf(strbuf, sizeof(strbuf), "Timer : %3d",increment);
		snprintf(strbuf, sizeof(strbuf), "Read Pot : %3d",result3);
    2ff0:	0f 2e       	mov	r0, r31
    2ff2:	fb e3       	ldi	r31, 0x3B	; 59
    2ff4:	ef 2e       	mov	r14, r31
    2ff6:	f0 e2       	ldi	r31, 0x20	; 32
    2ff8:	ff 2e       	mov	r15, r31
    2ffa:	f0 2d       	mov	r31, r0
static portTASK_FUNCTION(testLCD, p_){
	ioport_set_pin_level(LCD_BACKLIGHT_ENABLE_PIN, 1);
	while(1){
		
		//print light
		snprintf(strbuf, sizeof(strbuf), "Read Light : %3d",result);
    2ffc:	80 91 9a 23 	lds	r24, 0x239A
    3000:	8f 93       	push	r24
    3002:	80 91 99 23 	lds	r24, 0x2399
    3006:	8f 93       	push	r24
    3008:	bf 92       	push	r11
    300a:	af 92       	push	r10
    300c:	1f 92       	push	r1
    300e:	1f 93       	push	r17
    3010:	df 93       	push	r29
    3012:	cf 93       	push	r28
    3014:	ec d2       	rcall	.+1496   	; 0x35ee <snprintf>
		gfx_mono_draw_string(strbuf,0, 0, &sysfont);
    3016:	26 e0       	ldi	r18, 0x06	; 6
    3018:	30 e2       	ldi	r19, 0x20	; 32
    301a:	40 e0       	ldi	r20, 0x00	; 0
    301c:	60 e0       	ldi	r22, 0x00	; 0
    301e:	ce 01       	movw	r24, r28
    3020:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
		
		//print temp
		snprintf(strbuf, sizeof(strbuf), "Read Temp : %3d",result2);
    3024:	80 91 98 23 	lds	r24, 0x2398
    3028:	8f 93       	push	r24
    302a:	80 91 97 23 	lds	r24, 0x2397
    302e:	8f 93       	push	r24
    3030:	df 92       	push	r13
    3032:	cf 92       	push	r12
    3034:	1f 92       	push	r1
    3036:	1f 93       	push	r17
    3038:	df 93       	push	r29
    303a:	cf 93       	push	r28
    303c:	d8 d2       	rcall	.+1456   	; 0x35ee <snprintf>
		gfx_mono_draw_string(strbuf,0, 10, &sysfont);
    303e:	26 e0       	ldi	r18, 0x06	; 6
    3040:	30 e2       	ldi	r19, 0x20	; 32
    3042:	4a e0       	ldi	r20, 0x0A	; 10
    3044:	60 e0       	ldi	r22, 0x00	; 0
    3046:	ce 01       	movw	r24, r28
    3048:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
		
		//print timer
		//snprintf(strbuf, sizeof(strbuf), "Timer : %3d",increment);
		snprintf(strbuf, sizeof(strbuf), "Read Pot : %3d",result3);
    304c:	80 91 96 23 	lds	r24, 0x2396
    3050:	8f 93       	push	r24
    3052:	80 91 95 23 	lds	r24, 0x2395
    3056:	8f 93       	push	r24
    3058:	ff 92       	push	r15
    305a:	ef 92       	push	r14
    305c:	1f 92       	push	r1
    305e:	1f 93       	push	r17
    3060:	df 93       	push	r29
    3062:	cf 93       	push	r28
    3064:	c4 d2       	rcall	.+1416   	; 0x35ee <snprintf>
		gfx_mono_draw_string(strbuf,0, 20, &sysfont);
    3066:	26 e0       	ldi	r18, 0x06	; 6
    3068:	30 e2       	ldi	r19, 0x20	; 32
    306a:	44 e1       	ldi	r20, 0x14	; 20
    306c:	60 e0       	ldi	r22, 0x00	; 0
    306e:	ce 01       	movw	r24, r28
    3070:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <gfx_mono_draw_string>
		
		vTaskDelay(5/portTICK_PERIOD_MS);
    3074:	82 e0       	ldi	r24, 0x02	; 2
    3076:	90 e0       	ldi	r25, 0x00	; 0
    3078:	d6 da       	rcall	.-2644   	; 0x2626 <vTaskDelay>
	}
    307a:	8d b7       	in	r24, 0x3d	; 61
    307c:	9e b7       	in	r25, 0x3e	; 62
    307e:	48 96       	adiw	r24, 0x18	; 24
    3080:	8d bf       	out	0x3d, r24	; 61
    3082:	9e bf       	out	0x3e, r25	; 62
    3084:	bb cf       	rjmp	.-138    	; 0x2ffc <testLCD+0x30>

00003086 <PWM_Init>:
}

void PWM_Init(void)
{
	/* Set output */
	PORTC.DIR |= PIN0_bm;
    3086:	e0 e4       	ldi	r30, 0x40	; 64
    3088:	f6 e0       	ldi	r31, 0x06	; 6
    308a:	80 81       	ld	r24, Z
    308c:	81 60       	ori	r24, 0x01	; 1
    308e:	80 83       	st	Z, r24

	/* Set Register */
	TCC0.CTRLA = (PIN2_bm) | (PIN0_bm);
    3090:	e0 e0       	ldi	r30, 0x00	; 0
    3092:	f8 e0       	ldi	r31, 0x08	; 8
    3094:	85 e0       	ldi	r24, 0x05	; 5
    3096:	80 83       	st	Z, r24
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);
    3098:	86 e1       	ldi	r24, 0x16	; 22
    309a:	81 83       	std	Z+1, r24	; 0x01
	
	/* Set Period */
	TCC0.PER = 1000;
    309c:	88 ee       	ldi	r24, 0xE8	; 232
    309e:	93 e0       	ldi	r25, 0x03	; 3
    30a0:	86 a3       	std	Z+38, r24	; 0x26
    30a2:	97 a3       	std	Z+39, r25	; 0x27

	/* Set Compare Register value*/
	TCC0.CCA = 375;
    30a4:	87 e7       	ldi	r24, 0x77	; 119
    30a6:	91 e0       	ldi	r25, 0x01	; 1
    30a8:	80 a7       	std	Z+40, r24	; 0x28
    30aa:	91 a7       	std	Z+41, r25	; 0x29
    30ac:	08 95       	ret

000030ae <testServo>:
	}
}


static portTASK_FUNCTION(testServo, p_){
	PWM_Init();
    30ae:	eb df       	rcall	.-42     	; 0x3086 <PWM_Init>

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    30b0:	e0 ea       	ldi	r30, 0xA0	; 160
    30b2:	f6 e0       	ldi	r31, 0x06	; 6
			TCC0.CCA = 1;
			gpio_set_pin_low(LED3_GPIO);
			gpio_set_pin_high(LED2_GPIO);
			door = 2;
		}else if(gpio_pin_is_high(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
			TCC0.CCA = 350;
    30b4:	c0 e0       	ldi	r28, 0x00	; 0
    30b6:	d8 e0       	ldi	r29, 0x08	; 8
    30b8:	6e e5       	ldi	r22, 0x5E	; 94
    30ba:	71 e0       	ldi	r23, 0x01	; 1
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    30bc:	a0 e6       	ldi	r26, 0x60	; 96
    30be:	b6 e0       	ldi	r27, 0x06	; 6
    30c0:	10 e2       	ldi	r17, 0x20	; 32
    30c2:	90 e1       	ldi	r25, 0x10	; 16
			TCC0.CCA = 130;
			gpio_set_pin_low(LED2_GPIO);
			gpio_set_pin_high(LED3_GPIO);
			door = 1;
		}else if(gpio_pin_is_low(GPIO_PUSH_BUTTON_2) && gpio_pin_is_high(GPIO_PUSH_BUTTON_1)){
			TCC0.CCA = 1;
    30c4:	41 e0       	ldi	r20, 0x01	; 1
    30c6:	50 e0       	ldi	r21, 0x00	; 0
	PWM_Init();
	
	while(1){
		if(gpio_pin_is_low(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
			//delay_ms(50);
			TCC0.CCA = 130;
    30c8:	22 e8       	ldi	r18, 0x82	; 130
    30ca:	30 e0       	ldi	r19, 0x00	; 0

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    30cc:	80 85       	ldd	r24, Z+8	; 0x08

static portTASK_FUNCTION(testServo, p_){
	PWM_Init();
	
	while(1){
		if(gpio_pin_is_low(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
    30ce:	81 fd       	sbrc	r24, 1
    30d0:	0c c0       	rjmp	.+24     	; 0x30ea <testServo+0x3c>
    30d2:	80 85       	ldd	r24, Z+8	; 0x08
    30d4:	82 ff       	sbrs	r24, 2
    30d6:	09 c0       	rjmp	.+18     	; 0x30ea <testServo+0x3c>
			//delay_ms(50);
			TCC0.CCA = 130;
    30d8:	28 a7       	std	Y+40, r18	; 0x28
    30da:	39 a7       	std	Y+41, r19	; 0x29
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    30dc:	16 96       	adiw	r26, 0x06	; 6
    30de:	9c 93       	st	X, r25
    30e0:	16 97       	sbiw	r26, 0x06	; 6
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    30e2:	15 96       	adiw	r26, 0x05	; 5
    30e4:	1c 93       	st	X, r17
    30e6:	15 97       	sbiw	r26, 0x05	; 5
			gpio_set_pin_low(LED2_GPIO);
			gpio_set_pin_high(LED3_GPIO);
			door = 1;
    30e8:	f1 cf       	rjmp	.-30     	; 0x30cc <testServo+0x1e>

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    30ea:	80 85       	ldd	r24, Z+8	; 0x08
		}else if(gpio_pin_is_low(GPIO_PUSH_BUTTON_2) && gpio_pin_is_high(GPIO_PUSH_BUTTON_1)){
    30ec:	82 fd       	sbrc	r24, 2
    30ee:	0c c0       	rjmp	.+24     	; 0x3108 <testServo+0x5a>
    30f0:	80 85       	ldd	r24, Z+8	; 0x08
    30f2:	81 ff       	sbrs	r24, 1
    30f4:	09 c0       	rjmp	.+18     	; 0x3108 <testServo+0x5a>
			TCC0.CCA = 1;
    30f6:	48 a7       	std	Y+40, r20	; 0x28
    30f8:	59 a7       	std	Y+41, r21	; 0x29
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    30fa:	16 96       	adiw	r26, 0x06	; 6
    30fc:	1c 93       	st	X, r17
    30fe:	16 97       	sbiw	r26, 0x06	; 6
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3100:	15 96       	adiw	r26, 0x05	; 5
    3102:	9c 93       	st	X, r25
    3104:	15 97       	sbiw	r26, 0x05	; 5
			gpio_set_pin_low(LED3_GPIO);
			gpio_set_pin_high(LED2_GPIO);
			door = 2;
    3106:	e2 cf       	rjmp	.-60     	; 0x30cc <testServo+0x1e>

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    3108:	80 85       	ldd	r24, Z+8	; 0x08
		}else if(gpio_pin_is_high(GPIO_PUSH_BUTTON_1) && gpio_pin_is_high(GPIO_PUSH_BUTTON_2)){
    310a:	81 ff       	sbrs	r24, 1
    310c:	df cf       	rjmp	.-66     	; 0x30cc <testServo+0x1e>
    310e:	80 85       	ldd	r24, Z+8	; 0x08
    3110:	82 ff       	sbrs	r24, 2
    3112:	dc cf       	rjmp	.-72     	; 0x30cc <testServo+0x1e>
			TCC0.CCA = 350;
    3114:	68 a7       	std	Y+40, r22	; 0x28
    3116:	79 a7       	std	Y+41, r23	; 0x29
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    3118:	15 96       	adiw	r26, 0x05	; 5
    311a:	1c 93       	st	X, r17
    311c:	15 97       	sbiw	r26, 0x05	; 5
    311e:	15 96       	adiw	r26, 0x05	; 5
    3120:	9c 93       	st	X, r25
    3122:	15 97       	sbiw	r26, 0x05	; 5
    3124:	d3 cf       	rjmp	.-90     	; 0x30cc <testServo+0x1e>

00003126 <main>:
	result = adc_get_result(&MY_ADC3, MY_ADC3_CH);
	return result;
}

int main (void)
{
    3126:	8f 92       	push	r8
    3128:	9f 92       	push	r9
    312a:	af 92       	push	r10
    312c:	bf 92       	push	r11
    312e:	cf 92       	push	r12
    3130:	df 92       	push	r13
    3132:	ef 92       	push	r14
    3134:	ff 92       	push	r15
    3136:	0f 93       	push	r16
    3138:	1f 93       	push	r17
    313a:	cf 93       	push	r28
    313c:	df 93       	push	r29
    313e:	cd b7       	in	r28, 0x3d	; 61
    3140:	de b7       	in	r29, 0x3e	; 62
    3142:	2b 97       	sbiw	r28, 0x0b	; 11
    3144:	cd bf       	out	0x3d, r28	; 61
    3146:	de bf       	out	0x3e, r29	; 62
	// Insert system clock initialization code here (sysclk_init()).

	
	board_init();
    3148:	2b de       	rcall	.-938    	; 0x2da0 <board_init>
 * Enables all interrupt levels, with vectors located in the application section
 * and fixed priority scheduling.
 */
static inline void pmic_init(void)
{
	PMIC.CTRL = PMIC_LVL_LOW | PMIC_LVL_MEDIUM |
    314a:	87 e0       	ldi	r24, 0x07	; 7
    314c:	80 93 a2 00 	sts	0x00A2, r24
static void adc_init(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC, &adc_conf);
    3150:	be 01       	movw	r22, r28
    3152:	6f 5f       	subi	r22, 0xFF	; 255
    3154:	7f 4f       	sbci	r23, 0xFF	; 255
    3156:	80 e0       	ldi	r24, 0x00	; 0
    3158:	92 e0       	ldi	r25, 0x02	; 2
    315a:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    315e:	ae 01       	movw	r20, r28
    3160:	48 5f       	subi	r20, 0xF8	; 248
    3162:	5f 4f       	sbci	r21, 0xFF	; 255
    3164:	61 e0       	ldi	r22, 0x01	; 1
    3166:	80 e0       	ldi	r24, 0x00	; 0
    3168:	92 e0       	ldi	r25, 0x02	; 2
    316a:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    316e:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    3170:	8b 81       	ldd	r24, Y+3	; 0x03
    3172:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    3174:	80 61       	ori	r24, 0x10	; 16
    3176:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3178:	89 2f       	mov	r24, r25
    317a:	81 7e       	andi	r24, 0xE1	; 225
    317c:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    317e:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    3180:	02 e0       	ldi	r16, 0x02	; 2
    3182:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3184:	11 e0       	ldi	r17, 0x01	; 1
    3186:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3188:	19 86       	std	Y+9, r1	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN0, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC, &adc_conf);
    318a:	be 01       	movw	r22, r28
    318c:	6f 5f       	subi	r22, 0xFF	; 255
    318e:	7f 4f       	sbci	r23, 0xFF	; 255
    3190:	80 e0       	ldi	r24, 0x00	; 0
    3192:	92 e0       	ldi	r25, 0x02	; 2
    3194:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC, MY_ADC_CH, &adcch_conf);
    3198:	ae 01       	movw	r20, r28
    319a:	48 5f       	subi	r20, 0xF8	; 248
    319c:	5f 4f       	sbci	r21, 0xFF	; 255
    319e:	61 e0       	ldi	r22, 0x01	; 1
    31a0:	80 e0       	ldi	r24, 0x00	; 0
    31a2:	92 e0       	ldi	r25, 0x02	; 2
    31a4:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
static void adc_init2(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC2, &adc_conf);
    31a8:	be 01       	movw	r22, r28
    31aa:	6f 5f       	subi	r22, 0xFF	; 255
    31ac:	7f 4f       	sbci	r23, 0xFF	; 255
    31ae:	80 e0       	ldi	r24, 0x00	; 0
    31b0:	92 e0       	ldi	r25, 0x02	; 2
    31b2:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    31b6:	ae 01       	movw	r20, r28
    31b8:	48 5f       	subi	r20, 0xF8	; 248
    31ba:	5f 4f       	sbci	r21, 0xFF	; 255
    31bc:	62 e0       	ldi	r22, 0x02	; 2
    31be:	80 e0       	ldi	r24, 0x00	; 0
    31c0:	92 e0       	ldi	r25, 0x02	; 2
    31c2:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    31c6:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    31c8:	8b 81       	ldd	r24, Y+3	; 0x03
    31ca:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    31cc:	80 61       	ori	r24, 0x10	; 16
    31ce:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    31d0:	89 2f       	mov	r24, r25
    31d2:	81 7e       	andi	r24, 0xE1	; 225
    31d4:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    31d6:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    31d8:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    31da:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    31dc:	88 e0       	ldi	r24, 0x08	; 8
    31de:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN1, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC2, &adc_conf);
    31e0:	be 01       	movw	r22, r28
    31e2:	6f 5f       	subi	r22, 0xFF	; 255
    31e4:	7f 4f       	sbci	r23, 0xFF	; 255
    31e6:	80 e0       	ldi	r24, 0x00	; 0
    31e8:	92 e0       	ldi	r25, 0x02	; 2
    31ea:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC2, MY_ADC2_CH, &adcch_conf);
    31ee:	ae 01       	movw	r20, r28
    31f0:	48 5f       	subi	r20, 0xF8	; 248
    31f2:	5f 4f       	sbci	r21, 0xFF	; 255
    31f4:	62 e0       	ldi	r22, 0x02	; 2
    31f6:	80 e0       	ldi	r24, 0x00	; 0
    31f8:	92 e0       	ldi	r25, 0x02	; 2
    31fa:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
static void adc_init3(void)
{
	struct adc_config adc_conf;
	struct adc_channel_config adcch_conf;

	adc_read_configuration(&MY_ADC3, &adc_conf);
    31fe:	be 01       	movw	r22, r28
    3200:	6f 5f       	subi	r22, 0xFF	; 255
    3202:	7f 4f       	sbci	r23, 0xFF	; 255
    3204:	80 e0       	ldi	r24, 0x00	; 0
    3206:	92 e0       	ldi	r25, 0x02	; 2
    3208:	0e 94 3d 09 	call	0x127a	; 0x127a <adc_read_configuration>
	adcch_read_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    320c:	ae 01       	movw	r20, r28
    320e:	48 5f       	subi	r20, 0xF8	; 248
    3210:	5f 4f       	sbci	r21, 0xFF	; 255
    3212:	64 e0       	ldi	r22, 0x04	; 4
    3214:	80 e0       	ldi	r24, 0x00	; 0
    3216:	92 e0       	ldi	r25, 0x02	; 2
    3218:	0e 94 99 09 	call	0x1332	; 0x1332 <adcch_read_configuration>
static inline void adc_set_conversion_parameters(struct adc_config *conf,
		enum adc_sign sign, enum adc_resolution res,
		enum adc_reference ref)
{
	/* Preserve all but conversion and resolution config. */
	conf->ctrlb &= ~(ADC_CONMODE_bm | ADC_RESOLUTION_gm);
    321c:	9a 81       	ldd	r25, Y+2	; 0x02
	conf->ctrlb |= (uint8_t)res | (uint8_t)sign;

	conf->refctrl &= ~ADC_REFSEL_gm;
    321e:	8b 81       	ldd	r24, Y+3	; 0x03
    3220:	8f 78       	andi	r24, 0x8F	; 143
	conf->refctrl |= ref;
    3222:	80 61       	ori	r24, 0x10	; 16
    3224:	8b 83       	std	Y+3, r24	; 0x03
	Assert(base_ev_ch <= 3);
#endif

	switch (trig) {
	case ADC_TRIG_MANUAL:
		conf->ctrlb &= ~ADC_FREERUN_bm;
    3226:	89 2f       	mov	r24, r25
    3228:	81 7e       	andi	r24, 0xE1	; 225
    322a:	8a 83       	std	Y+2, r24	; 0x02
		conf->evctrl = ADC_EVACT_NONE_gc;
    322c:	1c 82       	std	Y+4, r1	; 0x04
		psc = ADC_PRESCALER_DIV256_gc;
	} else {
		psc = ADC_PRESCALER_DIV512_gc;
	}

	conf->prescaler = psc;
    322e:	0d 83       	std	Y+5, r16	; 0x05
				ADC_CH_MUXPOS_gp;
	} else if (neg == ADCCH_NEG_NONE) {
		/* Configure for single-ended measurement. */
		Assert(gain == 1);

		ch_conf->ctrl = ADC_CH_INPUTMODE_SINGLEENDED_gc;
    3230:	18 87       	std	Y+8, r17	; 0x08
		ch_conf->muxctrl = pos << ADC_CH_MUXPOS_gp;
    3232:	80 e1       	ldi	r24, 0x10	; 16
    3234:	89 87       	std	Y+9, r24	; 0x09
	adc_set_conversion_trigger(&adc_conf, ADC_TRIG_MANUAL, 1, 0);
	adc_set_clock_rate(&adc_conf, 200000UL);

	adcch_set_input(&adcch_conf, J3_PIN2, ADCCH_NEG_NONE, 1);

	adc_write_configuration(&MY_ADC3, &adc_conf);
    3236:	be 01       	movw	r22, r28
    3238:	6f 5f       	subi	r22, 0xFF	; 255
    323a:	7f 4f       	sbci	r23, 0xFF	; 255
    323c:	80 e0       	ldi	r24, 0x00	; 0
    323e:	92 e0       	ldi	r25, 0x02	; 2
    3240:	0e 94 ed 08 	call	0x11da	; 0x11da <adc_write_configuration>
	adcch_write_configuration(&MY_ADC3, MY_ADC3_CH, &adcch_conf);
    3244:	ae 01       	movw	r20, r28
    3246:	48 5f       	subi	r20, 0xF8	; 248
    3248:	5f 4f       	sbci	r21, 0xFF	; 255
    324a:	64 e0       	ldi	r22, 0x04	; 4
    324c:	80 e0       	ldi	r24, 0x00	; 0
    324e:	92 e0       	ldi	r25, 0x02	; 2
    3250:	0e 94 60 09 	call	0x12c0	; 0x12c0 <adcch_write_configuration>
	
	
	adc_init();
	adc_init2();
	adc_init3();
	gfx_mono_init();
    3254:	0e 94 e7 04 	call	0x9ce	; 0x9ce <gfx_mono_st7565r_init>
	
	TimerHandle_t timerPing = xTimerCreate("tPing", 2/portTICK_PERIOD_MS, pdTRUE, (void *) 0, vTimerCallback);
    3258:	0d e6       	ldi	r16, 0x6D	; 109
    325a:	17 e1       	ldi	r17, 0x17	; 23
    325c:	20 e0       	ldi	r18, 0x00	; 0
    325e:	30 e0       	ldi	r19, 0x00	; 0
    3260:	41 e0       	ldi	r20, 0x01	; 1
    3262:	61 e0       	ldi	r22, 0x01	; 1
    3264:	70 e0       	ldi	r23, 0x00	; 0
    3266:	8a e4       	ldi	r24, 0x4A	; 74
    3268:	90 e2       	ldi	r25, 0x20	; 32
    326a:	af db       	rcall	.-2210   	; 0x29ca <xTimerCreate>
    326c:	4c 01       	movw	r8, r24
	
	xTaskCreate(testLamp,"",500,NULL,1,NULL);
    326e:	a1 2c       	mov	r10, r1
    3270:	b1 2c       	mov	r11, r1
    3272:	c1 2c       	mov	r12, r1
    3274:	d1 2c       	mov	r13, r1
    3276:	e1 2c       	mov	r14, r1
    3278:	f1 2c       	mov	r15, r1
    327a:	01 e0       	ldi	r16, 0x01	; 1
    327c:	20 e0       	ldi	r18, 0x00	; 0
    327e:	30 e0       	ldi	r19, 0x00	; 0
    3280:	44 ef       	ldi	r20, 0xF4	; 244
    3282:	51 e0       	ldi	r21, 0x01	; 1
    3284:	61 e1       	ldi	r22, 0x11	; 17
    3286:	70 e2       	ldi	r23, 0x20	; 32
    3288:	81 e8       	ldi	r24, 0x81	; 129
    328a:	97 e1       	ldi	r25, 0x17	; 23
    328c:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskGenericCreate>
	xTaskCreate(testLCD,"",500,NULL,1,NULL);
    3290:	20 e0       	ldi	r18, 0x00	; 0
    3292:	30 e0       	ldi	r19, 0x00	; 0
    3294:	44 ef       	ldi	r20, 0xF4	; 244
    3296:	51 e0       	ldi	r21, 0x01	; 1
    3298:	61 e1       	ldi	r22, 0x11	; 17
    329a:	70 e2       	ldi	r23, 0x20	; 32
    329c:	86 ee       	ldi	r24, 0xE6	; 230
    329e:	97 e1       	ldi	r25, 0x17	; 23
    32a0:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskGenericCreate>
	xTaskCreate(testLightS,"",500,NULL,1,NULL);
    32a4:	20 e0       	ldi	r18, 0x00	; 0
    32a6:	30 e0       	ldi	r19, 0x00	; 0
    32a8:	44 ef       	ldi	r20, 0xF4	; 244
    32aa:	51 e0       	ldi	r21, 0x01	; 1
    32ac:	61 e1       	ldi	r22, 0x11	; 17
    32ae:	70 e2       	ldi	r23, 0x20	; 32
    32b0:	8c ec       	ldi	r24, 0xCC	; 204
    32b2:	97 e1       	ldi	r25, 0x17	; 23
    32b4:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskGenericCreate>
	xTaskCreate(testTempS,"",500,NULL,1,NULL);
    32b8:	20 e0       	ldi	r18, 0x00	; 0
    32ba:	30 e0       	ldi	r19, 0x00	; 0
    32bc:	44 ef       	ldi	r20, 0xF4	; 244
    32be:	51 e0       	ldi	r21, 0x01	; 1
    32c0:	61 e1       	ldi	r22, 0x11	; 17
    32c2:	70 e2       	ldi	r23, 0x20	; 32
    32c4:	8d ea       	ldi	r24, 0xAD	; 173
    32c6:	97 e1       	ldi	r25, 0x17	; 23
    32c8:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskGenericCreate>
	xTaskCreate(testServo,"",500,NULL,1,NULL);
    32cc:	20 e0       	ldi	r18, 0x00	; 0
    32ce:	30 e0       	ldi	r19, 0x00	; 0
    32d0:	44 ef       	ldi	r20, 0xF4	; 244
    32d2:	51 e0       	ldi	r21, 0x01	; 1
    32d4:	61 e1       	ldi	r22, 0x11	; 17
    32d6:	70 e2       	ldi	r23, 0x20	; 32
    32d8:	87 e5       	ldi	r24, 0x57	; 87
    32da:	98 e1       	ldi	r25, 0x18	; 24
    32dc:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskGenericCreate>
	xTaskCreate(testPot,"",500,NULL,1,NULL);
    32e0:	20 e0       	ldi	r18, 0x00	; 0
    32e2:	30 e0       	ldi	r19, 0x00	; 0
    32e4:	44 ef       	ldi	r20, 0xF4	; 244
    32e6:	51 e0       	ldi	r21, 0x01	; 1
    32e8:	61 e1       	ldi	r22, 0x11	; 17
    32ea:	70 e2       	ldi	r23, 0x20	; 32
    32ec:	8e e8       	ldi	r24, 0x8E	; 142
    32ee:	97 e1       	ldi	r25, 0x17	; 23
    32f0:	0e 94 7f 10 	call	0x20fe	; 0x20fe <xTaskGenericCreate>
	
	xTimerStart(timerPing, 0);
    32f4:	3e d8       	rcall	.-3972   	; 0x2372 <xTaskGetTickCount>
    32f6:	00 e0       	ldi	r16, 0x00	; 0
    32f8:	10 e0       	ldi	r17, 0x00	; 0
    32fa:	20 e0       	ldi	r18, 0x00	; 0
    32fc:	30 e0       	ldi	r19, 0x00	; 0
    32fe:	ac 01       	movw	r20, r24
    3300:	61 e0       	ldi	r22, 0x01	; 1
    3302:	c4 01       	movw	r24, r8
    3304:	98 db       	rcall	.-2256   	; 0x2a36 <xTimerGenericCommand>
	
	vTaskStartScheduler();
    3306:	0e 94 80 11 	call	0x2300	; 0x2300 <vTaskStartScheduler>

	// Insert application code here, after the board has been initialized.
}
    330a:	80 e0       	ldi	r24, 0x00	; 0
    330c:	90 e0       	ldi	r25, 0x00	; 0
    330e:	2b 96       	adiw	r28, 0x0b	; 11
    3310:	cd bf       	out	0x3d, r28	; 61
    3312:	de bf       	out	0x3e, r29	; 62
    3314:	df 91       	pop	r29
    3316:	cf 91       	pop	r28
    3318:	1f 91       	pop	r17
    331a:	0f 91       	pop	r16
    331c:	ff 90       	pop	r15
    331e:	ef 90       	pop	r14
    3320:	df 90       	pop	r13
    3322:	cf 90       	pop	r12
    3324:	bf 90       	pop	r11
    3326:	af 90       	pop	r10
    3328:	9f 90       	pop	r9
    332a:	8f 90       	pop	r8
    332c:	08 95       	ret

0000332e <__udivmodsi4>:
    332e:	a1 e2       	ldi	r26, 0x21	; 33
    3330:	1a 2e       	mov	r1, r26
    3332:	aa 1b       	sub	r26, r26
    3334:	bb 1b       	sub	r27, r27
    3336:	fd 01       	movw	r30, r26
    3338:	0d c0       	rjmp	.+26     	; 0x3354 <__udivmodsi4_ep>

0000333a <__udivmodsi4_loop>:
    333a:	aa 1f       	adc	r26, r26
    333c:	bb 1f       	adc	r27, r27
    333e:	ee 1f       	adc	r30, r30
    3340:	ff 1f       	adc	r31, r31
    3342:	a2 17       	cp	r26, r18
    3344:	b3 07       	cpc	r27, r19
    3346:	e4 07       	cpc	r30, r20
    3348:	f5 07       	cpc	r31, r21
    334a:	20 f0       	brcs	.+8      	; 0x3354 <__udivmodsi4_ep>
    334c:	a2 1b       	sub	r26, r18
    334e:	b3 0b       	sbc	r27, r19
    3350:	e4 0b       	sbc	r30, r20
    3352:	f5 0b       	sbc	r31, r21

00003354 <__udivmodsi4_ep>:
    3354:	66 1f       	adc	r22, r22
    3356:	77 1f       	adc	r23, r23
    3358:	88 1f       	adc	r24, r24
    335a:	99 1f       	adc	r25, r25
    335c:	1a 94       	dec	r1
    335e:	69 f7       	brne	.-38     	; 0x333a <__udivmodsi4_loop>
    3360:	60 95       	com	r22
    3362:	70 95       	com	r23
    3364:	80 95       	com	r24
    3366:	90 95       	com	r25
    3368:	9b 01       	movw	r18, r22
    336a:	ac 01       	movw	r20, r24
    336c:	bd 01       	movw	r22, r26
    336e:	cf 01       	movw	r24, r30
    3370:	08 95       	ret

00003372 <__tablejump2__>:
    3372:	ee 0f       	add	r30, r30
    3374:	ff 1f       	adc	r31, r31
    3376:	88 1f       	adc	r24, r24
    3378:	8b bf       	out	0x3b, r24	; 59
    337a:	07 90       	elpm	r0, Z+
    337c:	f6 91       	elpm	r31, Z
    337e:	e0 2d       	mov	r30, r0
    3380:	19 94       	eijmp

00003382 <malloc>:
    3382:	cf 93       	push	r28
    3384:	df 93       	push	r29
    3386:	82 30       	cpi	r24, 0x02	; 2
    3388:	91 05       	cpc	r25, r1
    338a:	10 f4       	brcc	.+4      	; 0x3390 <malloc+0xe>
    338c:	82 e0       	ldi	r24, 0x02	; 2
    338e:	90 e0       	ldi	r25, 0x00	; 0
    3390:	e0 91 a7 23 	lds	r30, 0x23A7
    3394:	f0 91 a8 23 	lds	r31, 0x23A8
    3398:	20 e0       	ldi	r18, 0x00	; 0
    339a:	30 e0       	ldi	r19, 0x00	; 0
    339c:	c0 e0       	ldi	r28, 0x00	; 0
    339e:	d0 e0       	ldi	r29, 0x00	; 0
    33a0:	30 97       	sbiw	r30, 0x00	; 0
    33a2:	11 f1       	breq	.+68     	; 0x33e8 <malloc+0x66>
    33a4:	40 81       	ld	r20, Z
    33a6:	51 81       	ldd	r21, Z+1	; 0x01
    33a8:	48 17       	cp	r20, r24
    33aa:	59 07       	cpc	r21, r25
    33ac:	c0 f0       	brcs	.+48     	; 0x33de <malloc+0x5c>
    33ae:	48 17       	cp	r20, r24
    33b0:	59 07       	cpc	r21, r25
    33b2:	61 f4       	brne	.+24     	; 0x33cc <malloc+0x4a>
    33b4:	82 81       	ldd	r24, Z+2	; 0x02
    33b6:	93 81       	ldd	r25, Z+3	; 0x03
    33b8:	20 97       	sbiw	r28, 0x00	; 0
    33ba:	19 f0       	breq	.+6      	; 0x33c2 <malloc+0x40>
    33bc:	8a 83       	std	Y+2, r24	; 0x02
    33be:	9b 83       	std	Y+3, r25	; 0x03
    33c0:	2b c0       	rjmp	.+86     	; 0x3418 <malloc+0x96>
    33c2:	80 93 a7 23 	sts	0x23A7, r24
    33c6:	90 93 a8 23 	sts	0x23A8, r25
    33ca:	26 c0       	rjmp	.+76     	; 0x3418 <malloc+0x96>
    33cc:	21 15       	cp	r18, r1
    33ce:	31 05       	cpc	r19, r1
    33d0:	19 f0       	breq	.+6      	; 0x33d8 <malloc+0x56>
    33d2:	42 17       	cp	r20, r18
    33d4:	53 07       	cpc	r21, r19
    33d6:	18 f4       	brcc	.+6      	; 0x33de <malloc+0x5c>
    33d8:	9a 01       	movw	r18, r20
    33da:	be 01       	movw	r22, r28
    33dc:	df 01       	movw	r26, r30
    33de:	ef 01       	movw	r28, r30
    33e0:	02 80       	ldd	r0, Z+2	; 0x02
    33e2:	f3 81       	ldd	r31, Z+3	; 0x03
    33e4:	e0 2d       	mov	r30, r0
    33e6:	dc cf       	rjmp	.-72     	; 0x33a0 <malloc+0x1e>
    33e8:	21 15       	cp	r18, r1
    33ea:	31 05       	cpc	r19, r1
    33ec:	09 f1       	breq	.+66     	; 0x3430 <malloc+0xae>
    33ee:	28 1b       	sub	r18, r24
    33f0:	39 0b       	sbc	r19, r25
    33f2:	24 30       	cpi	r18, 0x04	; 4
    33f4:	31 05       	cpc	r19, r1
    33f6:	90 f4       	brcc	.+36     	; 0x341c <malloc+0x9a>
    33f8:	12 96       	adiw	r26, 0x02	; 2
    33fa:	8d 91       	ld	r24, X+
    33fc:	9c 91       	ld	r25, X
    33fe:	13 97       	sbiw	r26, 0x03	; 3
    3400:	61 15       	cp	r22, r1
    3402:	71 05       	cpc	r23, r1
    3404:	21 f0       	breq	.+8      	; 0x340e <malloc+0x8c>
    3406:	fb 01       	movw	r30, r22
    3408:	82 83       	std	Z+2, r24	; 0x02
    340a:	93 83       	std	Z+3, r25	; 0x03
    340c:	04 c0       	rjmp	.+8      	; 0x3416 <malloc+0x94>
    340e:	80 93 a7 23 	sts	0x23A7, r24
    3412:	90 93 a8 23 	sts	0x23A8, r25
    3416:	fd 01       	movw	r30, r26
    3418:	32 96       	adiw	r30, 0x02	; 2
    341a:	44 c0       	rjmp	.+136    	; 0x34a4 <malloc+0x122>
    341c:	fd 01       	movw	r30, r26
    341e:	e2 0f       	add	r30, r18
    3420:	f3 1f       	adc	r31, r19
    3422:	81 93       	st	Z+, r24
    3424:	91 93       	st	Z+, r25
    3426:	22 50       	subi	r18, 0x02	; 2
    3428:	31 09       	sbc	r19, r1
    342a:	2d 93       	st	X+, r18
    342c:	3c 93       	st	X, r19
    342e:	3a c0       	rjmp	.+116    	; 0x34a4 <malloc+0x122>
    3430:	20 91 a5 23 	lds	r18, 0x23A5
    3434:	30 91 a6 23 	lds	r19, 0x23A6
    3438:	23 2b       	or	r18, r19
    343a:	41 f4       	brne	.+16     	; 0x344c <malloc+0xca>
    343c:	20 91 02 20 	lds	r18, 0x2002
    3440:	30 91 03 20 	lds	r19, 0x2003
    3444:	20 93 a5 23 	sts	0x23A5, r18
    3448:	30 93 a6 23 	sts	0x23A6, r19
    344c:	20 91 00 20 	lds	r18, 0x2000
    3450:	30 91 01 20 	lds	r19, 0x2001
    3454:	21 15       	cp	r18, r1
    3456:	31 05       	cpc	r19, r1
    3458:	41 f4       	brne	.+16     	; 0x346a <malloc+0xe8>
    345a:	2d b7       	in	r18, 0x3d	; 61
    345c:	3e b7       	in	r19, 0x3e	; 62
    345e:	40 91 04 20 	lds	r20, 0x2004
    3462:	50 91 05 20 	lds	r21, 0x2005
    3466:	24 1b       	sub	r18, r20
    3468:	35 0b       	sbc	r19, r21
    346a:	e0 91 a5 23 	lds	r30, 0x23A5
    346e:	f0 91 a6 23 	lds	r31, 0x23A6
    3472:	e2 17       	cp	r30, r18
    3474:	f3 07       	cpc	r31, r19
    3476:	a0 f4       	brcc	.+40     	; 0x34a0 <malloc+0x11e>
    3478:	2e 1b       	sub	r18, r30
    347a:	3f 0b       	sbc	r19, r31
    347c:	28 17       	cp	r18, r24
    347e:	39 07       	cpc	r19, r25
    3480:	78 f0       	brcs	.+30     	; 0x34a0 <malloc+0x11e>
    3482:	ac 01       	movw	r20, r24
    3484:	4e 5f       	subi	r20, 0xFE	; 254
    3486:	5f 4f       	sbci	r21, 0xFF	; 255
    3488:	24 17       	cp	r18, r20
    348a:	35 07       	cpc	r19, r21
    348c:	48 f0       	brcs	.+18     	; 0x34a0 <malloc+0x11e>
    348e:	4e 0f       	add	r20, r30
    3490:	5f 1f       	adc	r21, r31
    3492:	40 93 a5 23 	sts	0x23A5, r20
    3496:	50 93 a6 23 	sts	0x23A6, r21
    349a:	81 93       	st	Z+, r24
    349c:	91 93       	st	Z+, r25
    349e:	02 c0       	rjmp	.+4      	; 0x34a4 <malloc+0x122>
    34a0:	e0 e0       	ldi	r30, 0x00	; 0
    34a2:	f0 e0       	ldi	r31, 0x00	; 0
    34a4:	cf 01       	movw	r24, r30
    34a6:	df 91       	pop	r29
    34a8:	cf 91       	pop	r28
    34aa:	08 95       	ret

000034ac <free>:
    34ac:	0f 93       	push	r16
    34ae:	1f 93       	push	r17
    34b0:	cf 93       	push	r28
    34b2:	df 93       	push	r29
    34b4:	00 97       	sbiw	r24, 0x00	; 0
    34b6:	09 f4       	brne	.+2      	; 0x34ba <free+0xe>
    34b8:	8c c0       	rjmp	.+280    	; 0x35d2 <free+0x126>
    34ba:	fc 01       	movw	r30, r24
    34bc:	32 97       	sbiw	r30, 0x02	; 2
    34be:	12 82       	std	Z+2, r1	; 0x02
    34c0:	13 82       	std	Z+3, r1	; 0x03
    34c2:	00 91 a7 23 	lds	r16, 0x23A7
    34c6:	10 91 a8 23 	lds	r17, 0x23A8
    34ca:	01 15       	cp	r16, r1
    34cc:	11 05       	cpc	r17, r1
    34ce:	81 f4       	brne	.+32     	; 0x34f0 <free+0x44>
    34d0:	20 81       	ld	r18, Z
    34d2:	31 81       	ldd	r19, Z+1	; 0x01
    34d4:	82 0f       	add	r24, r18
    34d6:	93 1f       	adc	r25, r19
    34d8:	20 91 a5 23 	lds	r18, 0x23A5
    34dc:	30 91 a6 23 	lds	r19, 0x23A6
    34e0:	28 17       	cp	r18, r24
    34e2:	39 07       	cpc	r19, r25
    34e4:	79 f5       	brne	.+94     	; 0x3544 <free+0x98>
    34e6:	e0 93 a5 23 	sts	0x23A5, r30
    34ea:	f0 93 a6 23 	sts	0x23A6, r31
    34ee:	71 c0       	rjmp	.+226    	; 0x35d2 <free+0x126>
    34f0:	d8 01       	movw	r26, r16
    34f2:	40 e0       	ldi	r20, 0x00	; 0
    34f4:	50 e0       	ldi	r21, 0x00	; 0
    34f6:	ae 17       	cp	r26, r30
    34f8:	bf 07       	cpc	r27, r31
    34fa:	50 f4       	brcc	.+20     	; 0x3510 <free+0x64>
    34fc:	12 96       	adiw	r26, 0x02	; 2
    34fe:	2d 91       	ld	r18, X+
    3500:	3c 91       	ld	r19, X
    3502:	13 97       	sbiw	r26, 0x03	; 3
    3504:	ad 01       	movw	r20, r26
    3506:	21 15       	cp	r18, r1
    3508:	31 05       	cpc	r19, r1
    350a:	09 f1       	breq	.+66     	; 0x354e <free+0xa2>
    350c:	d9 01       	movw	r26, r18
    350e:	f3 cf       	rjmp	.-26     	; 0x34f6 <free+0x4a>
    3510:	9d 01       	movw	r18, r26
    3512:	da 01       	movw	r26, r20
    3514:	22 83       	std	Z+2, r18	; 0x02
    3516:	33 83       	std	Z+3, r19	; 0x03
    3518:	60 81       	ld	r22, Z
    351a:	71 81       	ldd	r23, Z+1	; 0x01
    351c:	86 0f       	add	r24, r22
    351e:	97 1f       	adc	r25, r23
    3520:	82 17       	cp	r24, r18
    3522:	93 07       	cpc	r25, r19
    3524:	69 f4       	brne	.+26     	; 0x3540 <free+0x94>
    3526:	ec 01       	movw	r28, r24
    3528:	28 81       	ld	r18, Y
    352a:	39 81       	ldd	r19, Y+1	; 0x01
    352c:	26 0f       	add	r18, r22
    352e:	37 1f       	adc	r19, r23
    3530:	2e 5f       	subi	r18, 0xFE	; 254
    3532:	3f 4f       	sbci	r19, 0xFF	; 255
    3534:	20 83       	st	Z, r18
    3536:	31 83       	std	Z+1, r19	; 0x01
    3538:	8a 81       	ldd	r24, Y+2	; 0x02
    353a:	9b 81       	ldd	r25, Y+3	; 0x03
    353c:	82 83       	std	Z+2, r24	; 0x02
    353e:	93 83       	std	Z+3, r25	; 0x03
    3540:	45 2b       	or	r20, r21
    3542:	29 f4       	brne	.+10     	; 0x354e <free+0xa2>
    3544:	e0 93 a7 23 	sts	0x23A7, r30
    3548:	f0 93 a8 23 	sts	0x23A8, r31
    354c:	42 c0       	rjmp	.+132    	; 0x35d2 <free+0x126>
    354e:	12 96       	adiw	r26, 0x02	; 2
    3550:	ed 93       	st	X+, r30
    3552:	fc 93       	st	X, r31
    3554:	13 97       	sbiw	r26, 0x03	; 3
    3556:	ed 01       	movw	r28, r26
    3558:	49 91       	ld	r20, Y+
    355a:	59 91       	ld	r21, Y+
    355c:	9e 01       	movw	r18, r28
    355e:	24 0f       	add	r18, r20
    3560:	35 1f       	adc	r19, r21
    3562:	e2 17       	cp	r30, r18
    3564:	f3 07       	cpc	r31, r19
    3566:	71 f4       	brne	.+28     	; 0x3584 <free+0xd8>
    3568:	80 81       	ld	r24, Z
    356a:	91 81       	ldd	r25, Z+1	; 0x01
    356c:	84 0f       	add	r24, r20
    356e:	95 1f       	adc	r25, r21
    3570:	02 96       	adiw	r24, 0x02	; 2
    3572:	8d 93       	st	X+, r24
    3574:	9c 93       	st	X, r25
    3576:	11 97       	sbiw	r26, 0x01	; 1
    3578:	82 81       	ldd	r24, Z+2	; 0x02
    357a:	93 81       	ldd	r25, Z+3	; 0x03
    357c:	12 96       	adiw	r26, 0x02	; 2
    357e:	8d 93       	st	X+, r24
    3580:	9c 93       	st	X, r25
    3582:	13 97       	sbiw	r26, 0x03	; 3
    3584:	e0 e0       	ldi	r30, 0x00	; 0
    3586:	f0 e0       	ldi	r31, 0x00	; 0
    3588:	d8 01       	movw	r26, r16
    358a:	12 96       	adiw	r26, 0x02	; 2
    358c:	8d 91       	ld	r24, X+
    358e:	9c 91       	ld	r25, X
    3590:	13 97       	sbiw	r26, 0x03	; 3
    3592:	00 97       	sbiw	r24, 0x00	; 0
    3594:	19 f0       	breq	.+6      	; 0x359c <free+0xf0>
    3596:	f8 01       	movw	r30, r16
    3598:	8c 01       	movw	r16, r24
    359a:	f6 cf       	rjmp	.-20     	; 0x3588 <free+0xdc>
    359c:	8d 91       	ld	r24, X+
    359e:	9c 91       	ld	r25, X
    35a0:	98 01       	movw	r18, r16
    35a2:	2e 5f       	subi	r18, 0xFE	; 254
    35a4:	3f 4f       	sbci	r19, 0xFF	; 255
    35a6:	82 0f       	add	r24, r18
    35a8:	93 1f       	adc	r25, r19
    35aa:	20 91 a5 23 	lds	r18, 0x23A5
    35ae:	30 91 a6 23 	lds	r19, 0x23A6
    35b2:	28 17       	cp	r18, r24
    35b4:	39 07       	cpc	r19, r25
    35b6:	69 f4       	brne	.+26     	; 0x35d2 <free+0x126>
    35b8:	30 97       	sbiw	r30, 0x00	; 0
    35ba:	29 f4       	brne	.+10     	; 0x35c6 <free+0x11a>
    35bc:	10 92 a7 23 	sts	0x23A7, r1
    35c0:	10 92 a8 23 	sts	0x23A8, r1
    35c4:	02 c0       	rjmp	.+4      	; 0x35ca <free+0x11e>
    35c6:	12 82       	std	Z+2, r1	; 0x02
    35c8:	13 82       	std	Z+3, r1	; 0x03
    35ca:	00 93 a5 23 	sts	0x23A5, r16
    35ce:	10 93 a6 23 	sts	0x23A6, r17
    35d2:	df 91       	pop	r29
    35d4:	cf 91       	pop	r28
    35d6:	1f 91       	pop	r17
    35d8:	0f 91       	pop	r16
    35da:	08 95       	ret

000035dc <memcpy>:
    35dc:	fb 01       	movw	r30, r22
    35de:	dc 01       	movw	r26, r24
    35e0:	02 c0       	rjmp	.+4      	; 0x35e6 <memcpy+0xa>
    35e2:	01 90       	ld	r0, Z+
    35e4:	0d 92       	st	X+, r0
    35e6:	41 50       	subi	r20, 0x01	; 1
    35e8:	50 40       	sbci	r21, 0x00	; 0
    35ea:	d8 f7       	brcc	.-10     	; 0x35e2 <memcpy+0x6>
    35ec:	08 95       	ret

000035ee <snprintf>:
    35ee:	0f 93       	push	r16
    35f0:	1f 93       	push	r17
    35f2:	cf 93       	push	r28
    35f4:	df 93       	push	r29
    35f6:	cd b7       	in	r28, 0x3d	; 61
    35f8:	de b7       	in	r29, 0x3e	; 62
    35fa:	2e 97       	sbiw	r28, 0x0e	; 14
    35fc:	cd bf       	out	0x3d, r28	; 61
    35fe:	de bf       	out	0x3e, r29	; 62
    3600:	0e 89       	ldd	r16, Y+22	; 0x16
    3602:	1f 89       	ldd	r17, Y+23	; 0x17
    3604:	88 8d       	ldd	r24, Y+24	; 0x18
    3606:	99 8d       	ldd	r25, Y+25	; 0x19
    3608:	26 e0       	ldi	r18, 0x06	; 6
    360a:	2c 83       	std	Y+4, r18	; 0x04
    360c:	09 83       	std	Y+1, r16	; 0x01
    360e:	1a 83       	std	Y+2, r17	; 0x02
    3610:	97 ff       	sbrs	r25, 7
    3612:	02 c0       	rjmp	.+4      	; 0x3618 <snprintf+0x2a>
    3614:	80 e0       	ldi	r24, 0x00	; 0
    3616:	90 e8       	ldi	r25, 0x80	; 128
    3618:	01 97       	sbiw	r24, 0x01	; 1
    361a:	8d 83       	std	Y+5, r24	; 0x05
    361c:	9e 83       	std	Y+6, r25	; 0x06
    361e:	ae 01       	movw	r20, r28
    3620:	44 5e       	subi	r20, 0xE4	; 228
    3622:	5f 4f       	sbci	r21, 0xFF	; 255
    3624:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3626:	7b 8d       	ldd	r23, Y+27	; 0x1b
    3628:	ce 01       	movw	r24, r28
    362a:	01 96       	adiw	r24, 0x01	; 1
    362c:	16 d0       	rcall	.+44     	; 0x365a <vfprintf>
    362e:	4d 81       	ldd	r20, Y+5	; 0x05
    3630:	5e 81       	ldd	r21, Y+6	; 0x06
    3632:	57 fd       	sbrc	r21, 7
    3634:	0a c0       	rjmp	.+20     	; 0x364a <snprintf+0x5c>
    3636:	2f 81       	ldd	r18, Y+7	; 0x07
    3638:	38 85       	ldd	r19, Y+8	; 0x08
    363a:	42 17       	cp	r20, r18
    363c:	53 07       	cpc	r21, r19
    363e:	0c f4       	brge	.+2      	; 0x3642 <snprintf+0x54>
    3640:	9a 01       	movw	r18, r20
    3642:	f8 01       	movw	r30, r16
    3644:	e2 0f       	add	r30, r18
    3646:	f3 1f       	adc	r31, r19
    3648:	10 82       	st	Z, r1
    364a:	2e 96       	adiw	r28, 0x0e	; 14
    364c:	cd bf       	out	0x3d, r28	; 61
    364e:	de bf       	out	0x3e, r29	; 62
    3650:	df 91       	pop	r29
    3652:	cf 91       	pop	r28
    3654:	1f 91       	pop	r17
    3656:	0f 91       	pop	r16
    3658:	08 95       	ret

0000365a <vfprintf>:
    365a:	2f 92       	push	r2
    365c:	3f 92       	push	r3
    365e:	4f 92       	push	r4
    3660:	5f 92       	push	r5
    3662:	6f 92       	push	r6
    3664:	7f 92       	push	r7
    3666:	8f 92       	push	r8
    3668:	9f 92       	push	r9
    366a:	af 92       	push	r10
    366c:	bf 92       	push	r11
    366e:	cf 92       	push	r12
    3670:	df 92       	push	r13
    3672:	ef 92       	push	r14
    3674:	ff 92       	push	r15
    3676:	0f 93       	push	r16
    3678:	1f 93       	push	r17
    367a:	cf 93       	push	r28
    367c:	df 93       	push	r29
    367e:	cd b7       	in	r28, 0x3d	; 61
    3680:	de b7       	in	r29, 0x3e	; 62
    3682:	2c 97       	sbiw	r28, 0x0c	; 12
    3684:	cd bf       	out	0x3d, r28	; 61
    3686:	de bf       	out	0x3e, r29	; 62
    3688:	7c 01       	movw	r14, r24
    368a:	6b 01       	movw	r12, r22
    368c:	8a 01       	movw	r16, r20
    368e:	fc 01       	movw	r30, r24
    3690:	16 82       	std	Z+6, r1	; 0x06
    3692:	17 82       	std	Z+7, r1	; 0x07
    3694:	83 81       	ldd	r24, Z+3	; 0x03
    3696:	81 ff       	sbrs	r24, 1
    3698:	b0 c1       	rjmp	.+864    	; 0x39fa <vfprintf+0x3a0>
    369a:	ce 01       	movw	r24, r28
    369c:	01 96       	adiw	r24, 0x01	; 1
    369e:	4c 01       	movw	r8, r24
    36a0:	f7 01       	movw	r30, r14
    36a2:	93 81       	ldd	r25, Z+3	; 0x03
    36a4:	f6 01       	movw	r30, r12
    36a6:	93 fd       	sbrc	r25, 3
    36a8:	85 91       	lpm	r24, Z+
    36aa:	93 ff       	sbrs	r25, 3
    36ac:	81 91       	ld	r24, Z+
    36ae:	6f 01       	movw	r12, r30
    36b0:	88 23       	and	r24, r24
    36b2:	09 f4       	brne	.+2      	; 0x36b6 <vfprintf+0x5c>
    36b4:	9e c1       	rjmp	.+828    	; 0x39f2 <vfprintf+0x398>
    36b6:	85 32       	cpi	r24, 0x25	; 37
    36b8:	39 f4       	brne	.+14     	; 0x36c8 <vfprintf+0x6e>
    36ba:	93 fd       	sbrc	r25, 3
    36bc:	85 91       	lpm	r24, Z+
    36be:	93 ff       	sbrs	r25, 3
    36c0:	81 91       	ld	r24, Z+
    36c2:	6f 01       	movw	r12, r30
    36c4:	85 32       	cpi	r24, 0x25	; 37
    36c6:	21 f4       	brne	.+8      	; 0x36d0 <vfprintf+0x76>
    36c8:	b7 01       	movw	r22, r14
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	c4 d1       	rcall	.+904    	; 0x3a56 <fputc>
    36ce:	e8 cf       	rjmp	.-48     	; 0x36a0 <vfprintf+0x46>
    36d0:	51 2c       	mov	r5, r1
    36d2:	31 2c       	mov	r3, r1
    36d4:	20 e0       	ldi	r18, 0x00	; 0
    36d6:	20 32       	cpi	r18, 0x20	; 32
    36d8:	a0 f4       	brcc	.+40     	; 0x3702 <vfprintf+0xa8>
    36da:	8b 32       	cpi	r24, 0x2B	; 43
    36dc:	69 f0       	breq	.+26     	; 0x36f8 <vfprintf+0x9e>
    36de:	30 f4       	brcc	.+12     	; 0x36ec <vfprintf+0x92>
    36e0:	80 32       	cpi	r24, 0x20	; 32
    36e2:	59 f0       	breq	.+22     	; 0x36fa <vfprintf+0xa0>
    36e4:	83 32       	cpi	r24, 0x23	; 35
    36e6:	69 f4       	brne	.+26     	; 0x3702 <vfprintf+0xa8>
    36e8:	20 61       	ori	r18, 0x10	; 16
    36ea:	2c c0       	rjmp	.+88     	; 0x3744 <vfprintf+0xea>
    36ec:	8d 32       	cpi	r24, 0x2D	; 45
    36ee:	39 f0       	breq	.+14     	; 0x36fe <vfprintf+0xa4>
    36f0:	80 33       	cpi	r24, 0x30	; 48
    36f2:	39 f4       	brne	.+14     	; 0x3702 <vfprintf+0xa8>
    36f4:	21 60       	ori	r18, 0x01	; 1
    36f6:	26 c0       	rjmp	.+76     	; 0x3744 <vfprintf+0xea>
    36f8:	22 60       	ori	r18, 0x02	; 2
    36fa:	24 60       	ori	r18, 0x04	; 4
    36fc:	23 c0       	rjmp	.+70     	; 0x3744 <vfprintf+0xea>
    36fe:	28 60       	ori	r18, 0x08	; 8
    3700:	21 c0       	rjmp	.+66     	; 0x3744 <vfprintf+0xea>
    3702:	27 fd       	sbrc	r18, 7
    3704:	27 c0       	rjmp	.+78     	; 0x3754 <vfprintf+0xfa>
    3706:	30 ed       	ldi	r19, 0xD0	; 208
    3708:	38 0f       	add	r19, r24
    370a:	3a 30       	cpi	r19, 0x0A	; 10
    370c:	78 f4       	brcc	.+30     	; 0x372c <vfprintf+0xd2>
    370e:	26 ff       	sbrs	r18, 6
    3710:	06 c0       	rjmp	.+12     	; 0x371e <vfprintf+0xc4>
    3712:	fa e0       	ldi	r31, 0x0A	; 10
    3714:	5f 9e       	mul	r5, r31
    3716:	30 0d       	add	r19, r0
    3718:	11 24       	eor	r1, r1
    371a:	53 2e       	mov	r5, r19
    371c:	13 c0       	rjmp	.+38     	; 0x3744 <vfprintf+0xea>
    371e:	8a e0       	ldi	r24, 0x0A	; 10
    3720:	38 9e       	mul	r3, r24
    3722:	30 0d       	add	r19, r0
    3724:	11 24       	eor	r1, r1
    3726:	33 2e       	mov	r3, r19
    3728:	20 62       	ori	r18, 0x20	; 32
    372a:	0c c0       	rjmp	.+24     	; 0x3744 <vfprintf+0xea>
    372c:	8e 32       	cpi	r24, 0x2E	; 46
    372e:	21 f4       	brne	.+8      	; 0x3738 <vfprintf+0xde>
    3730:	26 fd       	sbrc	r18, 6
    3732:	5f c1       	rjmp	.+702    	; 0x39f2 <vfprintf+0x398>
    3734:	20 64       	ori	r18, 0x40	; 64
    3736:	06 c0       	rjmp	.+12     	; 0x3744 <vfprintf+0xea>
    3738:	8c 36       	cpi	r24, 0x6C	; 108
    373a:	11 f4       	brne	.+4      	; 0x3740 <vfprintf+0xe6>
    373c:	20 68       	ori	r18, 0x80	; 128
    373e:	02 c0       	rjmp	.+4      	; 0x3744 <vfprintf+0xea>
    3740:	88 36       	cpi	r24, 0x68	; 104
    3742:	41 f4       	brne	.+16     	; 0x3754 <vfprintf+0xfa>
    3744:	f6 01       	movw	r30, r12
    3746:	93 fd       	sbrc	r25, 3
    3748:	85 91       	lpm	r24, Z+
    374a:	93 ff       	sbrs	r25, 3
    374c:	81 91       	ld	r24, Z+
    374e:	6f 01       	movw	r12, r30
    3750:	81 11       	cpse	r24, r1
    3752:	c1 cf       	rjmp	.-126    	; 0x36d6 <vfprintf+0x7c>
    3754:	98 2f       	mov	r25, r24
    3756:	9f 7d       	andi	r25, 0xDF	; 223
    3758:	95 54       	subi	r25, 0x45	; 69
    375a:	93 30       	cpi	r25, 0x03	; 3
    375c:	28 f4       	brcc	.+10     	; 0x3768 <vfprintf+0x10e>
    375e:	0c 5f       	subi	r16, 0xFC	; 252
    3760:	1f 4f       	sbci	r17, 0xFF	; 255
    3762:	ff e3       	ldi	r31, 0x3F	; 63
    3764:	f9 83       	std	Y+1, r31	; 0x01
    3766:	0d c0       	rjmp	.+26     	; 0x3782 <vfprintf+0x128>
    3768:	83 36       	cpi	r24, 0x63	; 99
    376a:	31 f0       	breq	.+12     	; 0x3778 <vfprintf+0x11e>
    376c:	83 37       	cpi	r24, 0x73	; 115
    376e:	71 f0       	breq	.+28     	; 0x378c <vfprintf+0x132>
    3770:	83 35       	cpi	r24, 0x53	; 83
    3772:	09 f0       	breq	.+2      	; 0x3776 <vfprintf+0x11c>
    3774:	57 c0       	rjmp	.+174    	; 0x3824 <vfprintf+0x1ca>
    3776:	21 c0       	rjmp	.+66     	; 0x37ba <vfprintf+0x160>
    3778:	f8 01       	movw	r30, r16
    377a:	80 81       	ld	r24, Z
    377c:	89 83       	std	Y+1, r24	; 0x01
    377e:	0e 5f       	subi	r16, 0xFE	; 254
    3780:	1f 4f       	sbci	r17, 0xFF	; 255
    3782:	44 24       	eor	r4, r4
    3784:	43 94       	inc	r4
    3786:	51 2c       	mov	r5, r1
    3788:	54 01       	movw	r10, r8
    378a:	14 c0       	rjmp	.+40     	; 0x37b4 <vfprintf+0x15a>
    378c:	38 01       	movw	r6, r16
    378e:	f2 e0       	ldi	r31, 0x02	; 2
    3790:	6f 0e       	add	r6, r31
    3792:	71 1c       	adc	r7, r1
    3794:	f8 01       	movw	r30, r16
    3796:	a0 80       	ld	r10, Z
    3798:	b1 80       	ldd	r11, Z+1	; 0x01
    379a:	26 ff       	sbrs	r18, 6
    379c:	03 c0       	rjmp	.+6      	; 0x37a4 <vfprintf+0x14a>
    379e:	65 2d       	mov	r22, r5
    37a0:	70 e0       	ldi	r23, 0x00	; 0
    37a2:	02 c0       	rjmp	.+4      	; 0x37a8 <vfprintf+0x14e>
    37a4:	6f ef       	ldi	r22, 0xFF	; 255
    37a6:	7f ef       	ldi	r23, 0xFF	; 255
    37a8:	c5 01       	movw	r24, r10
    37aa:	2c 87       	std	Y+12, r18	; 0x0c
    37ac:	49 d1       	rcall	.+658    	; 0x3a40 <strnlen>
    37ae:	2c 01       	movw	r4, r24
    37b0:	83 01       	movw	r16, r6
    37b2:	2c 85       	ldd	r18, Y+12	; 0x0c
    37b4:	2f 77       	andi	r18, 0x7F	; 127
    37b6:	22 2e       	mov	r2, r18
    37b8:	16 c0       	rjmp	.+44     	; 0x37e6 <vfprintf+0x18c>
    37ba:	38 01       	movw	r6, r16
    37bc:	f2 e0       	ldi	r31, 0x02	; 2
    37be:	6f 0e       	add	r6, r31
    37c0:	71 1c       	adc	r7, r1
    37c2:	f8 01       	movw	r30, r16
    37c4:	a0 80       	ld	r10, Z
    37c6:	b1 80       	ldd	r11, Z+1	; 0x01
    37c8:	26 ff       	sbrs	r18, 6
    37ca:	03 c0       	rjmp	.+6      	; 0x37d2 <vfprintf+0x178>
    37cc:	65 2d       	mov	r22, r5
    37ce:	70 e0       	ldi	r23, 0x00	; 0
    37d0:	02 c0       	rjmp	.+4      	; 0x37d6 <vfprintf+0x17c>
    37d2:	6f ef       	ldi	r22, 0xFF	; 255
    37d4:	7f ef       	ldi	r23, 0xFF	; 255
    37d6:	c5 01       	movw	r24, r10
    37d8:	2c 87       	std	Y+12, r18	; 0x0c
    37da:	27 d1       	rcall	.+590    	; 0x3a2a <strnlen_P>
    37dc:	2c 01       	movw	r4, r24
    37de:	2c 85       	ldd	r18, Y+12	; 0x0c
    37e0:	20 68       	ori	r18, 0x80	; 128
    37e2:	22 2e       	mov	r2, r18
    37e4:	83 01       	movw	r16, r6
    37e6:	23 fc       	sbrc	r2, 3
    37e8:	19 c0       	rjmp	.+50     	; 0x381c <vfprintf+0x1c2>
    37ea:	83 2d       	mov	r24, r3
    37ec:	90 e0       	ldi	r25, 0x00	; 0
    37ee:	48 16       	cp	r4, r24
    37f0:	59 06       	cpc	r5, r25
    37f2:	a0 f4       	brcc	.+40     	; 0x381c <vfprintf+0x1c2>
    37f4:	b7 01       	movw	r22, r14
    37f6:	80 e2       	ldi	r24, 0x20	; 32
    37f8:	90 e0       	ldi	r25, 0x00	; 0
    37fa:	2d d1       	rcall	.+602    	; 0x3a56 <fputc>
    37fc:	3a 94       	dec	r3
    37fe:	f5 cf       	rjmp	.-22     	; 0x37ea <vfprintf+0x190>
    3800:	f5 01       	movw	r30, r10
    3802:	27 fc       	sbrc	r2, 7
    3804:	85 91       	lpm	r24, Z+
    3806:	27 fe       	sbrs	r2, 7
    3808:	81 91       	ld	r24, Z+
    380a:	5f 01       	movw	r10, r30
    380c:	b7 01       	movw	r22, r14
    380e:	90 e0       	ldi	r25, 0x00	; 0
    3810:	22 d1       	rcall	.+580    	; 0x3a56 <fputc>
    3812:	31 10       	cpse	r3, r1
    3814:	3a 94       	dec	r3
    3816:	f1 e0       	ldi	r31, 0x01	; 1
    3818:	4f 1a       	sub	r4, r31
    381a:	51 08       	sbc	r5, r1
    381c:	41 14       	cp	r4, r1
    381e:	51 04       	cpc	r5, r1
    3820:	79 f7       	brne	.-34     	; 0x3800 <vfprintf+0x1a6>
    3822:	de c0       	rjmp	.+444    	; 0x39e0 <vfprintf+0x386>
    3824:	84 36       	cpi	r24, 0x64	; 100
    3826:	11 f0       	breq	.+4      	; 0x382c <vfprintf+0x1d2>
    3828:	89 36       	cpi	r24, 0x69	; 105
    382a:	31 f5       	brne	.+76     	; 0x3878 <vfprintf+0x21e>
    382c:	f8 01       	movw	r30, r16
    382e:	27 ff       	sbrs	r18, 7
    3830:	07 c0       	rjmp	.+14     	; 0x3840 <vfprintf+0x1e6>
    3832:	60 81       	ld	r22, Z
    3834:	71 81       	ldd	r23, Z+1	; 0x01
    3836:	82 81       	ldd	r24, Z+2	; 0x02
    3838:	93 81       	ldd	r25, Z+3	; 0x03
    383a:	0c 5f       	subi	r16, 0xFC	; 252
    383c:	1f 4f       	sbci	r17, 0xFF	; 255
    383e:	08 c0       	rjmp	.+16     	; 0x3850 <vfprintf+0x1f6>
    3840:	60 81       	ld	r22, Z
    3842:	71 81       	ldd	r23, Z+1	; 0x01
    3844:	07 2e       	mov	r0, r23
    3846:	00 0c       	add	r0, r0
    3848:	88 0b       	sbc	r24, r24
    384a:	99 0b       	sbc	r25, r25
    384c:	0e 5f       	subi	r16, 0xFE	; 254
    384e:	1f 4f       	sbci	r17, 0xFF	; 255
    3850:	2f 76       	andi	r18, 0x6F	; 111
    3852:	72 2e       	mov	r7, r18
    3854:	97 ff       	sbrs	r25, 7
    3856:	09 c0       	rjmp	.+18     	; 0x386a <vfprintf+0x210>
    3858:	90 95       	com	r25
    385a:	80 95       	com	r24
    385c:	70 95       	com	r23
    385e:	61 95       	neg	r22
    3860:	7f 4f       	sbci	r23, 0xFF	; 255
    3862:	8f 4f       	sbci	r24, 0xFF	; 255
    3864:	9f 4f       	sbci	r25, 0xFF	; 255
    3866:	20 68       	ori	r18, 0x80	; 128
    3868:	72 2e       	mov	r7, r18
    386a:	2a e0       	ldi	r18, 0x0A	; 10
    386c:	30 e0       	ldi	r19, 0x00	; 0
    386e:	a4 01       	movw	r20, r8
    3870:	2a d1       	rcall	.+596    	; 0x3ac6 <__ultoa_invert>
    3872:	a8 2e       	mov	r10, r24
    3874:	a8 18       	sub	r10, r8
    3876:	43 c0       	rjmp	.+134    	; 0x38fe <vfprintf+0x2a4>
    3878:	85 37       	cpi	r24, 0x75	; 117
    387a:	29 f4       	brne	.+10     	; 0x3886 <vfprintf+0x22c>
    387c:	2f 7e       	andi	r18, 0xEF	; 239
    387e:	b2 2e       	mov	r11, r18
    3880:	2a e0       	ldi	r18, 0x0A	; 10
    3882:	30 e0       	ldi	r19, 0x00	; 0
    3884:	25 c0       	rjmp	.+74     	; 0x38d0 <vfprintf+0x276>
    3886:	f2 2f       	mov	r31, r18
    3888:	f9 7f       	andi	r31, 0xF9	; 249
    388a:	bf 2e       	mov	r11, r31
    388c:	8f 36       	cpi	r24, 0x6F	; 111
    388e:	c1 f0       	breq	.+48     	; 0x38c0 <vfprintf+0x266>
    3890:	18 f4       	brcc	.+6      	; 0x3898 <vfprintf+0x23e>
    3892:	88 35       	cpi	r24, 0x58	; 88
    3894:	79 f0       	breq	.+30     	; 0x38b4 <vfprintf+0x25a>
    3896:	ad c0       	rjmp	.+346    	; 0x39f2 <vfprintf+0x398>
    3898:	80 37       	cpi	r24, 0x70	; 112
    389a:	19 f0       	breq	.+6      	; 0x38a2 <vfprintf+0x248>
    389c:	88 37       	cpi	r24, 0x78	; 120
    389e:	21 f0       	breq	.+8      	; 0x38a8 <vfprintf+0x24e>
    38a0:	a8 c0       	rjmp	.+336    	; 0x39f2 <vfprintf+0x398>
    38a2:	2f 2f       	mov	r18, r31
    38a4:	20 61       	ori	r18, 0x10	; 16
    38a6:	b2 2e       	mov	r11, r18
    38a8:	b4 fe       	sbrs	r11, 4
    38aa:	0d c0       	rjmp	.+26     	; 0x38c6 <vfprintf+0x26c>
    38ac:	8b 2d       	mov	r24, r11
    38ae:	84 60       	ori	r24, 0x04	; 4
    38b0:	b8 2e       	mov	r11, r24
    38b2:	09 c0       	rjmp	.+18     	; 0x38c6 <vfprintf+0x26c>
    38b4:	24 ff       	sbrs	r18, 4
    38b6:	0a c0       	rjmp	.+20     	; 0x38cc <vfprintf+0x272>
    38b8:	9f 2f       	mov	r25, r31
    38ba:	96 60       	ori	r25, 0x06	; 6
    38bc:	b9 2e       	mov	r11, r25
    38be:	06 c0       	rjmp	.+12     	; 0x38cc <vfprintf+0x272>
    38c0:	28 e0       	ldi	r18, 0x08	; 8
    38c2:	30 e0       	ldi	r19, 0x00	; 0
    38c4:	05 c0       	rjmp	.+10     	; 0x38d0 <vfprintf+0x276>
    38c6:	20 e1       	ldi	r18, 0x10	; 16
    38c8:	30 e0       	ldi	r19, 0x00	; 0
    38ca:	02 c0       	rjmp	.+4      	; 0x38d0 <vfprintf+0x276>
    38cc:	20 e1       	ldi	r18, 0x10	; 16
    38ce:	32 e0       	ldi	r19, 0x02	; 2
    38d0:	f8 01       	movw	r30, r16
    38d2:	b7 fe       	sbrs	r11, 7
    38d4:	07 c0       	rjmp	.+14     	; 0x38e4 <vfprintf+0x28a>
    38d6:	60 81       	ld	r22, Z
    38d8:	71 81       	ldd	r23, Z+1	; 0x01
    38da:	82 81       	ldd	r24, Z+2	; 0x02
    38dc:	93 81       	ldd	r25, Z+3	; 0x03
    38de:	0c 5f       	subi	r16, 0xFC	; 252
    38e0:	1f 4f       	sbci	r17, 0xFF	; 255
    38e2:	06 c0       	rjmp	.+12     	; 0x38f0 <vfprintf+0x296>
    38e4:	60 81       	ld	r22, Z
    38e6:	71 81       	ldd	r23, Z+1	; 0x01
    38e8:	80 e0       	ldi	r24, 0x00	; 0
    38ea:	90 e0       	ldi	r25, 0x00	; 0
    38ec:	0e 5f       	subi	r16, 0xFE	; 254
    38ee:	1f 4f       	sbci	r17, 0xFF	; 255
    38f0:	a4 01       	movw	r20, r8
    38f2:	e9 d0       	rcall	.+466    	; 0x3ac6 <__ultoa_invert>
    38f4:	a8 2e       	mov	r10, r24
    38f6:	a8 18       	sub	r10, r8
    38f8:	fb 2d       	mov	r31, r11
    38fa:	ff 77       	andi	r31, 0x7F	; 127
    38fc:	7f 2e       	mov	r7, r31
    38fe:	76 fe       	sbrs	r7, 6
    3900:	0b c0       	rjmp	.+22     	; 0x3918 <vfprintf+0x2be>
    3902:	37 2d       	mov	r19, r7
    3904:	3e 7f       	andi	r19, 0xFE	; 254
    3906:	a5 14       	cp	r10, r5
    3908:	50 f4       	brcc	.+20     	; 0x391e <vfprintf+0x2c4>
    390a:	74 fe       	sbrs	r7, 4
    390c:	0a c0       	rjmp	.+20     	; 0x3922 <vfprintf+0x2c8>
    390e:	72 fc       	sbrc	r7, 2
    3910:	08 c0       	rjmp	.+16     	; 0x3922 <vfprintf+0x2c8>
    3912:	37 2d       	mov	r19, r7
    3914:	3e 7e       	andi	r19, 0xEE	; 238
    3916:	05 c0       	rjmp	.+10     	; 0x3922 <vfprintf+0x2c8>
    3918:	ba 2c       	mov	r11, r10
    391a:	37 2d       	mov	r19, r7
    391c:	03 c0       	rjmp	.+6      	; 0x3924 <vfprintf+0x2ca>
    391e:	ba 2c       	mov	r11, r10
    3920:	01 c0       	rjmp	.+2      	; 0x3924 <vfprintf+0x2ca>
    3922:	b5 2c       	mov	r11, r5
    3924:	34 ff       	sbrs	r19, 4
    3926:	0d c0       	rjmp	.+26     	; 0x3942 <vfprintf+0x2e8>
    3928:	fe 01       	movw	r30, r28
    392a:	ea 0d       	add	r30, r10
    392c:	f1 1d       	adc	r31, r1
    392e:	80 81       	ld	r24, Z
    3930:	80 33       	cpi	r24, 0x30	; 48
    3932:	11 f4       	brne	.+4      	; 0x3938 <vfprintf+0x2de>
    3934:	39 7e       	andi	r19, 0xE9	; 233
    3936:	09 c0       	rjmp	.+18     	; 0x394a <vfprintf+0x2f0>
    3938:	32 ff       	sbrs	r19, 2
    393a:	06 c0       	rjmp	.+12     	; 0x3948 <vfprintf+0x2ee>
    393c:	b3 94       	inc	r11
    393e:	b3 94       	inc	r11
    3940:	04 c0       	rjmp	.+8      	; 0x394a <vfprintf+0x2f0>
    3942:	83 2f       	mov	r24, r19
    3944:	86 78       	andi	r24, 0x86	; 134
    3946:	09 f0       	breq	.+2      	; 0x394a <vfprintf+0x2f0>
    3948:	b3 94       	inc	r11
    394a:	33 fd       	sbrc	r19, 3
    394c:	12 c0       	rjmp	.+36     	; 0x3972 <vfprintf+0x318>
    394e:	30 ff       	sbrs	r19, 0
    3950:	06 c0       	rjmp	.+12     	; 0x395e <vfprintf+0x304>
    3952:	5a 2c       	mov	r5, r10
    3954:	b3 14       	cp	r11, r3
    3956:	18 f4       	brcc	.+6      	; 0x395e <vfprintf+0x304>
    3958:	53 0c       	add	r5, r3
    395a:	5b 18       	sub	r5, r11
    395c:	b3 2c       	mov	r11, r3
    395e:	b3 14       	cp	r11, r3
    3960:	60 f4       	brcc	.+24     	; 0x397a <vfprintf+0x320>
    3962:	b7 01       	movw	r22, r14
    3964:	80 e2       	ldi	r24, 0x20	; 32
    3966:	90 e0       	ldi	r25, 0x00	; 0
    3968:	3c 87       	std	Y+12, r19	; 0x0c
    396a:	75 d0       	rcall	.+234    	; 0x3a56 <fputc>
    396c:	b3 94       	inc	r11
    396e:	3c 85       	ldd	r19, Y+12	; 0x0c
    3970:	f6 cf       	rjmp	.-20     	; 0x395e <vfprintf+0x304>
    3972:	b3 14       	cp	r11, r3
    3974:	10 f4       	brcc	.+4      	; 0x397a <vfprintf+0x320>
    3976:	3b 18       	sub	r3, r11
    3978:	01 c0       	rjmp	.+2      	; 0x397c <vfprintf+0x322>
    397a:	31 2c       	mov	r3, r1
    397c:	34 ff       	sbrs	r19, 4
    397e:	11 c0       	rjmp	.+34     	; 0x39a2 <vfprintf+0x348>
    3980:	b7 01       	movw	r22, r14
    3982:	80 e3       	ldi	r24, 0x30	; 48
    3984:	90 e0       	ldi	r25, 0x00	; 0
    3986:	3c 87       	std	Y+12, r19	; 0x0c
    3988:	66 d0       	rcall	.+204    	; 0x3a56 <fputc>
    398a:	3c 85       	ldd	r19, Y+12	; 0x0c
    398c:	32 ff       	sbrs	r19, 2
    398e:	16 c0       	rjmp	.+44     	; 0x39bc <vfprintf+0x362>
    3990:	31 fd       	sbrc	r19, 1
    3992:	03 c0       	rjmp	.+6      	; 0x399a <vfprintf+0x340>
    3994:	88 e7       	ldi	r24, 0x78	; 120
    3996:	90 e0       	ldi	r25, 0x00	; 0
    3998:	02 c0       	rjmp	.+4      	; 0x399e <vfprintf+0x344>
    399a:	88 e5       	ldi	r24, 0x58	; 88
    399c:	90 e0       	ldi	r25, 0x00	; 0
    399e:	b7 01       	movw	r22, r14
    39a0:	0c c0       	rjmp	.+24     	; 0x39ba <vfprintf+0x360>
    39a2:	83 2f       	mov	r24, r19
    39a4:	86 78       	andi	r24, 0x86	; 134
    39a6:	51 f0       	breq	.+20     	; 0x39bc <vfprintf+0x362>
    39a8:	31 ff       	sbrs	r19, 1
    39aa:	02 c0       	rjmp	.+4      	; 0x39b0 <vfprintf+0x356>
    39ac:	8b e2       	ldi	r24, 0x2B	; 43
    39ae:	01 c0       	rjmp	.+2      	; 0x39b2 <vfprintf+0x358>
    39b0:	80 e2       	ldi	r24, 0x20	; 32
    39b2:	37 fd       	sbrc	r19, 7
    39b4:	8d e2       	ldi	r24, 0x2D	; 45
    39b6:	b7 01       	movw	r22, r14
    39b8:	90 e0       	ldi	r25, 0x00	; 0
    39ba:	4d d0       	rcall	.+154    	; 0x3a56 <fputc>
    39bc:	a5 14       	cp	r10, r5
    39be:	30 f4       	brcc	.+12     	; 0x39cc <vfprintf+0x372>
    39c0:	b7 01       	movw	r22, r14
    39c2:	80 e3       	ldi	r24, 0x30	; 48
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	47 d0       	rcall	.+142    	; 0x3a56 <fputc>
    39c8:	5a 94       	dec	r5
    39ca:	f8 cf       	rjmp	.-16     	; 0x39bc <vfprintf+0x362>
    39cc:	aa 94       	dec	r10
    39ce:	f4 01       	movw	r30, r8
    39d0:	ea 0d       	add	r30, r10
    39d2:	f1 1d       	adc	r31, r1
    39d4:	80 81       	ld	r24, Z
    39d6:	b7 01       	movw	r22, r14
    39d8:	90 e0       	ldi	r25, 0x00	; 0
    39da:	3d d0       	rcall	.+122    	; 0x3a56 <fputc>
    39dc:	a1 10       	cpse	r10, r1
    39de:	f6 cf       	rjmp	.-20     	; 0x39cc <vfprintf+0x372>
    39e0:	33 20       	and	r3, r3
    39e2:	09 f4       	brne	.+2      	; 0x39e6 <vfprintf+0x38c>
    39e4:	5d ce       	rjmp	.-838    	; 0x36a0 <vfprintf+0x46>
    39e6:	b7 01       	movw	r22, r14
    39e8:	80 e2       	ldi	r24, 0x20	; 32
    39ea:	90 e0       	ldi	r25, 0x00	; 0
    39ec:	34 d0       	rcall	.+104    	; 0x3a56 <fputc>
    39ee:	3a 94       	dec	r3
    39f0:	f7 cf       	rjmp	.-18     	; 0x39e0 <vfprintf+0x386>
    39f2:	f7 01       	movw	r30, r14
    39f4:	86 81       	ldd	r24, Z+6	; 0x06
    39f6:	97 81       	ldd	r25, Z+7	; 0x07
    39f8:	02 c0       	rjmp	.+4      	; 0x39fe <vfprintf+0x3a4>
    39fa:	8f ef       	ldi	r24, 0xFF	; 255
    39fc:	9f ef       	ldi	r25, 0xFF	; 255
    39fe:	2c 96       	adiw	r28, 0x0c	; 12
    3a00:	cd bf       	out	0x3d, r28	; 61
    3a02:	de bf       	out	0x3e, r29	; 62
    3a04:	df 91       	pop	r29
    3a06:	cf 91       	pop	r28
    3a08:	1f 91       	pop	r17
    3a0a:	0f 91       	pop	r16
    3a0c:	ff 90       	pop	r15
    3a0e:	ef 90       	pop	r14
    3a10:	df 90       	pop	r13
    3a12:	cf 90       	pop	r12
    3a14:	bf 90       	pop	r11
    3a16:	af 90       	pop	r10
    3a18:	9f 90       	pop	r9
    3a1a:	8f 90       	pop	r8
    3a1c:	7f 90       	pop	r7
    3a1e:	6f 90       	pop	r6
    3a20:	5f 90       	pop	r5
    3a22:	4f 90       	pop	r4
    3a24:	3f 90       	pop	r3
    3a26:	2f 90       	pop	r2
    3a28:	08 95       	ret

00003a2a <strnlen_P>:
    3a2a:	fc 01       	movw	r30, r24
    3a2c:	05 90       	lpm	r0, Z+
    3a2e:	61 50       	subi	r22, 0x01	; 1
    3a30:	70 40       	sbci	r23, 0x00	; 0
    3a32:	01 10       	cpse	r0, r1
    3a34:	d8 f7       	brcc	.-10     	; 0x3a2c <strnlen_P+0x2>
    3a36:	80 95       	com	r24
    3a38:	90 95       	com	r25
    3a3a:	8e 0f       	add	r24, r30
    3a3c:	9f 1f       	adc	r25, r31
    3a3e:	08 95       	ret

00003a40 <strnlen>:
    3a40:	fc 01       	movw	r30, r24
    3a42:	61 50       	subi	r22, 0x01	; 1
    3a44:	70 40       	sbci	r23, 0x00	; 0
    3a46:	01 90       	ld	r0, Z+
    3a48:	01 10       	cpse	r0, r1
    3a4a:	d8 f7       	brcc	.-10     	; 0x3a42 <strnlen+0x2>
    3a4c:	80 95       	com	r24
    3a4e:	90 95       	com	r25
    3a50:	8e 0f       	add	r24, r30
    3a52:	9f 1f       	adc	r25, r31
    3a54:	08 95       	ret

00003a56 <fputc>:
    3a56:	0f 93       	push	r16
    3a58:	1f 93       	push	r17
    3a5a:	cf 93       	push	r28
    3a5c:	df 93       	push	r29
    3a5e:	fb 01       	movw	r30, r22
    3a60:	23 81       	ldd	r18, Z+3	; 0x03
    3a62:	21 fd       	sbrc	r18, 1
    3a64:	03 c0       	rjmp	.+6      	; 0x3a6c <fputc+0x16>
    3a66:	8f ef       	ldi	r24, 0xFF	; 255
    3a68:	9f ef       	ldi	r25, 0xFF	; 255
    3a6a:	28 c0       	rjmp	.+80     	; 0x3abc <fputc+0x66>
    3a6c:	22 ff       	sbrs	r18, 2
    3a6e:	16 c0       	rjmp	.+44     	; 0x3a9c <fputc+0x46>
    3a70:	46 81       	ldd	r20, Z+6	; 0x06
    3a72:	57 81       	ldd	r21, Z+7	; 0x07
    3a74:	24 81       	ldd	r18, Z+4	; 0x04
    3a76:	35 81       	ldd	r19, Z+5	; 0x05
    3a78:	42 17       	cp	r20, r18
    3a7a:	53 07       	cpc	r21, r19
    3a7c:	44 f4       	brge	.+16     	; 0x3a8e <fputc+0x38>
    3a7e:	a0 81       	ld	r26, Z
    3a80:	b1 81       	ldd	r27, Z+1	; 0x01
    3a82:	9d 01       	movw	r18, r26
    3a84:	2f 5f       	subi	r18, 0xFF	; 255
    3a86:	3f 4f       	sbci	r19, 0xFF	; 255
    3a88:	20 83       	st	Z, r18
    3a8a:	31 83       	std	Z+1, r19	; 0x01
    3a8c:	8c 93       	st	X, r24
    3a8e:	26 81       	ldd	r18, Z+6	; 0x06
    3a90:	37 81       	ldd	r19, Z+7	; 0x07
    3a92:	2f 5f       	subi	r18, 0xFF	; 255
    3a94:	3f 4f       	sbci	r19, 0xFF	; 255
    3a96:	26 83       	std	Z+6, r18	; 0x06
    3a98:	37 83       	std	Z+7, r19	; 0x07
    3a9a:	10 c0       	rjmp	.+32     	; 0x3abc <fputc+0x66>
    3a9c:	eb 01       	movw	r28, r22
    3a9e:	09 2f       	mov	r16, r25
    3aa0:	18 2f       	mov	r17, r24
    3aa2:	00 84       	ldd	r0, Z+8	; 0x08
    3aa4:	f1 85       	ldd	r31, Z+9	; 0x09
    3aa6:	e0 2d       	mov	r30, r0
    3aa8:	19 95       	eicall
    3aaa:	89 2b       	or	r24, r25
    3aac:	e1 f6       	brne	.-72     	; 0x3a66 <fputc+0x10>
    3aae:	8e 81       	ldd	r24, Y+6	; 0x06
    3ab0:	9f 81       	ldd	r25, Y+7	; 0x07
    3ab2:	01 96       	adiw	r24, 0x01	; 1
    3ab4:	8e 83       	std	Y+6, r24	; 0x06
    3ab6:	9f 83       	std	Y+7, r25	; 0x07
    3ab8:	81 2f       	mov	r24, r17
    3aba:	90 2f       	mov	r25, r16
    3abc:	df 91       	pop	r29
    3abe:	cf 91       	pop	r28
    3ac0:	1f 91       	pop	r17
    3ac2:	0f 91       	pop	r16
    3ac4:	08 95       	ret

00003ac6 <__ultoa_invert>:
    3ac6:	fa 01       	movw	r30, r20
    3ac8:	aa 27       	eor	r26, r26
    3aca:	28 30       	cpi	r18, 0x08	; 8
    3acc:	51 f1       	breq	.+84     	; 0x3b22 <__ultoa_invert+0x5c>
    3ace:	20 31       	cpi	r18, 0x10	; 16
    3ad0:	81 f1       	breq	.+96     	; 0x3b32 <__ultoa_invert+0x6c>
    3ad2:	e8 94       	clt
    3ad4:	6f 93       	push	r22
    3ad6:	6e 7f       	andi	r22, 0xFE	; 254
    3ad8:	6e 5f       	subi	r22, 0xFE	; 254
    3ada:	7f 4f       	sbci	r23, 0xFF	; 255
    3adc:	8f 4f       	sbci	r24, 0xFF	; 255
    3ade:	9f 4f       	sbci	r25, 0xFF	; 255
    3ae0:	af 4f       	sbci	r26, 0xFF	; 255
    3ae2:	b1 e0       	ldi	r27, 0x01	; 1
    3ae4:	3e d0       	rcall	.+124    	; 0x3b62 <__ultoa_invert+0x9c>
    3ae6:	b4 e0       	ldi	r27, 0x04	; 4
    3ae8:	3c d0       	rcall	.+120    	; 0x3b62 <__ultoa_invert+0x9c>
    3aea:	67 0f       	add	r22, r23
    3aec:	78 1f       	adc	r23, r24
    3aee:	89 1f       	adc	r24, r25
    3af0:	9a 1f       	adc	r25, r26
    3af2:	a1 1d       	adc	r26, r1
    3af4:	68 0f       	add	r22, r24
    3af6:	79 1f       	adc	r23, r25
    3af8:	8a 1f       	adc	r24, r26
    3afa:	91 1d       	adc	r25, r1
    3afc:	a1 1d       	adc	r26, r1
    3afe:	6a 0f       	add	r22, r26
    3b00:	71 1d       	adc	r23, r1
    3b02:	81 1d       	adc	r24, r1
    3b04:	91 1d       	adc	r25, r1
    3b06:	a1 1d       	adc	r26, r1
    3b08:	20 d0       	rcall	.+64     	; 0x3b4a <__ultoa_invert+0x84>
    3b0a:	09 f4       	brne	.+2      	; 0x3b0e <__ultoa_invert+0x48>
    3b0c:	68 94       	set
    3b0e:	3f 91       	pop	r19
    3b10:	2a e0       	ldi	r18, 0x0A	; 10
    3b12:	26 9f       	mul	r18, r22
    3b14:	11 24       	eor	r1, r1
    3b16:	30 19       	sub	r19, r0
    3b18:	30 5d       	subi	r19, 0xD0	; 208
    3b1a:	31 93       	st	Z+, r19
    3b1c:	de f6       	brtc	.-74     	; 0x3ad4 <__ultoa_invert+0xe>
    3b1e:	cf 01       	movw	r24, r30
    3b20:	08 95       	ret
    3b22:	46 2f       	mov	r20, r22
    3b24:	47 70       	andi	r20, 0x07	; 7
    3b26:	40 5d       	subi	r20, 0xD0	; 208
    3b28:	41 93       	st	Z+, r20
    3b2a:	b3 e0       	ldi	r27, 0x03	; 3
    3b2c:	0f d0       	rcall	.+30     	; 0x3b4c <__ultoa_invert+0x86>
    3b2e:	c9 f7       	brne	.-14     	; 0x3b22 <__ultoa_invert+0x5c>
    3b30:	f6 cf       	rjmp	.-20     	; 0x3b1e <__ultoa_invert+0x58>
    3b32:	46 2f       	mov	r20, r22
    3b34:	4f 70       	andi	r20, 0x0F	; 15
    3b36:	40 5d       	subi	r20, 0xD0	; 208
    3b38:	4a 33       	cpi	r20, 0x3A	; 58
    3b3a:	18 f0       	brcs	.+6      	; 0x3b42 <__ultoa_invert+0x7c>
    3b3c:	49 5d       	subi	r20, 0xD9	; 217
    3b3e:	31 fd       	sbrc	r19, 1
    3b40:	40 52       	subi	r20, 0x20	; 32
    3b42:	41 93       	st	Z+, r20
    3b44:	02 d0       	rcall	.+4      	; 0x3b4a <__ultoa_invert+0x84>
    3b46:	a9 f7       	brne	.-22     	; 0x3b32 <__ultoa_invert+0x6c>
    3b48:	ea cf       	rjmp	.-44     	; 0x3b1e <__ultoa_invert+0x58>
    3b4a:	b4 e0       	ldi	r27, 0x04	; 4
    3b4c:	a6 95       	lsr	r26
    3b4e:	97 95       	ror	r25
    3b50:	87 95       	ror	r24
    3b52:	77 95       	ror	r23
    3b54:	67 95       	ror	r22
    3b56:	ba 95       	dec	r27
    3b58:	c9 f7       	brne	.-14     	; 0x3b4c <__ultoa_invert+0x86>
    3b5a:	00 97       	sbiw	r24, 0x00	; 0
    3b5c:	61 05       	cpc	r22, r1
    3b5e:	71 05       	cpc	r23, r1
    3b60:	08 95       	ret
    3b62:	9b 01       	movw	r18, r22
    3b64:	ac 01       	movw	r20, r24
    3b66:	0a 2e       	mov	r0, r26
    3b68:	06 94       	lsr	r0
    3b6a:	57 95       	ror	r21
    3b6c:	47 95       	ror	r20
    3b6e:	37 95       	ror	r19
    3b70:	27 95       	ror	r18
    3b72:	ba 95       	dec	r27
    3b74:	c9 f7       	brne	.-14     	; 0x3b68 <__ultoa_invert+0xa2>
    3b76:	62 0f       	add	r22, r18
    3b78:	73 1f       	adc	r23, r19
    3b7a:	84 1f       	adc	r24, r20
    3b7c:	95 1f       	adc	r25, r21
    3b7e:	a0 1d       	adc	r26, r0
    3b80:	08 95       	ret

00003b82 <_exit>:
    3b82:	f8 94       	cli

00003b84 <__stop_program>:
    3b84:	ff cf       	rjmp	.-2      	; 0x3b84 <__stop_program>
